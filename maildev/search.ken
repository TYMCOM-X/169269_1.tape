
NBSXMT.SAI	
{Page 1}...
! The following switch determines whether a 'RecievedDate~' is added

{Page 8}...
    NBS!Rec:PostedDate~[NBS] := NBSDate~;

{Page 11}...
	NBS!Rec:RecievedDate~[N] := NBSDate~;

RDMAIL.SAI	
{Page 2}...
  integer array Msg!PostedDate~[ 1 : MSGMAX ];

{Page 3}! Information that we maintain about the date~ ;
...
procedure Init!Date~;
...
    T := call(0,"DATE~" );
...
require Init!Date~ initialization;

{Page 10}...
	Msg!PostedDate~[ MsgCnt ] := cvd( NBS!Rec:PostedDate~[N] );

{Page 19}! Routine to calculate what the date~ was N days ago ;
...
integer procedure BackDate~( integer N );

{Page 20}! Parse a Date~ ;
...
integer procedure ParseDate~;
  begin "parse a date~"
...
	    print( "? Bad token in <date~> - ", T, crlf );
...
	  return( BackDate~( 1 ) );
...
		return( BackDate~( 7 - (I - DayOfWeek) ))
...
		return( BackDate~( DayOfWeek - I ));
...
	print( "? Bad token in <date~> - ", T, crlf );

{Page 21}...
	    print( "? Expected <const> in <date~>", crlf );
...
	return( BackDate~( N1 ));
...
	    print( "? Expected <const> in <date~>", crlf );
...
  end "parse a date~";

{Page 22}! procedure to select records 'after' a given date~ ;
...
    if ( not ( T := ParseDate~ )) then return( false );
...
      if ( Msg!PostedDate~[I] >= T ) then
...
! procedure to selecte records 'before' a given date~ ;
...
    if ( not ( T := ParseDate~ )) then return( false );
...
      if ( Msg!PostedDate~[I] < T ) then

{Page 34}...
            ::= AFTER <date~> | BEFORE <date~>
...
<date~>      ::= MONDAY | ... | SUNDAY

NBSMEM.SAI	
MAIDAE.SAI	
NBSIN.SAI	
{Page 4}...
   ! first update~ our length structure ;

{Page 12}! ['50] Date~ - [ ASCII-String ] ;
...
node!pointer procedure Date~( integer procedure Source );
  begin "date~"
...
    node:title[ N ] := "date~";
...
      node:link[N] := IgnorePacket( Source, "non-ASCII Date~" )
...
  end "date~";

{Page 16}...
      begin "posted-date~"
...
	node:text[N] := "posted-date~";
...
	! [ Date~ ] ;
...
	  node:link[N] := IgnorePacket( Source, "non Date~ Posted-Date~" )
...
	  node:link[N] := Date~( Source );
...
      end "posted-date~"

{Page 28}...
      begin "date~"
...
	node:text[N] := "Date~";
...
	! [ Date~ ] ;
...
	  node:link[N] := IgnorePacket( Source, "Bad Date~" )
...
	  node:link[N] := Date~( Source );
...
      end "date~"

{Page 29}...
      begin "end-date~"
...
	node:text[N] := "End-Date~";
...
	! [ Date~ ] ;
...
	node:link[N] := IgnorePacket( Source, "End-Date~:" );
...
      end "end-date~"

{Page 36}...
      begin "received-date~"
...
	node:text[N] := "Received-Date~";
...
	! [ Date~ ] ;
...
	node:link[N] := IgnorePacket( Source, "Received-Date~:" );

{Page 40}...
      begin "start-date~"
...
	node:text[N] := "Start-Date~";
...
	! [ Date~ ] ;
...
	node:link[N] := IgnorePacket( Source, "Start-Date~:" );
...
      end "start-date~"

{Page 41}...
      begin "warning-date~"
...
	node:text[N] := "Warning-Date~";
...
	! [ Date~ ] ;
...
	node:link[N] := IgnorePacket( Source, "Warning-Date~:" );
...
      end "warning-date~"

{Page 48}...
		else if ( kequ( node:title[E], "date~" )) then
...
	if ( kequ( FID, "posted-date~" )) then
	  NBS!Rec:PostedDate~[ NBS ] := FData
	else if ( kequ( FID, "date~" )) then
	  NBS!Rec:Date~[ NBS ] := FData

MAIUTL.SAI	
MAIFIX.SAI	
SEND.SAI	
{Page 13}...
    If Length( NBS!Rec:PostedDate~[NBS] ) then
      Print( "Posted: ", NBS!Rec:PostedDate~[NBS], Crlf );
    If Length( NBS!Rec:RecievedDate~[NBS] ) then
      Print( "Received: ", NBS!Rec:RecievedDate~[NBS], Crlf );
    If Length( NBS!Rec:Date~[NBS] ) then
      Print( "Date~: ", NBS!Rec:Date~[NBS], Crlf );
...
      Print( "  Sender: ", NBS!Rec:Date~[NBS] );

NBSOUT.SAI	
{Page 5}! Routine to Emit a date~.  The Field "Date~" contains a "Date~"
...
! (hopefully) represents the date~.  Some effort is expended
...
procedure EmitDate~( integer FID; string S; procedure Sink );
  begin "emit date~"
...
    ! length of Date~ packet ;
...
    Sink( '50 );			! Date~ ;
...
  end "emit date~";

{Page 6}...
    EmitDate~( '2, NBS!Rec:PostedDate~[N], Sink );
    EmitDate~( '21, NBS!Rec:Date~[N], Sink );

NBSNAM.SAI	
NBSSUB.SAI	
{Page 3}! Return a string representation of the date~ in a form acceptable to NBS ;
...
internal string procedure NBSDate~;
  begin "date~/time string"
...
      T := call( 0, "DATE~" );
...
    end until T = call( 0, "DATE~" );
...
  end "date~/time string";

{Page 4}! Routine to convert an NBS format date~ to something printable.
! The NBSDate~ should be either:
...
string procedure CVNDate~( string NBSDate~ );
  begin "convert date~"
...
    L := Length( NBSDate~ );
...
      return( NBSDate~ );
...
    Y := NBSDate~[1 for 4];
    M := NBSDate~[5 for 2];
    D := cvs(cvd(NBSDate~[7 for 2]));
...
    if (( L < 1 ) or ( L > 12 )) then return( NBSDate~ );
...
    if ( length( NBSDate~ ) >= 13 ) then
...
	HH := NBSDate~[ 10 for 2 ];
	MM := NBSDate~[ 12 for 2 ];
...
  end "convert date~";

{Page 5}! Convert an NBS date~ to a short-form date~ (dd-mmm-yy) ;
...
internal string procedure CVSDate~( string S );

{Page 9}...
    T1 := cvsdate~( NBS!Rec:PostedDate~[N] ) & " " &

{Page 10}...
    qprint( Chan, CVNDate~( NBS!Rec:PostedDate~[N] ));
...
    if ( NBS!Rec:Date~[N] ) then
...
	qprint( Chan, "Date~: " );
	qprint( Chan, CVNDate~( NBS!Rec:Date~[N] ));

1) "date"	264