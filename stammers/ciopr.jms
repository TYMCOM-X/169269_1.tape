TITLE CIOPR UUO TO FIDDLE WITH COMMUNICATIONS INTERFACE.
; ***********EXTENSIVE MODS 4-5-1980 BY JMS***********
IFCPU (KS),<	;ENDS ON LAST PAGE.
;DR11C hardware parameters.
DEFINE IOREG(REGISTERNAME,OFFSET,BITNAMES,MSB)
<BIT==100000
IFNB <MSB>,<BIT==MSB>
DR'REGISTERNAME==OFFSET
IRP BITNAMES,<REGISTERNAME'BITNAMES==BIT
BIT==BIT/2
>>
IOREG(CSR,0,<RB,,,,,,,,RA,IEA,IEB,,,,1,0>)
 DRFN==CSR0   ;Data ready for node (set by KS10 after loading OB).
 ODOFS==1	;High vector = dispatch when node's read OB.
 KRFMD==CSR1  ;KS10 ready for more data (set by KS10 after reading IB).
 IROFS==0	;Low vector = dispatch when node's written IB.
IOREG(OB,2)
IOREG(IB,4)
;Macro to make a DR11c known to the system.
;Since the concatenation operator can't be used outside of
; macro definitions, we have to use the SETxxx macros.
DEFINE SETBASEADDRESS(N,ADDRESS) <
DR'N'BA==ADDRESS
>
DEFINE SETVECTORADDRESS(N,ADDRESS) <
DR'N'VL==ADDRESS
>
DEFINE DR11C(BASEADDRESS,VECTORBASE) <
SETBASEADR(\NUMDR,BASEADDRESS)
SETVECTORADDRESS(\NUMDR,VECTORADDRESS)
IF1,<BLOCK 8>
IF2,<DRINTH(\NUMDR)>
NUMDR==NUMDR+1
>
NUMDR==0
;Insert definitions here.
DR11C(767770,300/4)
DR11C(767760,310/4)
DR11C(767750,320/4)
DR11C(767740,330/4)
;Macro to generate DR11C interrupt handlers for DR11C number N.
DEFINE DRINTH(N) <
DR'N'IRF:0
DR'N'IR:0
	SETOM DR'N'IRF
	JEN @DR'N'IR
DR'N'ODF:-1
DR'N'OD:0
	SETOM DR'N'ODF
	JEN @DR'N'OD
>;DEFINE DRINTH
DRIVTB:
DEFINE DRVECL(N) <
	DR'N'VL
>
IF1,<BLOCK NUMDR>
IF2,<
ZZ==0
REPEAT NUMDR,<
	DRVECL(\ZZ)
ZZ==ZZ+1
>>
DRFLTB:
DEFINE DRFLAG(N) <
	DR'N'IRF,,DR'N'ODF
>
IF1,<BLOCK NUMDR>
IF2,<
ZZ==0
REPEAT NUMDR,<
	DRFLAG(\ZZ)
ZZ==ZZ+1
>>
DRBATB:
DEFINE DRBADR(N) <
	3,,DR'N'BA
>
IF1,<BLOCK NUMDR>
IF2,<
ZZ==0
REPEAT NUMDR,<
	DRBADR(\ZZ)
ZZ==ZZ+1
>>
DR.BFN=0			;BAD FUNCTION NUMBER
DR.BDR=1			;BAD DR11C NUMBER
DR.TMO=2			;TIMEOUT ON DR WAIT
EXTERNAL DRDO,DRINI,CLKDR,CH7,EPT,CPOPJ1
CIOPR:: UMOVE T1,(W)		;T1:=<FN,,ADR OF ARG BLOCK>
	HLRZ T2,T1		;T2:=<FN>
	HRRZ T1,T1		;T1:=<ADR OF ARG BLOCK>
	UMOVE T1,(T1)		;T1:=<ARG BLOCK>
        HLRZ T3,T1		;T3:=<DR11C #>
        HRRZ T4,T1		;T4:=<ARGUMENT>
	CAILE T2,DLFTZ-1	;IN RANGE?
	  JRST [MOVEI TI,DR.BFN
		JRST DLEE]
	JRST @DLFT(T2)		;YES, EXECUTE FUNCTION.
DLFT:	EXP DLCDR,DLSDR,DLWDR,DLRDR,DRDDR
DLFTZ==.-DLFT
DLOK:	AOSA (P)
DLEE:	 UMOVEM T1,(W)		;ERROR CODE FOR USER.
	POPJ P,

;DLCDR FUNCTION: CLEAR COMMUNICATIONS INTERFACE.
; T3:=DR11C NUMBER
DLCDR:  PUSHJ P,DLGDR		; LOOK FOR DR11C
         JRST DLEE		; DOESN'T EXIST
        SKIPN DRDO		; ARE WE IN CTY MODE?
         JRST DLOK		; YES!!
       	MOVEI T1,0		; WRITE A ZERO
	ADDI T3,DRBATB		; TO THIS DR
	WRIO T1,DRCSR(T3)
	MOVEI T3,CH7
	MOVEI T2,CLKDR
	WRPI LI.PIF		;DISALLOW INTERRUPTS AND
      	SKIPA P2,T3		;UNLINK THE INTERRUPT CHAIN
DLUIR:	 SKIPA T3,T4		;PREVIOUS:=CURRENT
	  HRRZI T4,(T3)		;T3:=PREVIOUS
	HRRZ T4,1(T4)		;T4:=CURRENT
	CAIN T4,(P2)		;LOOPED AROUND?
	 JRST DLEE		;YES! DOESN'T EXIST- REJECT USER.
	CAIE T4,(T2)		;NO-FOUND IT?
	 JRST DLUIR		;NO-TRY AGAIN
       	MOVE T4,1(T4)		;PREVIOUS.NEXT:=CURRENT.NEXT.
	MOVEM T4,1(T3)		;GOT IT!
	WRPI LI.PIN		;ALLOW INTERRUPTS AGAIN
	JRST DLOK

;DLSDR FUNCTION: SELECT DR11C FOR LOADING
; T3:=DR11C #
DLSDR:	PUSHJ P,DLGDR		;GET HANDLES ON DR11C
	 JRST DLEE		;ERROR.
	HRRZ T4,EPT+103		;SETUP INTERRUPT VECTORS.
	ADD T4,DRIVTB(T3)
	HLRZ T1,DRFLTB(T3)
	ADD T1,[JSR 1]
	MOVEM T1,IROFS(T4)
	HRRZ T1,DRFLTB(T3)
	ADD T1,[JSR 1]
	MOVEM T1,ODOFS(T4)
	MOVEI T1,CSRIEA+CSRIEB	;ENABLE BOTH INTERRUPTS
	WRIO T1,DRCSR(P1)
	MOVEI T1,^D1000		;GIVE IT A CHANCE TO INTERRUPT
	SOJG T1,.		;ASSUME NO INT PENDING AFTER THIS.
	HLRZ T4,DRFLTB(T3)	;CLEAR INPUT READY FLAG
	SETZM (T4)
	HRRZ T4,DRFLTB(T3)	;SET DR11C READY FOR OUR OUTPUT FLAG
	SETOM (T4)
	JRST DLOK

;DLWDR FUNCTION: WRITE WORD TO SELECTED DR11C.
; T3:=DR11C #
; T4:=16 BIT WORD TO WRITE
DLWDR:	PUSHJ P,DLGDR		;GET DR11C BASE ADDRESS.
	 JRST DLEE		;ERROR.
	HRRZ T1,DRFLTB(T3)	;SEE IF PREVIOUS OUTPUT TAKEN.
	SKIPN (T1)
	 JSP T2,DLWAIT
	WRPI LI.PIF
	SETZM (T1)		;CLEAR TAKEN FLAG.
	WRIO T4,DROB(P1)	;SEND WORD
	MOVEI T4,DRFN
	BCIO T4,DRCSR(P1)
	BSIO T4,DRCSR(P1)	;IR INT FOR OTHER SIDE
	WRPI LI.PIN
	JRST DLOK

;DLRDR FUNCTION: READ WORD FROM SELECTED DR11C.
; T3:=DR11C #
; T4:=ADRESS OF USER WORD TO READ 16 BITS INTO
DLRDR:	PUSHJ P,DLGDR		;GET DR11C BASE ADDRESS.
	 JRST DLEE		;ERROR.
	HLRZ T1,DRFLTB(T3)
	SKIPN (T1)
	 JSP T2,DLWAIT
	WRPI LI.PIF
	SETZM (T1)		;CLEAR FLAG.
	RDIO T1,DRIB(P1)	;GET WORD
	UMOVEM T1,(T4)		;GIVE IT TO USER
	MOVEI T1,KRFMD
	BCIO T1,DRCSR(P1)
	BSIO T1,DRCSR(P1)
	WRPI LI.PIN
	JRST DLOK

;DLDDR FUNCTION.  DESELECT DR11C.
; T3:=DR11C #
DLDDR:	PUSHJ P,DLGDR		;GET HANDLES ON DR11C
	 JRST DLEE		;ERROR.
	HRRZ T4,DRFLTB(T3)	;MAKE SURE LAST OUTPUT TAKEN.
	SKIPN (T4)
	 JSP T2,DLWAIT
	MOVEI T1,0		;DISABLE INTERRUPTS
	WRIO T1,DRCSR(P1)
	WRPI LI.PIF		;REINSTALL DR11C DRIVER
        SETOM DRDO
        PUSHJ P,DRINI
    	WRPI LI.PIN
	JRST DLOK

;DLGDR.  LOAD P1 WITH UNIBUS ADR OF DRCSR SPECIFIED BY USER.
; T3:=DR11C #  SKIP IF LEGAL DR11C, SINGLE RETURN OTHERWISE.
DLGDR:  CAILE T3,NUMDR-1
	 JRST [MOVEI TI,DR.BDR
	       POPJ P,]
	MOVE P1,DRBATB(T3)	;T2:=DR11C BASE ADDRESS.
	JRST CPOPJ1

;DLWAIT.  WAIT UNTIL PREDICATE TRUE (SKIPS).  PUT PREDICATE
; BEFORE JSP T2,DLWAIT.  IF PREDICATE FAILS TRIES AGAIN.
; UP TO 100 TRIES ARE ALLOWED.
DLWAIT:	MOVEI P2,100.
DLWT1:	MOVEI P3,2		;RESCHEDULE
	SLEEP P3,
	XCT -2(T2)
	 SOJG P2,DLWT1
	JUMPE P2,[MOVEI TI,DR.TMO
		  POPJ P,]
	JRST (T2)
>;END IFCPU (KS) STARTING PAGE 1.

IFNCPU (KS),<
CIOPR::POPJ P,
>
END
