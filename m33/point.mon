S.MAC	
{Page 23}
DEFINE FDEERP(LOC)<[POINT~ 6,'LOC,5]>
DEFINE PRNTBP(AC)<[POINT~ 12,JBTFTR('AC),11]>
DEFINE NEIGBP(AC)<[POINT~ 12,JBTFTR('AC),11+12]>
DEFINE CHLDBP(AC)<[POINT~ 12,JBTFTR('AC),11+2*12]>

{Page 24}
DEFINE HTPPTR(LOC)<POINT~ 3,'LOC,17> ;GENERATE BYTE POINT~ER

{Page 26}
 IFL PG-400,<POINT~ 18,PGS+UPTEP0+<<PG-340>/2>,17+18*<<PG>&1>>
 IFGE PG-400,<POINT~ 18,EPT+EPTPG0+<<PG-400>/2>,17+18*<<PG>&1>>
	POINT~ 18,EPT+EPTPG0+<<PG-400>/2>,17+18*<<PG>&1>
	POINT~ 18,UPX+UPTEP0+<<PG-340>/2>,17+18*<<PG>&1>>
DEFINE UPMPTR(PG)<POINT~ 18,%UPT+400+<PG-340>/2,17+18*<<PG>&1>>

COMMON.MAC	
{Page 8}
 UPYPSR::POINT~ UPSPSR,%UPT+UPTSTS,UPNPSR ;POINT~ER TO PENDING STREAM REC TYPE
 USYPSR::POINT~ UPSPSR,%UPS+UPTSTS,UPNPSR ; One for %UPS
 UXYPSR::POINT~ UPSPSR,%UPX+UPTSTS,UPNPSR ; One for %UPX
 UPYUWL::POINT~ 10,%UPT+UPTUWS,25	;CURRENT LIMIT
 USYUWL::POINT~ 10,%UPS+UPTUWS,25 ;ONE FOR %UPS
 UXYUWL::POINT~ 10,%UPX+UPTUWS,25 ;ONE FOR %UPX
 UPYUWM::POINT~ 10,%UPT+UPTUWS,35	;CEILING FOR CURRENT LIMIT
 USYUWM::POINT~ 10,%UPS+UPTUWS,35 ;ONE FOR %UPS
 UXYUWM::POINT~ 10,%UPX+UPTUWS,35 ;ONE FOR %UPX
 USYSIN::POINT~ 10,%UPS+UPTRES,15	;NUMBER OF PAGES SWAPPED IN
 USYRES::POINT~ 10,%UPS+UPTRES,25	;NUMBER OF RESERVES PAGES JOB OWNS STILL
 USYLSP::POINT~ 10,%UPS+UPTRES,35	;LMAP SCAN POINT~ER (WHERE

{Page 9}
LMYCUR:: POINT~ LMSCUR,%UPLMA(W),LMNCUR ;CURRENT PROTECTION: WRITE,
LM3CUR:: POINT~ LMSCUR,P3,LMNCUR
LMYERR::POINT~ 2,%UPLMA(W),^L<LMPDTE>-^D18 ;SWAP ERROR BITS
LM3ERR::POINT~ 2,P3,^L<LMPDTE>-^D18	;ONE FOR P3
LMYOVR: POINT~ ^D23,%UPLMA(W),^D35 ;AN AREA OF THE LMA SLOT
LM3OVR: POINT~ ^D23,P3,^D35
 LMYOV1: POINT~ ^D13,%UPLMA(W),^D25
 LM3OV1: POINT~ ^D13,P3,^D25
 LMYOV2: POINT~ ^D10,%UPLMA(W),^D35
 LM3OV2: POINT~ ^D10,P3,^D35
 LMYSPB::POINT~ 18,%UPLMA(W),31 ;BASE ADDRESS OF SPT SECTION
 LM3SPB::POINT~ 18,P3,31		;SAME, BUT IN P3
 LMYSPO::POINT~ 4,%UPLMA(W),35	;OFFSET INTO ENTRIES OF THIS ENTRY
 LM3SPO::POINT~ 4,P3,35		;ONE FOR P3
UP4LDA::POINT~ 17,P4,35	;LOW ORDER PART OF DISK ADDRESS

{Page 24}
	LDB	M,[POINT~ 8,INTTAB(P1),8] ;GET NUMBER OF DDB'S
	MOVE	PG,[POINT~ 6,DEVNAM(F),17] ;BYTE POINT~ER TO NEWLY CREATED

{Page 40}
PMONTB:	POINT~ 6,MONTAB(T1),5	;POINT~ER TO NUMBER OF DAYS INMONTH

{Page 42}
	DPB T1,[POINT~ 13,PAGDTI,17];NOTE NEW UPT LOCATION. T1/PHYS PG
	DPB	T1,[POINT~ 13,PAGDTI,35]
	DPB	T1,[POINT~ 13,PAGDTI,35]
	SKIPA U,[POINT~ 18,%UPS+UPTEP0(PG),17]
	MOVE U,[POINT~ 18,%UPS+UPTEP0(PG),35]

{Page 44}
	REYMON: POINT~ DCSIZ+NUMREV-1,RESTRT,35-RENUM
	REY'DCNAM'A: POINT~ DCSIZ,RESTRT,35
	REY'DCNAM'M: POINT~ DCSIZ,RESTRT,35-RENUM

{Page 45}
	MOVE	M,[POINT~ 8,SACLST,23] ;B HOLDS PNTR.
IOXCT:	DPB P1,[POINT~ 7,T3,9]	;PUT IN I/O DEVICE FIELD
SAYBB:	POINT~	8,SACCMD,15
SAYCC:	POINT~	32,SACARG,31
	POINT~	16,SACARG+1,15
	POINT~	8,SACARG+1,23

{Page 46}
	DPB	T3,[POINT~ 5,T4,27]	; TO

{Page 48}
	DPB	T2,[POINT~ AMSTRK,T3,AMPTRK]
	DPB	T1,[POINT~ AMSCYL,T3,AMPCYL]

{Page 52}
PUUOAC:	POINT~	4,M,12		;M AC FIELD
PIOMOD:	POINT~	4,S,35		;MODE BITS
PUNIT:	POINT~	7,DEVCHR(F),23	;DEVICE UNIT NUMBER
PJBSTS:	POINT~	JWSIZ,JBTSTS(J),JWPOS ;JOB WAIT STATE (QUEUE) CODE
PJBST2:	POINT~	JWSIZ,T2,JWPOS	;ONE FOR T2
PDVTIM:	POINT~	3,DEVCHR(F),9	;CODE FOR TIME DEVICE MAY
PDVCNT:	POINT~	7,DEVCHR(F),16	;COUNTED DOWN EACH SECOND,
IADPTR:	POINT~	2,DEVIAD(F),2	;COUNT OF NUMBER OF USER CHANNELS INITED
DEYCLS:	POINT~ 2,DEVCLS(F),1	;DEVICE CLASS CODE
DEYMCT:	POINT~ 4,DEVCLS(F),13	;DEVICE MAX FREE CORE COUNT
DEYTCT:	POINT~ 4,DEVCLS(F),17	;DEVICE CURRENT FREE CORE COUNT
JBYQNT:	POINT~ JBSQNT,JBTICT(J),JBNQNT ;POINT~ER TO QUANTUM RUN TIME FOR JOB
	POINT~ 27,JBTCTX+ZZ(J),35 ;POINT~ER TO DISK ADDRESS FOR PAGE ZZ
JBYSWS::POINT~ 2,JBTPGO(J),1	;SWAPPER STATE
JBYACT::POINT~ 10,JBTPGO(J),11	;NUMBER OF ACTIVE LMAP SLOTS
JBYCTR::POINT~ 5,JBTPGO(J),17	;NUMBER OF PAGES RESERVED FOR
JBYPPP::POINT~ 6,JBTMWS(J),5	;# OF PER-PROCESS PAGES
JBYMWS::POINT~ 10,JBTMWS(J),15	;MONITOR WORKING SET SIZE
JBYMWL::POINT~ 10,JBTMWS(J),25	;LIMIT
JBYUWS::POINT~ 10,JBTMWS(J),35	;USER WORKING SET SIZE.
JBYWCH:	POINT~ 23,JBTWCH(J),35 ;BYTE POINT~ER TO TIME OF DAY STARTED WAITING

{Page 53}
JBYRPT:	POINT~ 2,JBTLIC(J),LICRPS
JBYWPT:	POINT~ 2,JBTLIC(J),LICWPS
JBYINA:: POINT~ JBLMSZ,JBTINA(J),17	;POINT~ER TO INACTIVITY LIMIT FIELD
PVYMOD:	POINT~ PVSMOD,JBTPRV(J),PVNMOD
PVZMOD:	POINT~ PVSMOD,JBTPRV(T1),PVNMOD
PVYCOR:	POINT~ PVSCOR,JBTPRV(J),PVNCOR
PVYTIM:	POINT~ PVSTIM,JBTPRV(J),PVNTIM
PVYCRM:	POINT~ PVSCRM,JBTPRV(J),PVNCRM
PVYHNG:	POINT~ PVSHNG,JBTPRV(J),PVNHNG
JBYUUO:	POINT~ 6,%UPT+UPTTPN,5	;(0) UUO TRAP NUMBER
JBYCLK:	POINT~ 6,%UPT+UPTTPN,11	;(1) CLOCK TRAP NUMBER
JBYPGT:	POINT~ 6,%UPT+UPTTPN,17	;(2) PAGE TRAP NUMBER
JBYHNG:	POINT~ 6,%UPT+UPTTPN,23	;(3) HUNG DEVICE TRAP NUMBER
JBYTIM:	POINT~ 6,JBTINT(J),5	;(4) TIMER TRAP NUMBER
JBYERR:	POINT~ 6,%UPT+UPTTPN,29	;(5) DEVICE ERROR TRAP NUMBER
JBYWAK:	POINT~ 6,JBTINT(J),11	;(6) WAKE UUO
JBYSAL:	POINT~ 6,%UPT+UPTTP1,5	;(7) UWS FAULT, SIZE AT LEAST LIMIT
JBYSLL:	POINT~ 6,%UPT+UPTTP1,11	;(10) UWS FAULT, SIZE LESS THAN LIMIT
JBYREF:	POINT~ 6,%UPT+UPTTP1,17	;(11) REF BIT TRAP
JBYPER:	POINT~ 6,%UPT+UPTTP1,23	;(12) TRAP ON I/O ERRORS.
JBYNTQ:	POINT~ 6,JBTINT(J),17	;(13) NOTICE TO QUIT (TO BE HUNG)
JBYEXC:	POINT~ 6,JBTINT(J),23	;(14) FRAME EXITED INTERRUPT.
JBYMCY:	POINT~ 6,%UPT+UPTTP1,29	;(15) Micro-cycle interrupt timer
JBYLIM:	POINT~ 6,JBTINT(J),29	;(16) TRU limit interrupt
JBYSC1: POINT~ 9,JBTSCA(J),8	;Numerator for non-kcore factor
JBYSC2: POINT~ 9,JBTSCA(J),17	;Denominator for non-kcore
JBYSC3: POINT~ 9,JBTSCA(J),26	;Num. for kcore factor
JBYSC4: POINT~ 9,JBTSCA(J),35	;Denom. for kcore (or 0 if absolute)

{Page 54}
PGYUNU::POINT~ 6,.-.(PG),10	;UNUSED
PGYPGO::POINT~ 12,.-.(PG),22	;OUTPUT WAIT FOR THIS PAGE LINK
PGYFPL::POINT~ 13,.-.(PG),35	;FORWARD LINK (PAGE NUMBER)
PGYLMA::POINT~ 22,.-.(PG),22	;LMA CHAIN START (LINKS
PGYLMV::POINT~ 10,.-.(PG),10	;VP NUMBER OF NEXT SLOT
PGYLMJ::POINT~ 12,.-.(PG),22	;JOB NUMBER OF NEXT SLOT, 0 IF END
PGYBPL::POINT~ 13,.-.(PG),35	;BACKWARD LINK (PAGE NUMBER)
PGYLST::POINT~ 3,.-.(PG),2	;WHICH LIST PAGE IS ON (SEE CORE1
PGYDIO::POINT~ 6,.-.(PG),8	;DIRECT I/O COUNT (TAPE, NOT DISK)
PGYADR::POINT~ 27,.-.(PG),35	;DISK ADDRESS. (RETRIEVAL POINT~ER FORMAT)
PGYUNI::POINT~ 8,.-.(PG),16	;UNIT NUMBER PART
PGYPNO::POINT~ 19,.-.(PG),35	;PAGE ADDRESS WITHIN UNIT
PGYSPT::POINT~ 22,.-.(PG),22	;SPT BASE + OFFSET
PGYSPB::POINT~ 18,.-.(PG),18	;SPT BASE
PGYSPO::POINT~ 4,.-.(PG),22	;OFFSET
PGYCHT::POINT~ 13,.-.(PG),35	;LINK TO NEXT CORE PAGE ON CHT
PGYNXM::POINT~ 1,.-.(PG),0	;NXM
PGYERR::POINT~ 2,.-.(PG),2	;IODERR,IODTER
PGYSIP::POINT~ 1,.-.(PG),3	;SWAP IN IN PROGRESS
PGYSOP::POINT~ 1,.-.(PG),4	;SWAP OUT IN PROGRESS
PGYDRT::POINT~ 1,.-.(PG),5	;DIRTY
PGYSTS::POINT~ 6,.-.(PG),5	;CORE PAGE STATUS WORD
PGYSIO::POINT~ 2,.-.(PG),4	;COVERS SIP AND SOP.
PGYATB::POINT~ 13,.-.(PG),18	;PLACE TO REMEMBER ATB ADDRESS WHILE
PGYUSE::POINT~ 17,.-.(PG),35	;NUMBER OF REASONS WHY PAGE IS IN CORE
PGYCSH::POINT~ 36,.-.(PG),35	;WHOLE WORD (TO MAKE CODE FASTER)
	POINT~ AGESIZ,%UPT+UPTAGE(T1),ZZBIT

COMMOD.MAC	
{Page 7}
ATYBSZ: POINT~ ATSBLK+ATSPGS,ATBSIZ(T2),ATNBLK ;POINT~ER TO NO.
ATYWSZ: POINT~ ATSWRD,ATBSIZ(T2),ATNWRD ;POINT~ER TO NO. OF WORDS

{Page 8}
ATYALP: POINT~ ^D26,ATBALP(T2),^D35
ATYADT:	POINT~ ATSADT,ATBADT(P2),ATNADT
ATYCDT:	POINT~ ATSCDT,ATBCDT(P2),ATNCDT
ATYCSC:	POINT~ ATSCSC,ATBCSC(P2),ATNCSC
ATYCTM:	POINT~ ATSCTM,ATBCTM(P2),ATNCTM
ATYPRV:	POINT~ ATSPRV,ATBPRV(P2),ATNPRV
ATYUF1:	POINT~ ATSUF1,ATBUF1(P2),ATNUF1
ATYUF2:	POINT~ ATSUF2,ATBUF2(P2),ATNUF2
ATYXCD:	POINT~ ATSXCD,ATBXCD(P2),ATNXCD
ATYCTD:	POINT~ ATSCTM+ATSCDT,ATBCTM(P2),ATNCDT
ATYBLK:	POINT~ ATSBLK+ATSPGS,ATBBLK(P2),ATNBLK
ATYCNT:	POINT~ ATSCNT,ATBCNT(P2),ATNCNT

{Page 9}
FNYUFP:	POINT~ FNSUFP,FNBUFP(P3),FNNUFP

{Page 10}
DRYPRV:	POINT~ DRSPRV,DRBPRV(P4),DRNPRV
DRYCNT:	POINT~ DRSCNT,DRBCNT(P4),DRNCNT

{Page 11}
SPYNFE::POINT~ SPSNFE,SPTNFE(T4),SPNNFE	;BYTE POINT~ER TO FIELD

{Page 12}
SP4OFS::POINT~ SPSOFS,T4,SPNOFS	;POINT~ER TO POINT~ER IN T4
SP4BAS::POINT~ SPSBAS,T4,SPNBAS	;BYTE POINT~ER TO SPT POINT~ER IN T4

{Page 14}
DEYRPS: POINT~ DESRPS,DEVRPS(F),DENRPS ;REL POSITION OF LAST DDB
DEYSTC:	POINT~ DESSTC,DEVSTC(F),DENSTC	;STATUS CODE FOR SWPCLN

{Page 20}
RIYPRV:	POINT~ RISPRV,RIBPRV+%RIB,RINPRV  ;BYTE POINT~ER TO ACCESS PRIVILEGES

{Page 24}
RBYUNI: POINT~ PTSUNI,T2,PTNUNI
RBYUN1: POINT~ PTSUNI,T1,PTNUNI
RBYUN4: POINT~ PTSUNI,T4,PTNUNI
RBYUNA:	POINT~ PTSUNI,ATBRIB(P2),PTNUNI
RBYUNR:	POINT~ PTSUNI,DRBRIB(P1),PTNUNI
RBYUNV:	POINT~ PTSUNI,DEVRIB(F),PTNUNI
RBYPNO:	POINT~ PTSPNO,T2,PTNPNO
RBYPN1:	POINT~ PTSPNO,T1,PTNPNO
RB1PNO:	POINT~ PTSPNO,P1,PTNPNO

{Page 26}
UFYUF2:	POINT~ UFSUF2,%RIB+UFDUF2(T2),UFNUF2
UFYUF1:	POINT~ UFSUF1,%RIB+UFDUF1(T2),UFNUF1
UFYPRV:	POINT~ UFSPRV,%RIB+UFDPRV(T2),UFNPRV
UFYXCD:	POINT~ UFSXCD,%RIB+UFDXCD(T2),UFNXCD
UFYCTM:	POINT~ UFSCTM,%RIB+UFDCTM(T2),UFNCTM
UFYCDT:	POINT~ UFSCDT,%RIB+UFDCDT(T2),UFNCDT

{Page 28}
JBYIRD:	POINT~ JBSIRD,JBTRCT(J),JBNIRD	;BYTE POINT~ER
JBYRCT:	POINT~ JBSRCT,JBTRCT(J),JBNRCT	;BYTE POINT~ER
JBYIWT:	POINT~ JBSIWT,JBTWCT(J),JBNIWT	;BYTE POINT~ER
JBYWCT:	POINT~ JBSRCT,JBTRCT(J),JBNRCT	;BYTE POINT~ER
e 29}
  STYINC: POINT~ 1,STTSTS(T2),1	;ON IF SAT IS IN CORE IN A PCB.
  STYBAD: POINT~ 1,STTSTS(T2),2	;ON IF SAT IS BAD.
  STYCHK: POINT~ 1,STTSTS(T2),3	;ON IF SAT HAS BEEN CHECKED.

{Page 34}
BAYNBB:	POINT~ BASNBB,BATNBB(T2),BANNBB	;BYTE PTR
BA1NBB: POINT~ BASNBB,%RIB+BATNBB(T1),BANNBB	; Used in (CORE1)

{Page 38}
	LDB T2,[POINT~ 8,@CHNSTB(PG),23]	;GET UNIT
	LDB T1,[POINT~ 2,T1,17] ;GET NO. OF CHANNEL WITH BAD MEMORY REF.
	DPB	T1,[POINT~ 2,T2,15] ;INTO T2 AND ALSO TO PART OF
	DPB	T2,[POINT~ ^D22,CHNMER(PG),^D24] ;CHNMER.
	DPB	T2,[POINT~ 6,CHNMER(PG),^D30] ;STORE NO.

{Page 48}
KOYPI:	POINT~ KOSPI,KOBPI(J),KONPI     ;;PI CHANNEL THIS KONTROLLER ASSIGNED TO

{Page 56}
TUYTMN::POINT~ 3,TUBDA(U),32	;Point~er to TM03 number
TUYTUN::POINT~ 3,TUBDA(U),35	;Point~er to TU45 number.

{Page 58}
UNYSCN:	POINT~ UNSSCN,UNISCN(U),UNNSCN	;CHANNEL #
UNYPUN:	POINT~ UNSPUN,UNIPUN(U),UNNPUN	;PHYSICAL UNIT # (0-7) WITHIN KONTROLLER
UNYLUN:	POINT~ UNSLUN,UNILUN(U),UNNLUN	;LOGICAL UNIT # (0-77) WITHIN STR
UNYLN1:	POINT~ UNSLUN,UNILUN(T1),UNNLUN	;LOGICAL UNIT # - FOR ONCE ONLY
UNYWPS:	POINT~ UNSWPS,UNIWPS(U),UNNWPS	;+VE NO. OF WORDS PER SAT BLOCK
UNYUTP:	POINT~ UNSUTP,UNIUTP(U),UNNUTP	;UNIT TYPE(KONTROLLER DEPENDENT)
UNYBPT:	POINT~ UNSBPT,UNIBPT(U),UNNBPT	;BLOCKS/TRACK - ARG TO KONTROLLER ROUTINES
UNYPPY:	POINT~ UNSPPY,UNIPPY(U),UNNPPY	;PAGES PER CYLINDER
UNYKTP:	POINT~ UNSKTP,UNIKTP(U),UNNKTP	;KONTROLLER TYPE THIS UNIT IS CONNECTED TO
UNYSPU:	POINT~ UNSSPU,UNISPU(U),UNNSPU	;# SAT BLOCKS ON THIS UNIT
UNYKNM:	POINT~ UNSKNM,UNIKNM(U),UNNKNM	;KONTROLLER NO. WITHIN THIS TYPE
UNYTIM:	POINT~ UNSTIM,UNITIM(U),UNNTIM	;TIMER FOR HUNG DEVICE
UNYPAC:	POINT~ UNSPAC,UNIPAC(U),UNNPAC	;ACTIVE PAGE POINT~ER
UNYPGL:	POINT~ UNSPGL,UNIPGL(U),UNNPGL	;RQUEST LIST POINT~ER
UNYRTY:	POINT~ UNSRTY,UNIRTY(U),UNNRTY	;RETRY COUNT
UNYRCL:	POINT~ UNSRCL,UNIRCL(U),UNNRCL	;RECAL COUNT
UNYRRT:	POINT~ UNSRRT,UNIRRT(U),UNNRRT	;RETRY COUNT BETWEEN RECALS
UNYOCV:	POINT~ UNSOCV,UNIOCV(U),UNNOCV	;OFFSET STATE (ERROR RECOVERY).
UNYRTO:	POINT~ UNSRTO,UNIRTO(U),UNNRTO	;RETRY THIS MANY TIMES AFTER OFFSET.
UNYRCO:	POINT~ UNSRCO,UNIRCO(U),UNNRCO	;RECAL AFTER RETRY AFTER OFFSET.
UNYOS:	POINT~ UNSOS,UNIOS(U),UNNOS	;1 <=> SET OFFSET MODE BEFORE XFR
UNYSIZ:	POINT~ UNSSIZ,UNISIZ(U),UNNSIZ	;UNIT DATA BLOCK SIZE
UNYPPL:	POINT~ UNSPPL,UNIPPL(U),UNNPPL	;PARTIAL PAGE TRANSFER BYTE

FILUUO.MAC	
{Page 9}
	LDB	T1,[POINT~ 4,M,^D12] ;GET AC FIELD.

{Page 12}
	DPB P3,[POINT~ 2,P4,23]

{Page 13}
	DPB T1,[POINT~ 8,P4,26]
	DPB T1,[POINT~ 4,P4,18]

{Page 42}
	DPB	T1,[POINT~ 11,T2,23] ;STORE TIME IN T2

{Page 43}
	DPB	S,[POINT~ 4,T2,12] ;MODE
	LDB	T1,[POINT~ 12,T2,35] ;GET DATE
	DPB T3,[POINT~ 2,T1,23]	;GET ALL OF DATE
	DPB T1,[POINT~ 12,T2,35]
	DPB T2,[POINT~ 2,T4,21]	;SAVE EXTENDED DATE INFO

{Page 71}
LICMAX:	LDB T3,[POINT~ 2,T2,LICWPS]	;MAX OF WRITE PRVS
	LDB T4,[POINT~ 2,T2,LICWPS+^D18]
	DPB T4,[POINT~ 2,T2,LICWPS+^D18]
	LDB T3,[POINT~ 2,T2,LICRPS]	;READ IS MAX OF READ
	LDB T4,[POINT~ 2,T2,LICRPS+^D18]
	DPB T3,[POINT~ 2,T2,LICRPS+^D18]
LICMSK:	LDB T3,[POINT~ 2,T2,LICWPS]
	LDB T4,[POINT~ 2,T2,LICWPS+^D18]
	 DPB T4,[POINT~ 2,T2,LICWPS]
	LDB T3,[POINT~ 2,T2,LICRPS]
	LDB T4,[POINT~ 2,T2,LICRPS+^D18]
	 DPB T4,[POINT~ 2,T2,LICRPS]
LICSAM:	LDB T3,[POINT~ 2,T2,LICWPS]
	LDB T4,[POINT~ 2,T2,LICWPS+^D18]
	LDB T3,[POINT~ 2,T2,LICRPS]
	LDB T4,[POINT~ 2,T2,LICRPS+^D18]

FILIO.MAC	
{Page 24}
	DPB	T1,[POINT~ OHTLNS,T2,OHTLNP]

{Page 25}
	HRLI	T3,(POINT~ OHTLNS,0,OHTLNP)	;FRESH BYTE POINT~ER
	LDB	T1,[POINT~ OHTLNS,OHTTAB(T4),OHTLNP] ;GET NEW NEXT MEMBER

{Page 26}
	ADD	T3,[POINT~ OHTLNS,OHTTAB,OHTLNP] ;TURN T3 INTO POINT~ER TO LINK.
SRCOH2:	LDB	T1,[POINT~ OHTLNS,T1,OHTLNP] ;GET INDEX.
	POINT~ OHTLNS,OHTHED,ZZ-1

FRMSER.MAC	
{Page 12}
	LDB	T4,[POINT~ 9,U,26] ;PAGE NUMBER
FRMXVE:	LDB	P3,[POINT~ 6,T2,5] ;GET SUBCODE

{Page 24}
	LDB	T2,[POINT~ 6,T1,5] ;Check first character

{Page 28}
	  DPB	P4,[POINT~ 1,%UPX+UPTPJ2,35]

{Page 30}
FARLCY:	POINT~	FARLCL,FRATAB(P1),FARLCR ;Byte point~er to Read index
FAWLCY:	POINT~	FAWLCL,FRATAB(P1),FAWLCR ;Byte point~er to Write index
FARARY:	POINT~	FARARL,FRATAB(P1),FARARR ;Byte point~er to R.A.R. field
FAWARY:	POINT~	FAWARL,FRATAB(P1),FAWARR ;Byte point~er to W.A.R. field
	POINT~	36,%UPX+UPTLOG,35 ;Byte point~er to fullword field

{Page 34}
FILFRH:	LDB	T3,[POINT~ 15,P4,35] ;GET INDEX OF OLD HANDLE

{Page 68}
FDDSP:	LDB	T3,[POINT~ 3,P4,20] ;GET TYPE FROM FD
	JRST	[LDB T3,[POINT~ 3,P4,23] ;GET FAMILY TYPE

{Page 72}
	DPB	T1,[POINT~ 6,T4,5] ;PUT IN BYTE POINT~ER FOR DES.
	DPB	T1,[POINT~ 6,T3,5] ;PUT "P" FIELD FOR SOURCE BYTE IN ON TOP OF ONE FOR DES.

PCBIO.MAC	
{Page 2}
    PCUSTS: POINT~ 4,PCBSTS(T2),^D8 ;BITS OF PCBSTS NOT CHANGED
    PCISTS:: POINT~ 5,PCBSTS(T2),^D4 ;BITS OF PCBSTS THAT MAY BE
    PCYLCC: POINT~ ^D9,PCBLCC(T2),^D17

{Page 3}
%CTSTS::!  POINT~ 6,JBTPCB(T1),<<<POSN*6>-1>+18>
%CTADR:!  POINT~ 6,JBTPCB(T1),<<POSN*6>-1>

{Page 4}
QUYPCP: POINT~ ^D8,QUEPCB(J),^D17 ;NO. OF PREVIOUS JOB IN QUEUE.
QUYPCS: POINT~ ^D10,QUEPCB(J),^D27 ;STATUS BITS FOR THIS JOB.
QUYPCN: POINT~ ^D8,QUEPCB(J),^D35 ;NO. OF NEXT JOB IN THE QUEUE.

{Page 31}
	LDB	T1,[POINT~ 2,OHTTAB(T4),1] ;GET BITS IN RH(T1)

SWAMP.MAC	
{Page 16}
	MOVE	T1,[POINT~ ^D6,UNINAM(U)] ;
	MOVE	T2,[POINT~ ^D7,P1] ;
	MOVE	T3,[POINT~ ^D7,P1] ;BYTE PNTR TO P1 AND P2.

CLUBS.MAC	
{Page 2}
CMYVPG:	POINT~ CMSVPG,CMCVPG(T1),CMNVPG
CMYCID:	POINT~ CMSCID,CMCCID(T1),CMNCID

FILFND.MAC	
{Page 29}
	LDB T3,[POINT~ 3,T4,29]	;GET OWNERS PROTECTION
	MOVE T3,[POINT~ 3,T4,29]

APXKON.MAC	
{Page 9}
	DPB	T2,[POINT~ AMSTRK,T3,AMPTRK]
	DPB	T1,[POINT~ AMSCYL,T3,AMPCYL]

F3TSER.MAC	
{Page 8}
	LDB PG,[POINT~ 13,T1,26] ;GET PHYSICAL PAGE NUMBER.

{Page 11}
	LDB T1,[POINT~ 2,M,35]	;Yes.  Set up mode information.

{Page 15}
	LDB	T1,[POINT~ 14,T2,13]	;GET COUNT FROM STATUS
	LDB	T1,[POINT~ 13,T2,13] ;GET TOTAL COUNT
WRERR1:	LDB	T3,[POINT~ 2,S,^D28] ;GET DENSITY

{Page 16}
	DPB	T1,[POINT~ 4,P2,29] ;SET FUNCTION FIELD
	DPB	T2,[POINT~ 2,P2,25] ;UNIT NUMBER
	LDB	T2,[POINT~ 2,DEVMD1(F),35] ;GET MODE
	LDB	T2,[POINT~ 2,S,28] ;GET DENSITY
	DPB	T2,[POINT~ 3,P2,32] ;PUT IT IN COMMAND

{Page 19}
	LDB M,[POINT~ 14,T4,13]	;Number of words to do on this page.
	  LDB M,[POINT~ 14,(T1),13]	;Yes, this many words to transfer.
SETAD1:	LDB	T2,[POINT~ 14,(T1),13] ;GET COUNT OF THIS IOWD
	LDB	T4,[POINT~ 22,(T1),35] ;GET ADDRESS-1
	DPB	T3,[POINT~ 13,T4,13] ;PUT COUNT WHICH WILL BRING US TO 200 IN
	DPB	T3,[POINT~ 13,T4,13] ;SET
	LDB	M,[POINT~ 14,(T1),13] ;SETUP M FOR NEW NUMBER OF WORDS TO DO

{Page 20}
	LDB	T1,[POINT~ 4,P2,29]	;GET COMMAND CODE
	MOVE	T3,[POINT~ 18,EPT+<%ONC/1000/2>,-1+^D18*<<%ONC/^O1000>&1>]
	LDB	T2,[POINT~ 13,T1,26] ;GET PAGE NUMBER
	LDB	T4,[POINT~ 4,P2,29] ;GET COMMAND AGAIN

CLOCK1.MAC	
{Page 1}
CLOCK:	POINT~ 36,CIPWTM,35	;BYTE POINT~ER TO CLOCK REQ QUEUE

{Page 6}
	LDB T1,[POINT~ 7,T2,18]	;GET JOB NUMBER
	LDB T2,[POINT~ 6,T2,6]	;AND DISPATCH NUMBER

{Page 10}
BKPALV:	POINT~	KPALVL,RLWORD##,KPALVE	;BYTE POINT~ER TO KEEP ALIVE COUNT

{Page 12}
	MOVE T3,[POINT~ 7,.JBNO,13]	;BEGIN 3RD BYTE IDPB

{Page 24}
CHGCLK:	LDB T3,[POINT~ 12,T1,18]	;GET JOB NUMBER AND TYPE
	LDB T1,[POINT~ 12,(T2),18]
CLKJOB:	POINT~	7,T1,18		;Byte point~er to set job/frame # into

{Page 25}
PJBS1:	POINT~ JWSIZ,JBTSTS(P3),JWPOS ;BYTE POINT~ER TO JOB STATUS
PJBS3:	POINT~ JWSIZ,JBTSTS(17),JWPOS

{Page 26}
PJBS2:	POINT~ JWSIZ,JBTSTS(T1),JWPOS ;LIKE PJBSTS BUT USES T1,NOT J

COMCON.MAC	
{Page 3}
	HRR	P3,T1		;SAVE TABLE POINT~ER
	HRL	P3,P4		;AND AOBJN POINT~ER FOR TYPE
	HRRZ	T1,P3		;RESTORE COMMAND POINT~ERS
COMFND:	LDB	P3,[POINT~ 3,(P4),2] ;GET TYPE
	POP	P,T3		;RESTORE COMMAND POINT~ER

{Page 6}
CMDCMX:	POINT~	4,TTYTAB(J),13	;Byte point~er for Forced Command Index

{Page 7}
	MOVSI	T2,-CMFSIZ	;AOBJN point~er

{Page 20}
	MOVE	W,[-<VPUMAX-1000+1>,,340+CNVVPN] ;GET AOBJN POINT~ER
LKUUPT:	MOVSI	W,-NCTXPG	;AOBJN POINT~ER

{Page 25}
; General entry point~ for forcing "must kill"

{Page 51}
	DPB T1,[POINT~ 21,DAMESS,27]

{Page 57}
	HRRI	T3,%UPS-%UPT(T3)	;ADJUST POINT~ER TO UPS

{Page 65}
	PUSH	P,T1	;SAVE ORIGINAL AOBJN POINT~ER TO COMPUTE INDEX.
TABFND:	POP	P,T3	;GET ORIGINAL POINT~ER

{Page 69}
	HLRZ W,DEVLST	;GET DDB POINT~ER

{Page 71}
	SKIPA W,[POINT~ 6,T2]

{Page 74}
;CALL:	MOVE T1, BYTE POINT~ER TO LAST CHAR. IN INPUT STRING

{Page 75}
;CONMS1 - SAME CALLING SEQUENCE AS CONMES,EXCEPT LH IS BYTE POINT~ER
CONMES:	HRLI T1,440700		;FORM ASCIZ BYTE POINT~ER
	PUSH P,T1		;SAVE BYTE POINT~ER

{Page 76}
;CALL:	MOVE U,BYTE POINT~ER

{Page 81}
;CALL:	MOVE T1,INPUT BYTE POINT~ER

{Page 82}
	POP	P,T1		; RESTORE ENTRY POINT~ FLAG

CORE1.MAC	
{Page 8}
	MOVEI T1,DABBIT(J) ;GET DUMMY ATB POINT~ER
	PUSHJ P,CNVATP	;CONVERT ATB POINT~ER INTO ADDRESS

{Page 15}
		 JRST REMOV8]	;SO ADJUST STACK POINT~ER AND GO.

{Page 16}
	JRST	REMV36		;(RIBELB WILL NOT MATCH ANY POINT~ERS IN THE RIB)

{Page 19}
@@PURPOSE AFTER KNOWN RESCHEDULE POINT~S IN REMOVE, UPDATE

{Page 24}
	LDB	P2,[POINT~ 10,P1,17] ;GET COUNT
	MOVE	W,P2		;GET POINT~ER IN W SO VP IS IN RH(W)

{Page 25}
	MOVE	W,P2		;SETUP AOBJN POINT~ER AGAIN.

{Page 31}
	LDB	W,[POINT~ 10,T1,17] ;NUMBER PAGES TO DO

{Page 36}
	DPB T2,[POINT~ 2,P1,5]	;PS.DDE ARE 1B4 1B5
	LDB T1,[POINT~ 2,T1,1] ;GET ERROR STATUS BITS

{Page 39}
	LDB T1,[POINT~ 10,T1,17]

{Page 40}
	HRLI U,(POINT~ 1,0,35)	;DEPOSITING 1 BIT AT A TIME

{Page 46}
	LDB	T2,[POINT~ 10,T1,17] ;GET COUNT

{Page 47}
SUBTTL UUO TO RETURN VP'S DISK POINT~ER
;	<NORMAL RETURN>		;RETRIEVAL POINT~ER RETURNED IN AC.
;FORMAT OF RETRIEVAL POINT~ER SAME AS THAT FOUND IN RIBS AND THROUGHOUT
	PUSHJ	P,GETDPA	;OK, GET DISK POINT~ER IN T2

{Page 51}
	HRRM	T2,JBTPGO(T1)	;OLD LAST POINT~S TO NEW LAST
	DPB	T1,[POINT~ JWSIZ,JBTSTS(T2),JWPOS]

{Page 56}
QUESTION: SHOULD %UPX PAGES BE TAKEN OUT OF MWS AT THIS POINT~?

{Page 57}
	MOVE	W,[-NCTXPG,,%UPX.N+CNVVPN] ;AOBJN POINT~ER

{Page 58}
	MOVE	W,[-NCTXPG,,%UPX.N+CNVVPN] ;AOBJN POINT~ER FOR PAGES TO REMOVE

{Page 60}
TABLE STUFF WILL BE INCONSISTENT (E.G. LMA CHAIN, PGY POINT~ING

{Page 61}
	LDB	W,[POINT~ 9,T1,17] ;GET PAGE NUMBER
	DPB	T1,[POINT~ 6,F,23] ;GET 0AWST IN 18-23.
	LDB	W,[POINT~ 9,T1,26] ;GET VIRTUAL PAGE NUMBER IN W

{Page 64}
	SKIPA	T1,[20,,21]	;THIS IS POINT~ER TO USE

{Page 71}
SPCFLT:	LDB	T1,[POINT~ 5,F,23]	;GET CODE

{Page 75}
POINT~ER. PAGE WE ARE REPLACING FOR MUST NOT ALREADY BE IN UWS,
%UPT+UPTRPT HAS NEW REPLACEMENT POINT~ER. UWS SIZE GUARANTEED

{Page 76}
UWSRP5:	MOVEM	W, %UPT+UPTRPT	;UPDATE POINT~ER

{Page 86}
	MOVEM	W, %UPT+UPTRPT	;  UPDATE POINT~ER

{Page 90}
WITH ACTIVATION. (ACTLMS ENTERS AT THIS POINT~).
(VIRGIN PAGE ENTERS AT THIS POINT~). INCREMENT CP'S

{Page 93}
	LDB	T3,LM3ATB	;GET ATB POINT~ER
	DPB	T3,PGYATB	;REMEMBER ATB POINT~ER
ACTLM4:	LDB	T3,LM3SPT	;GET SPT POINT~ER
	LDB	T4,PGYSPT	;YES, GET SPT POINT~ER FOR SETSHR.

{Page 94}
	DPB	T1,LM3LMJ	;SLOT WE'RE DOING POINT~S

{Page 97}
	LDB	T1,PGYLMJ	;GET FIRST LMAP POINT~ER

{Page 98}
; FIND THE SLOT BEFORE THE ONE WE'RE REMOVING AND POINT~ IT
; LMAP POINT~ER FOR FIRST LMAP SLOT ON CHAIN, J AND W STILL
; CONTAIN LMAP POINT~ER FOR SLOT WE'RE REMOVING, P3 AND P4
	PUSH	P,J		;SAVE LMAP POINT~ER TO LMAP WE'RE
	STOPCD			; CRASH, NO ONE POINT~ED TO SLOT
	LDB	T1,LM3LMJ	;GET LMAP SLOT IT POINT~S TO
	CAMN	T1,-1(P)	;DOES IT POINT~ TO ONE WE'RE REMOVING?
	DPB	P1,LM3LMJ	;YES, POINT~ PREVIOUS TO NEXT
	POP	P,W		;RESTORE OLD REMOVED LMAP POINT~ER

{Page 99}
	LDB	T1,PGYATB	;GET ATB POINT~ER
DEALM7:	LDB	T2,PGYSPT	;GET SPT POINT~ER

{Page 100}
@@ENTRY T4 CONTAINS SPT POINT~ER (BASE+OFFSET), P3 AND
T4 STILL CONTAINS SPT POINT~ER.
SPT POINT~ER IN SLOT AND RETURN.
	DPB	T4,PGYSPT	;STORE SPT POINT~ER IN PGYSPT
SETSH1:	DPB	T4,LM3SPT	;JUST PUT SPT POINT~ER IN SLOT

{Page 102}
CALL AT REMCHR (REMOVE ENTRY POINT~) IF MAY BE SUPER MAPPER AROUND.
PGYCHT POINT~ER OF PREVIOUS PAGE TO POINT~ TO PAGE AFTER THE
	EXCH	T4,PG		;POINT~ TO PREVIOUS CP'S PGY TABLE
	DPB	T1,PGYCHT	;PREVIOUS POINT~S TO NEXT AFTER ONE

{Page 103}
	DPB	T4,PGYCHT	;OLD LAST ONE NOW POINT~S TO NEW LAST ONE

{Page 104}
	MOVE	T1,EPYPSM	;POINT~ER TO PUT SLOT ENTRIES [EPTPTR(%UPS.N-1)]
	MOVE	T3,USYPTN	;GET POINT~ER TO OTHER MAP SLOTS [UPSPTR(%UPT.N)]

{Page 108}
@@ENTRY P3,P4 CONTAIN LMAP SLOT POINT~ER DATA
PICKUP ATB POINT~ER FROM LMAP SLOT.  IF SLOT IS ON I/O CHAIN,
	LDB	T1,PGYATB	;GET ATB POINT~ER
GETAT4:	LDB	T1,LM3ATB	;GET ATB POINT~ER FROM LMAP SLOT

{Page 110}
@@PURPOSE GET SPT ENTRY ADDRESS AND SPT POINT~ER FROM AN LMAP SLOT
@@EXIT SPT ENTRY ADDRESS IN T1, SPT POINT~ER IN T4.
	LDB	T4,PGYSPT	;GET POINT~ER IN T4
GETSP1:	LDB	T4,LM3SPT	;GET POINT~ER IN T4
	JUMPN	T4,CPOPJ	;RETURN IF THERE WAS A POINT~ER

{Page 115}
	DPB	T1,PGYBPL	;NEW LAST POINT~S BACK TO OLD LAST
	DPB	T1,PGYFPL	;OLD LAST POINT~S FORWARD TO NEW LAST
	HRLM	PG,LSTLST(T4)	;NEW LAST POINT~ED TO BY LH OF LSTLST
	DPB	T1,PGYFPL	;OK,NEW FIRST POINT~S TO OLD FIRST
	DPB	T1,PGYBPL	;OLD FIRST POINT~S BACK TO NEW FIRST
	HRRM	PG,LSTLST(T4)	;NEW FIRST IS FIRST POINT~ER
;HERE IF LIST WAS EMPTY. BOTH HALVES OF HEADER POINT~ TO ONLY PAGE

{Page 116}
;FIRST POINT~ OLD LAST PAGE FORWARD TO OLD NEXT PAGE.  IF THERE IS
; LIST) THEN POINT~ FORWARD HEADER POINT~ER AT OLD NEXT.
; WILL STORE A ZERO IN FORWARD HEADER POINT~ER).
	HRRM	T2,LSTLST(T3)	;DOESN'T. HEADER FORWARD POINT~ER
	JRST	REMLS2		; POINT~S TO OLD NEXT PAGE.
	DPB	T2,PGYFPL	;OLD LAST POINT~S FORWARD TO OLD NEXT
;NOW POINT~ OLD NEXT PAGE BACKWARD TO OLD LAST PAGE. IF THERE
; IS NO OLD NEXT PAGE, THEN POINT~ BACKWARD HEADER POINT~ER
; POINT~ER IS SET TO ZERO.
	HRLM	T1,LSTLST(T3)	;NOT ONE. BACKWARD HEADER POINT~ER
	POPJ	P,		; POINT~S TO OLD LAST PAGE, IF THERE
	DPB	T1,PGYBPL	;OLD NEXT POINT~S BACK TO OLD LAST

{Page 120}
	MOVSI	T4,-<VPMAX+^D35>/^D36 ;AOBJN POINT~ER
	MOVSI	T4,-<^D512+^D35>/^D36 ;GET AOBJN POINT~ER TO TABLE
	MOVSI	T4,-<VPMAX+^D35>/^D36 ;GET AOBJN POINT~ER
	ADD	T4,T1		;ADJUST AOBJN POINT~ER (DO A FEW AOBS)
	PUSH	P,T4		;SAVE AOBJN POINT~ER

{Page 122}
	HRRM	T1,JBTPGO(J)	;NEW FIRST POINT~S TO OLD FIRST

{Page 125}
;	T2=AOBJN POINT~ER FOR TABLE

{Page 131}
	HRLZI	W, -777		;W/ PAGE # AOBJN POINT~ER

{Page 132}
	AOS	P1		;  ADVANCE THE POINT~ER

ERRCON.MAC	
{Page 8}
USRILR:	LDB	T2,[POINT~ 9,(P),26] ;GET PAGE OF PC

{Page 11}
	CAMN T1,JOB		;POINT~S TO CURRENT JOB?

{Page 20}
	LDB	T1,[POINT~ 9,M,26] ;GET PAGE FROM M

{Page 21}
	SUBI	T2,1		;POINT~ TO THE ACTUAL UUO

{Page 26}
;CALL	MOVE U,ASCII OUTPUT BYTE POINT~ER

JOBDAT.MAC	
{Page 6}
01800	UJOB SYM,116,1		;POINT~ER TO LOADER AND DDT SYMBOL TABLE POINT~ER
01900	UJOB USY,117,1		;POINT~ER TO UNDEFINED SYMBOL TABLE

{Page 8}
02900			;;;; IT WILL CONTAIN SOME SORT OF POINT~ER

ACTSER.MAC	
{Page 2}
	LDB T1,[POINT~ 9,DEVIOS(F),35]
BUFCHK:	MOVS T2,ACTBUF-2	;GET BUFFER IN AND OUT POINT~ERS

{Page 4}
	JUMPGE F,[	SKIPL JBTAWQ(J)	;POINT~ 7
	JRST RAFRET	;POINT~ 8. REL ACT & FAIL
	PUSHJ P,WSCHED	;POINT~ 9
POINT~ 1
POINT~ 2
POINT~ 2A
POINT~ 3 NONEXISTENT
POINT~ 4
POINT~ 5
POINT~ 5A
POINT~ 6
POINT~ 7
   AT THIS POINT~***
POINT~ 8
POINT~ 9

{Page 5}
2. BUFFER POINT~ERS ADVANCED
FINBUF:	PUSHJ P,FINAC1	;UN-INTERLOCK, UPDATE BUFFER POINT~ERS, NON-SKIP EXIT
;RELACB..FALL THRU FROM ABOVE. ALSO JBTABT(J) SET TO POINT~

{Page 7}
STORE DATA IN MONITOR BUFFER AND ADVANCE POINT~ER.  IF ENTERED
AT MORBUF ONLY THE POINT~ERS ARE ADVANCED.
STORES DATA AND ADVANCES BUFFER POINT~ERS.  IF BUFFER
	HRLM T2,ACTBUF-2	;SET NEW IN POINT~ER

{Page 8}
CKPRL==41	;CHECKPOINT~. DITTO MUST AGREE WITH "CKPLNG"
	ATB LICXC,TCCTAR,TCCARL,0	;TRU COMPONENT CHECKPOINT~
ACYCOD: POINT~ 9,(T2),8	;TO DPB REC TYPE
ACYJOB: POINT~ 9,(T2),17		;TO DPB JOB, INTO HEADER WORD
ACYTYP: POINT~ 6,ACRTAB(T3),23	;TO MATCH TYPE
ACYMIN: POINT~ 6,ACRTAB(T3),29   ;TO GET MIN REC SIZE FOR VAR LEN RECS
ACYSIZ: POINT~ 6,ACRTAB(T3),35	;TO GET REC SIZE

LPTSER.MAC	
{Page 1}
; DEVCLS of the DDB point~s to the first location
; the In point~er in the left half, the Out point~er
; in the right half.  The in point~er is adjusted by UUOCON,
; the Out point~er by this module.
;The LPT buffer is point~ed at by LPTLBA in the DDB.

{Page 3}
	LDB T2,[POINT~ 9,LPTLBA(F),8]	;-10 page of buffer
	HRRZI M,(M)	;M point~s to current(the first for now) command
	AOJA	M,CMDLUP;increment command point~er and loop back
	MOVEI	T1,0	;set current line point~er to zero
	MOVE	T4,[POINT~ 18,VFUBUF+1]	;skip 2 bits
	ADJBP T1,VFUPTR	;T1/byte point~er to last byte to be sent
ERRSCN:	PUSH	P,M	;save command point~er
	HRLI	M,-MAXC	;M/-max command count,,command point~er
	POP	P,M	;restore initial command point~er
	ADJBP P1,VFUPTR	;P1=point~er to byte just before this line's
	ADJBP P1,VFUPTR	;P1=point~er to byte just before this line's
VFUPTR:	POINT~ 8,VFUBUF+1
C6TO1:	POINT~ 6,T1,17
C12TO7:	POINT~ 6,T1,11

{Page 4}
	CALL SOP		;T1:=point~er to next block
LPTCF:	MOVE T1,LPCFPT		;Output point~er to CRFF
; output point~er in T1.  T1.Lh=-10 words to send
	MOVE T1,LPVLPT		;Point~er to VFU data

{Page 5}
;LPTCVT.  Move T1 words out of monitor buffer point~ed

{Page 6}
	HRRZ T4,DEVCLS(F)	;Advance output point~er over data
	CALL SOP		;Setup next output point~er
	MOVE T2,[POINT~ 18,LPTSB(F)]

{Page 12}
	HRRZ	T1,DEVCLS(F)	;YES,SET UP INITIAL BLKO POINT~ER

{Page 13}
; ADVANCE BUFFER POINT~ER.
;   ON ENTRY (T1)= LAST BLKO POINT~ER
	HRRZ	T2,DEVCLS(F)	;BUFFER POINT~ER
	HRRM	T1,-2(T2)	;STORE NEW OUT POINT~ER
;  SET UP NEW BLKO POINT~ER FOR NEXT BLOCK
;    ON EXIT (T1)= NEW POINT~ER
BPTSET:	HRRZ	T3,DEVCLS(F)	;GET BUFFER POINT~ER
	HLRZ	T1,-2(T3)	;LOAD IN POINT~ER
	HRRZ	T2,-2(T3)	;LOAD OUT POINT~ER
	HRRZ	T1,-1(T3)	;GET LAST POINT~ER

{Page 14}
					; TO POINT~ TO DDB AGAIN
	MOVE	T1,LPTPTR(F)	;GET OLD BLKO POINT~ER
	PUSHJ	P,BPTSET	;SET UP NEW BLKO POINT~ER
	MOVEM	T1,LPTPTR(F)	;STORE NEW POINT~ER
LPTBG1:	MOVE	T1,LPTPTR(F)	;OLD BLKO POINT~ER
	PUSHJ	P,BPTSET	;SET UP INITIAL BLKO POINT~ER *******
	MOVEM	T1,LPTPTR(F)	;STORE NEW POINT~ER

{Page 15}
	MOVN	U,[EXP 1000001]	;DECREMENT BLK0 POINT~ER

PICON.MAC	
{Page 2}
PGFUIO:	XWD	PC.UIO,PGFAIL	;ADDRESS POINT~ER USED IN ONCE

{Page 4}
STKAC:	EXCH	16,%UPT+UPTACP	;SAVE PC, GET AC POINT~ER
	EXCH	16,%UPT+UPTACP	;SAVE POINT~ER, GET PC
	EXCH	16,%UPT+UPTACP	;GET AC POINT~ER, SAVE PC
	ADDI	16,20		;ADVANCE STACK POINT~ER
	EXCH	16,%UPT+UPTACP	;SAVE NEW POINT~ER, GET PC

{Page 5}
	HRRZ	17,%UPT+UPTACP	;GET STACK POINT~ER ADDRESS
	MOVEI	17,%UPT+UPTAC0+20*XACSTL+16 ;YES, RESET POINT~ER TO REAL PLACE
	MOVEM	17,%UPT+UPTACP	;SET NEW POINT~ER

{Page 6}
SAVAPR:	0		;APR status at point~ of interrupt

{Page 10}
	MOVSI	0,440700!P1	;Generate byte point~er in AC 0
BUGTY6:	MOVE	0,[POINT~ 3,P1,17]

{Page 14}
SNITPT: BLOCK 1  	;CIRCULATING POINT~ER (INDEX INTO) HFITTB

{Page 15}
	HLRZ T3,SICTB(T3)	;T3 POINT~S AT XWD COUNT,LEAP-COUNT
	MOVEM T1,SNITMX		;CIRCULATING POINT~ER RESET VALUE
	MOVEM T1,SNITPT		;CIRC POINT~ER

{Page 16}
FUNCTION: START SNOOP INTERRUPTS.  FOR KL10, POINT~ THE

{Page 23}
	PUSH P,T2	;SAVE ARGUMENT POINT~ER
	MOVE T2,(P)		;GET POINT~ER BACK

{Page 24}
TTYEN1:	POP P,T2		;RESTORE ARG POINT~ER

{Page 27}
	SOS (P)			;RETURN POINT~ING TO UUO

{Page 28}
	LDB F,[POINT~ HISPRT,T1,HINPRT]	;GET PORT NUMBER
HIBNWK:	LDB T2,[POINT~ HISTIM,T1,HINTIM]

{Page 32}
SETTIM:	LDB T2,[POINT~ HISTIM,T1,HINTIM]	;GET TYPE (MS, SEC, MIN)
	DPB T2,[POINT~ 11,T1,11]	;SET UP DISPATCH AND TYPE
	DPB J,[POINT~ 7,T1,18]	;AND JOB

SCHED1.MAC	
{Page 7}
;A Q-HEADER POINT~ING TO THE FIRST AND LAST MEMBERS OF THE Q.
;ITS CONTENTS CONTAINS THE LINKING POINT~ERS. THESE
;POINT~ERS ARE ALSO INDICIES RELATIVE TO JBTQ RATHER THAN
;ABSOLUTE ADDRESSES--RH(LINK)=FOWARD POINT~ER;
;LH(LINK)=BACKWARD POINT~ER.

{Page 8}
QINI:	MOVNI	T1,MXQUE	;MAKE ALL QUEUE HEADERS POINT~ TO THEMSELVES
	HRL	T1,T1		;BACKWARD POINT~ERS TOO
	MOVSM	T1,JBTQ+1	;BACK POINT~ER FOR JOB 1
	MOVEM	T1,JBTQ(J)	;FORWARD POINT~ER OF JOBMAX JOB NO.
	HRLI	J,1		;SET NULQ HEADER TO POINT~
QINI1:	HRRM	J,JBTQ-1(J)	;JOB I-1 POINT~ TO JOB I
	HRLM	J,JBTQ+1(J)	;BACK POINT~ER JOB I+1 POINT~S TO JOB I

{Page 9}
	MOVE	U,(U)		;GET QUANTUM TIME (POINT~ER IS @)

{Page 17}
;AT THIS POINT~, WE CAN THEN RECOVER.

{Page 24}
	IN.  AT ANY POINT~ IN EITHER OF THE TWO PHASES OF

{Page 32}
	MOVSI	W,-NCTXPG	;AOBJN POINT~ER TO CTXTAB

{Page 33}
	MOVE	P3,EPYPSM	;POINT~ER TO %UPS SLOTS [EPTPTR(%UPS.N-1)]

{Page 40}
	MOVE	T1,UPT+UPTACP	;GET AC STACK POINT~ER
SWICS8:	MOVE	W,[-NCTXPG,,<%UPT.N+CNVVPN>] ;AOBJN POINT~ER TO VIRTUAL PAGE
	MOVEI	T1,DABBIT(J)	;GET DUMMY ATB POINT~ER

{Page 44}
	DPB	W,USYLSP	;THIS IS THE FIRST LMAP SCAN POINT~ER
	LDB	W,USYLSP	;GET LMAP SCAN POINT~ER
;HERE WITH W/ LMAP SCAN POINT~ER, P1/RESERVED PAGES LEFT,

{Page 48}
; SWAP IN SCAN YET, SO MUST REMEMBER LMAP SCAN POINT~ER,
	DPB	W,USYLSP	;STORE LMAP SCAN POINT~ER
; NO NEED TO STORE ANY POINT~ERS IN THE LMAP

{Page 58}
	MOVE	W,[-NCTXPG,,%UPT.N+CNVVPN] ;GET AOBJN POINT~ER
	PUSHJ	P,MPSUPS	;YES, POINT~ IT BACK TO US

{Page 66}
	HRLZM	T1,JBTFIT(J)	;NEW LAST POINT~S BACK TO OLD LAST, FORWARD
	HRRM	J,JBTFIT(T1)	;OLD LAST POINT~S FORWARD TO NEW LAST
	HRLM	T2,JBTFIT(T1)	;NEXT POINT~S BACK TO LAST
	HRRM	T1,JBTFIT(T2)	;AST POINT~S FORWARD TO NEXT

{Page 67}
	ADD	P,[^D10,,^D10]	;SAVE 10 ACS. ADVANCE STACK POINT~ER
	MOVE	T1,P		;GET COPY OF POINT~ER

{Page 68}
VIRTUAL ADDRESSES %UPT+X DO NOT POINT~ TO THEMSELVES YET.
MPSUPS:	JSP	T4,SAVE1	;SAVE P1 FOR BYTE POINT~ER,
				; P2 IS AOBJN POINT~ER

SCNSER.MAC	
{Page 4}
;DEFINE RECEIVED CHARACTERISTICS BYTE POINT~ERS
LDP'N:	POINT~ W,LDBTMR+ZZWORD(U),ZZPOS>

{Page 5}
;DEFINE SENT CHARACTERISTICS BYTE POINT~ERS
LDS'N:	POINT~ W,LDBTMS+ZZWORD(U),ZZPOS>

{Page 6}
	LOP'NAME:POINT~ 1,LDBOUT(U),ZZN

{Page 7}
LDBOPB:! 0	;BYTE POINT~ER TO SET NEED-OUTPUT BIT
LDBBKP:! 0	;^U POINT~ER, RESET TO HERE
LDBFLP:! 0	;OUTPUT FILLER POINT~ER (FOR HT/VT/FF PADDING)

{Page 14}
;RANDOM LDB BYTE POINT~ERS
TRMBYP:	POINT~ 5,LDBLOG(U),11	;TERMINAL ID CODE
LDPLNO:	POINT~ 9,LDBLIN(U),35	;PORT NUMBER
LDPTBK:	POINT~ 1,LDBBYT(U),2	;TABS-AS-BREAKS
LDPBBP:	POINT~ 1,LDBBYT(U),3	;BACKSPACE-AS-PUNCTUATION
LDPNTB:	POINT~ 1,LDBBYT(U),4	;NO SPECIAL TAB HANDLING
LDPBSP:	POINT~ 1,LDBBYT(U),8	;BS OR ERASE FOR CHAR DELETE
LDPMOD:	POINT~ 2,LDBBYT(U),11	;MONITOR MODE
LDPFC2:	POINT~ 2,LDBBYT(U),13	;FILLER CLASS 2
LDPFA2:	POINT~ 2,LDBBYT(P1),13
LDPWID:	POINT~ 8,LDBBYT(U),21	;LINE WIDTH
LDPWDA:	POINT~ 8,LDBBYT(P1),21
LDPFC1:	POINT~ 2,LDBBYT(U),23	;FILLER CLASS 1
LDPFA1:	POINT~ 2,LDBBYT(P1),23
LDPTIM:	POINT~ 4,LDBBYT(U),27	;IMAGE INPUT TIMEOUT TIMER
LDPPOS:	POINT~ 8,LDBBYT(U),35	;ESTIMATED POSITION ON LINE
LDPPSM: POINT~ 4,LDBMOD(U),5	;LAST PORT-STATUS MSG
LDPCHG:	POINT~ 7,LDBMOD(U),15	;IMAGE COUNT FOR CHARGING
LDPLMD:	POINT~ 7,LDBMOD(U),22	;ALL THE LINE MODE (INPUT AND ECHO)
LDPMEC:	POINT~ 3,LDBMOD(U),18	;ECHO LINE MODE
LDPMIN:	POINT~ 4,LDBMOD(U),22	;INPUT LINE MODE
LDPIMB:	POINT~ 9,LDBMOD(U),31	;IMAGE MODE BREAK CHARACTER
LDPMOU:	POINT~ 4,LDBMOD(U),35	;OUTPUT LINE MODE
LDPSOX:	POINT~ 1,LDBDCH(U),1	;SUPPRESS OUTPUT TRANSLATION
LDPCOM:	POINT~ 1,LDBDCH(U),4	;COMMAND MODE BIT
LDPMDF:	POINT~ 5,LDBDCH(U),8	;SOURCE OF LINE MODE INFO
LDPNFC:	POINT~ 1,LDBDCH(U),10	;NO FREE CRLFS
LDPLCT:	POINT~ 1,LDBDCH(U),13	;LOWER CASE TRANSLATION (TO UPPER)
LDPTAB:	POINT~ 1,LDBDCH(U),14	;HARDWARE TABS
LDPPTP:	POINT~ 1,LDBDCH(U),16	;PAPER TAPE MODE
LDPFRM:	POINT~ 1,LDBDCH(U),17	;HARDWARE FF/VT
LDPNXO:	POINT~ 1,LDBDCH(U),20	;DON'T SEND XON/XOFF
LDPDEM:	POINT~ 1,LDBDCH(U),21	;PERPETUAL DEFERRED ECHO MODE
LDPBSD:	POINT~ 1,LDBDCX(U),2	;BACKSPACE == RUBOUT/^A
LDPERA:	POINT~ 1,LDBDCX(U),3	;ERASE ON CHAR DEL
LDPLCO:	POINT~ 1,LDBDCX(U),5	;LOWER CASE OUTPUT ONLY
LDPRTC:	POINT~ 1,LDBDCX(U),7	;[Darren] special ^T mode
LDPTTP: POINT~ 36,LDBTTP(U),35	;[dws] terminal type word

{Page 15}
;TTY DDB INTERRUPT-TO-CHANNEL BYTE POINT~ERS
DDPT'N:	POINT~ 6,DDBTRP+ZZWORD(F),ZZBIT>
;OTHER DDB BYTE POINT~ERS
DDPBBP:	POINT~ 1,DDBDCH(F),0	;BACKSPACE AS PUNCTUATION
DDPTBK:	POINT~ 1,DDBDCH(F),1	;TABS ARE BREAKS
DDPNTB:	POINT~ 1,DDBDCH(F),2	;NO SPECIAL TAB ACTION
DDPIMB: POINT~ 9,DDBDCH(F),35	;IMAGE MODE BREAK CHARACTER
DDPMOD: POINT~ 4,DEVIOS(F),35	;DATA MODE
DDPCOM: POINT~ 1,DDBDCH(F),3	;SAVED STATE OF LDLCOM
DDPNZP:	POINT~ 1,DEVMOD(F),5	;NO-ZAP BIT

{Page 16}
;TTY DDB. ONCE CREATES ONE OF THESE PER JOB FOR TTYTAB TO POINT~ TO.

{Page 25}
;BUFFER RING BYTE POINT~ERS
INPTYP:	POINT~ 8,IRING(P4),BYP1	;TYPE
INPLIN:	POINT~ 8,IRING(P4),BYP2	;LINE NUMBER
INPCHR:	POINT~ 8,IRING(P4),BYP3	;CHARACTER
INPCH2:	POINT~ 8,IRING(P4),BYP4	;SECOND DATA CHARACTER
INPDL1:	POINT~ 16,IRING(P4),BYP2	;FIRST TWO CHRS
INPDL2:	POINT~ 16,IRING(P4),BYP4	;SECOND TWO CHRS
;POINT~ER FOR PUTTING THINGS IN THE OUTPUT RING
OUPTYP:	POINT~ 8,ORING(P4),BYP1	;TYPE
OUPLIN:	POINT~ 8,ORING(P4),BYP2	;PORT NUMBER
;POINT~ERS FOR ASSEMBLING FULL WORDS FOR OUTPUT (IN P3)
WRPLIN:	POINT~ 8,P3,BYP2		;PORT NUMBER
WRPCHR:	POINT~ 8,P3,BYP3		;DATA CHARACTER
WRPCH2:	POINT~ 8,P3,BYP4		;SECOND DATA CHARACTER

{Page 26}
CHPINP:	POINT~ 2,P3,1	;POINT~ER TO THE INPUT FIELD
CHPOUT:	POINT~ 2,P3,3	;POINT~ER TO THE OUTPUT FIELD
CHPSPO:	POINT~ 3,P3,6	;POINT~ER TO THE OUTPUT SPECIAL ACTION FIELD
CHPRED:	POINT~ 3,P3,9	;POINT~ER TO THE READ FIELD
CHPECH:	POINT~ 3,P3,12	;POINT~ER TO THE ECHO FIELD
CHPSPR:	POINT~ 3,P3,15	;POINT~ER TO THE READ SPECIAL ACTION FIELD
CHPSPI:	POINT~ 5,P3,20	;POINT~ER TO THE INPUT SPECIAL ACTION FIELD
CHPSPE:	POINT~ 4,P3,24	;POINT~ER TO THE ECHO SPECIAL ACTION FIELD

{Page 33}
	MOVE P1,IRPMB2		;SAVE PREVIOUS BASE POINT~ER
	MOVE P1,IRPMB1		;SAVE PREVIOUS BASE POINT~ER
	MOVEM P1,IRPMB1		;SAVE CURRENT BASE POINT~ER TOO
	MOVE P1,IRPMP2		;SAVE PREVIOUS MESSAGE POINT~ER
	MOVE P1,IRPMP1		;SAVE PREVIOUS MESSAGE POINT~ER
	MOVEM P4,IRPMP1		;SAVE MESSAGE POINT~ER TOO

{Page 43}
	DPB T2,[POINT~ 16,T1,19]

{Page 45}
	HRLI T1,(POINT~ 8,0,BYP2)	;SET UP A BYTE POINT~ER
	ADD P4,P1	;INCREMENT POINT~ER BY NUMBER USED

{Page 47}
	PUSHJ P,RECVRG	;MUST SET UP THE INPUT POINT~ERS
	MOVEM T2,LDBTIP(U)	;SET UP INPUT POINT~ERS

{Page 53}
IMGRM1:	MOVEM T2,LDBECT(U)	;FIX ECHO POINT~ER

{Page 54}
IACT2A:	SETZM LDBBKI(U)		;RESET ^U POINT~ERS
	JRST IACT2A		;GO RESET ^U POINT~ER

{Page 59}
;PUT IN A WHOLE STRING, BYTE POINT~ER IN T4

{Page 60}
	SETZM LDBBKI(U)	;RESET ^U POINT~ER

{Page 65}
;GET RID OF A LINE OF TEXT. ADJUST ALL POINT~ERS
RIDLIN:	SKIPN T1,LDBBKP(U)	;IS THERE A ^U POINT~ER
	HRRZ T2,LDBBKI(U)	;NUMBER OF CHRS SINCE ^U POINT~ER
	MOVEM T1,LDBECT(U)	;RESET ECHO POINT~ER

{Page 67}
	MOVEM T2,LDBECT(U)	;RESET ECHO POINT~ER TO INPUT

{Page 76}
;	CHRWRP+1 TO POINT~ TO THE NEXT FREE BYTE IN THE
;	OTHERWISE, IT SETS CHRWRP+1 TO POINT~ TO THE
	MOVE	T1, [POINT~ 8, PTYBUF]
	MOVE	T2, BIOPBP(T1)	;T2/ BLOCK IDPB POINT~ER

{Page 77}
;	POINT~ER&COUNT AND SEE IF WE'VE FILLED IT YET
	MOVE	T1, CHRWRP+1	;T1/ BYTE POINT~ER
	CAMN	T1, [POINT~ 8, PTYBUF]
	PUSH	P, [POINT~ 8, PTYBUF]
    ;-1(P) IS ORIGINAL ENDING BYTE POINT~ER
    ;  (P) IS SOURCE BYTE POINT~ER

{Page 78}
	MOVEM	T3, BIOPBP(T1)	;UPDATE BYTE POINT~ER

{Page 82}
	MOVE	T2, [POINT~ 8,BIODAT]
	MOVEM	T2, BIOPBP(T1)	;STORE PTY BYTE POINT~ER

{Page 84}
	MOVE	T3, [POINT~ 8,BIODAT]
	ADD	T3, T1		;T3/ BYTE POINT~ER
	MOVE	T3, BIOPBP(T1)	;T3/ POINT~ER
PGBOP3:	MOVEM	T3, BIOPBP(T1)	;  UPDATE CHARACTER POINT~ER

{Page 87}
	HRLI T1,(POINT~ 8,0,BYP2);SET TO PUT FIRST IN 3RD BYTE
	MOVEM T1,CHRWRP+0	;SET BYTE POINT~ER

{Page 88}
	AOS P4,ORPPDP	;JUST ADVANCE OUTPUT POINT~ER
	AOS CHRWRP+0	;INCREMENT CHAR BYTE POINT~ER.

{Page 93}
	HRRZI	T2, ZBGBUG-1	;(PDL POINT~ER)

{Page 95}
	DPB	T1, [POINT~ ^D16, P3, BYP4]
		STOPCD		;THERE HAS TO BE ONE AT THIS POINT~
	DPB	T2,[POINT~ 11,T1,26]	;PAGE # OVERLAYS HIGH 11 BITS
	DPB	T1,[POINT~ 8,P3,BYP3]	;LOW 8 BITS TO 3RD BYTE POS.
	DPB	T1,[POINT~ 10,P3,BYP2]	;THE REST IN BYTES 1 & 2
	DPB	T1,[POINT~ 18,P3,23] ;PUT IT IN
IFCPU (KI),<DPB	T1,[POINT~ 9,P3,23] ;PUT IN LOW 9 BITS, MAP SMASHES THEM
	DPB	T1,[POINT~ 9,P3,14] ;PUT IN HIGH 9 BITS.

{Page 99}
;THE ECHO POINT~ER AND REPORT NON-COMPLETION TO THE DISPATCHER
ECHBAK:	ADDM T3,LDBECT(U)	;BACK UP POINT~ER

{Page 108}
	ADDM	T3,LDBECT(U)	;BACK UP BYTE POINT~ER

{Page 109}
		SETZM	LDBFLP(U)	;CLEAR THE POINT~ER

{Page 110}
;	   A BYTE POINT~ER). OTHERWISE, IT SKIP-RETURNS. IT MAY

{Page 113}
;SPOFIL -- CALLED WITH T4/ FILL POINT~ER. OUTPUT THE FILL CHARACTERS.
;	   TO POINT~ TO WHAT'S LEFT, SET P1 = -1, AND LET GOFIL

{Page 114}
;FILLER	POINT~ERS AND VARIOUS ECHO POINT~ERS
CCPTR:	POINT~ 7,CCASC
CRPTR:	POINT~ 7,CCASC,20	;JUST THE RETURN FROM ABOVE
CUPTR:	POINT~ 7,CUASC
UPARPT:	POINT~ 7,UPASC
COPTR:	POINT~ 7,COASC
FLLBSC:	POINT~ 7,BSLASC
FFFLP:	POINT~ 7,FFLP0		;FILLER FOR SIMULATING FORM FEED
VTFLP:	POINT~ 7,FFLP0,27	;FILLER FOR SIMULATING VERTICAL TAB
IFE XXXR,<POINT~ 7,FILERS+XXXQ>
IFN XXXR,<POINT~ 7,FILERS+XXXQ,<7*XXXR>-1>>>
;THE ABOVE MACRO DEFINES POINT~ERS INTO A LIST OF FILLERS (377)

{Page 116}
TABPTR:	POINT~ 7,SSPT
	POINT~ 7,SSPT,6		;FILLERS TO SIMULATE TABS WITH SPACES
	POINT~ 7,SSPT,13
	POINT~ 7,SSPT,20
	POINT~ 7,SSPT,27
	POINT~ 7,SSPT+1
	POINT~ 7,SSPT+1,6
	POINT~ 7,SSPT+1,13

{Page 122}
	EXCH T1,(T2)		;CHANGE EL POINT~ER
	HRRZM T2,TTFREE		;AND FREE POINT~ER

{Page 123}
;CALL WITH T2 CONTAINING A BYTE POINT~ER TO THE LIST
;THIS ROUTINE WILL IBP T2 WHICH MAY POINT~ IT INTO A LINK WORD
;ALSO WE MAY BE CALLED WITH THE POINT~ER DECREMENTED SO THAT
;IBP WILL POINT~ TO THE CURRENT CHUNKS LINK WORD
;ON RETURN, T2 CONAINS THE BYTE POINT~ER TO THE CHARACTER
	HLRZ T1,(T2)	;SO GET BACK LINK (T2 POINT~S TO FIRST WORD OF CHUNK)
	HRR T2,T1	;NOW POINT~ TO CORRECT WORD
	AOSA T2		;IF FORWARD, POINT~ TO FIRST CHR

{Page 124}
;CHARACTER IS IN T3. T2 CONTAINS A BYTE POINT~ER TO LAST
TTPC2:	HRRI T2,1(T1)	;NOW RESET BYTE POINT~ER

{Page 125}
;A BYTE POINT~ER IN T2. CLOBBERS T1
	HRLI T2,(POINT~ 9,0,35)	;POINT~ SO THAT IBP POINT~ TO 1ST CHR

{Page 128}
	HRRZ P1,DEVIAD(F)		;PREPARE BYTE POINT~ER TO STORE
	XCTFU <LDB P2,[POINT~ 17,(P1),17]>	;BUFFER SIZE IN WORDS
	HRRZ T1,DEVBUF(F)	;BUFFER POINT~ER FOR SIZE

{Page 129}
TTYSZS:	XCTBU <LDB T2,[POINT~ 6,1(T1),11]>	;GET POINT~ER SIZE
	DPB T2,[POINT~ 6,P1,11]	;SET IN P1 POINT~ER
	AOJA P1,CPOPJ	;ADD 1 TO POINT~ TO FIRST DATA WORD

{Page 130}
	HLRZ T1,DEVBUF(F)	;GET POINT~ER TO BUFFER HEADER

{Page 135}
	HLLZS	DDBLDB(F)	;Clear DDB-to-LDB point~er
	HLLZS	LDBDDB(U)	;Clear LDB-to-DDB point~er

{Page 138}
	MOVE	T2, [ILDB POINT~ER TO ASCIZ MESSAGE IN USER SPACE]

{Page 139}
    ;HERE WITH T2/ ILDB POINT~ER, T3/ TALKEE LDB TO SEND A MESSAGE
	PUSH	P, T2		;AND SAVE BYTE POINT~ER

{Page 141}
	XWD TUUATO!TUUROM,OUTPTR	;17 OUTPUT FROM POINT~ER

{Page 142}
	HRLI M,(POINT~ 7,0)			;POINT~ TO USER AREA

{Page 144}
;OUTPTR -- OUTPUT FROM BYTE POINT~ER
	XCTFU <MOVE W,(M)>	;GET BYTE POINT~ER
	LDB T3,[POINT~ 6,W,11]	;GET SIZE FIELD
	ADDM T3,W		;BACK UP POINT~ER 1 POSITION
;OUTPTC -- OUTPUT FROM BYTE POINT~ER + COUNT
	XCTFU	<MOVE W, 1(M)>	;W/ BYTE POINT~ER
	TLZ	W, 37		;W/ BYTE POINT~ER - INDEX&INDIRECT BITS
OUTPC2:	LDB	T3, [POINT~ 6,W,11]
	ADDM	T3, W		;DECREMENT BYTE POINT~ER BY 1 BYTE
	XCTTU	<MOVEM W, 1(M)>	;AND BYTE POINT~ER
	XCTFU	<MOVE W,1(M)>	;W/ BYTE POINT~ER
	TLZ	W,37		;W/ BYTE POINT~ER - INDEX & IND BITS

{Page 150}
GEPMC1:	POINT~ 2,T1,16	;FILLER CLASS 1
GEPMC2:	POINT~ 2,T1,14	;FILLER CLASS 2
GEPMC3:	POINT~ 8,T1,12	;WIDTH
GEPMC4:	POINT~ 3,LDBBYT(U),4	;GET NO XON, NO TAB, TAB AS BRK
GEPMC5:	POINT~ 3,T1,4	;LOCATION OF ABOVE IN GETTMC WORD
GEPMC6:	POINT~ 3,T1,19	;IR
GEPMC7:	POINT~ 3,T1,22	;OR
GEPMC8:	POINT~ 1,T1,23	;PAR
GEPMC9:	POINT~ 3,T1,26	;PA
GEPM10:	POINT~ 1,T1,27	;HDX
GEPM11:	POINT~ 3,T1,30	;PB
GEPM12:	POINT~ 5,T1,35	;0 BIT + PC

{Page 153}
;	   BY ADJUSTING COUNTS, LINE DELETE POINT~ER
	MOVEM	T2, LDBBKP(U)	;  SET LINE-DELETE POINT~ER TO NOW

{Page 154}
	MOVE	T2, LDBECT(U)	;T2/ ECHO-TAKER BYTE POINT~ER
	MOVE	T2, LDBTIT(U)	;T2/ CHAR-TAKER BYTE POINT~ER
    ;T2/ BUFFERLET BYTE POINT~ER, T4/ COUNT

{Page 158}
	DPB	T2, [POINT~ 8,     T1, 35]

{Page 161}
	TUUROM,,OUTPTR	;5 OUTPUT FROM POINT~ER
	TUUROM,,OUTPTC	;67 OUTPUT FROM POINT~ER+COUNT
	FRCRSC		;72 FORCE A RESCAN LINE (COUNT/POINT~ER 

{Page 163}
BYTTC:	HLRZ	T1, TCNDSP(T1)	;T1/ BYTE POINT~ER ADDR

{Page 173}
FRCINP:	UMOVE M,(M)	;GET BYTE POINT~ER

{Page 175}
	XCTFU	<MOVE PG, 1(M)>	;PG/ BYTE POINT~ER
	XCTTU	<MOVEM PG, 1(M)>;  STORE BACK THE MODIFIED BYTE POINT~ER

{Page 181}
RCVS2A:	MOVE T1,[POINT~ 7,AUXSTR]

{Page 182}
	HRRZM	U, AUXRCP	; SAVE THE LINE POINT~ER

{Page 184}
	AOJA P4,AUXCLP	;ADVANCE POINT~ER AND CONTINUE
AXCLP2:	ADDI P4,1	;ADVANCE POINT~ER
	MOVEM P4,ORPPDP	;SAVE POINT~ER FOR 620

{Page 185}
	HRLI T1,(POINT~ 7,0)	;GET POINT~ER TO THE STRING
	MOVE P4,[POINT~ 7,AUXSTR]	;SET TO SAVE IT
	MOVE T4,[POINT~ 6,AUXUNM]	;SET TO ACCUMULATE A USER NAME
	MOVEI T4,0	;BY ZAPPING POINT~ER

{Page 186}
        HRRZM   P4,AUXEND#      ;SAVE POINT~ER TO LAST WORD OF LOGIN STRING

{Page 187}
IFKMC<	LDB T3,[POINT~ 2,P1,2]	;GET TYMBASE NUMBER

{Page 190}
	HRR	T2, T1		; T2/ AOBJN POINT~ER

{Page 191}
BIOPBP==2	;PTY BLOCK I/O: ILDB/IDPB POINT~ER FOR NEXT BYTE

{Page 196}
	PUSH	P,T4		;TO HOLD DESTINATION BYTEPOINT~ER
	HRLI	T3,(POINT~ 18,0)	;PACK HALFWORD BYTES INTO
	HRLI	T4,(POINT~ 16,0)	;	FULLWORD BYTES

{Page 198}
	PUSH	P,T4		;TO HOLD DESTINATION BYTEPOINT~ER
	HRLI	T3,(POINT~ 16,0)	;UNPACK FULLWORD BYTES INTO
	HRLI	T4,(POINT~ 18,0)	;		HALFWORD BYTES

{Page 205}
;RELBB -- RELEASE THE BLOCK I/O BUFFER POINT~ED TO BY T1

{Page 208}
	SKIPN T1,LDBBKP(U)	;ANYTHING IN ^U POINT~ER
	CAMN T1,T2		;IS THIS THE POINT~ER NOW
	JUMPN T1,CPOPJ	;DON'T WORRY IF NO ^U POINT~ER

{Page 212}
	PUSHJ	P, GETCHK	;  T2/ CHUNK BYTE POINT~ER

{Page 220}
	HRRZ	F,LDBDDB(U)	;Set up DDB point~er
;; Routine to set up command input point~er to accept command
TRESCN:	MOVE	T2,LDBTIT(U)	;TTY input buffer point~er
	MOVEM	T2,TTCMCA	;Copy into command input point~er

{Page 225}
CTYTYP:	MOVSI P3,440700!P1		;POINT~ER FOR ASCIZ

{Page 228}
TTYHLT::		;Global entry point~ to put TTY in cmd mode

{Page 233}
	PUSH P,[POINT~ 6,-1(P)]		;POINT~ER TO READ CHARS

{Page 234}
	HRLI T3,220600			;POINT~ 6,0,17

{Page 236}
	HRLI M,(POINT~ 7,0)

{Page 241}
	MOVE T2,ORPPDP	;PICK UP THE OUTPUT RING POINT~ER.
	LDB T1,[POINT~ 16,ALR620,15]
	DPB T1,[POINT~ 16,P3,BYP4]
	ANDI P4,MSKORG	;POINT~ TO CORRECT LOCATION (POSSIBLE WRAP)
	LDB T1,[POINT~ 16,ALR620,31]
	DPB T1,[POINT~ 16,P3,BYP2]

{Page 243}
	HRLM T2,DDBBLK(T1)	;YES, SET ITS BACK POINT~ER
	HRRZ F,T2	;POINT~ TO PRED FOR LINKING

{Page 248}
  DEFINE RTYMOD(X) = <[POINT~ 2,X,2]>

{Page 256}
;	   POINT~ER TO IT IN TTYTAB(J)

{Page 257}
	MOVE T3,[POINT~ 6,DEVNAM(F),17]

{Page 268}
TINASS:	LDB T3,[POINT~ 9,T1,17]	;GET THE CHANNEL NUMBER
	LDB T2,[POINT~ 9,T1,8]	;GET INTERRUPT NUMBER

{Page 269}
;if this ever changes!  The CONFIG gettab point~s to TTYINI as
	MOVE P1,[POINT~ 1,LINFLG]	;READY TO SET BYTE PTRS
TTINI2:	HRRZ U,LINTAB(P2)	;POINT~ TO LDB
	IBP P1		;TO POINT~ TO NEXT BIT
;;***NOTE*** uses TTYFLK, which point~s at DEVLST-DEVSER.  This

{Page 270}
	MOVEI J,TTCHKS(T1)	;SET FREE POINT~ER TO FIRST
	SETZM IRPPDP	;RESET ALL POINT~ERS
	MOVE T3,[POINT~ 7,CONFIG,6]

{Page 274}
LINPTR:	0	;OUTPUT SCAN POINT~ER
TTCMCA:	0	;INPUT POINT~ER FOR COMMAND BEING DECODED
FRETTY:	0	;POINT~ER TO FREE TTY DDBS
TTYFLK:	0	;POINT~ER TO WHERE TO LINK IN TTY BLOCKS
CHRRDP:	0	;BYTE POINT~ER TO INPUT RING FOR CHARACTER INPUT
CHRWRP:	0	;REAL TTY: BYTE POINT~ER TO OUTPUT RING
	0	;PTY: BYTE POINT~ER TO PTY BUFFER

{Page 275}
AUXSTP:	0	;STRING POINT~ER

CIOPR.MAC	
CTYSIM.MAC	
{Page 2}
	MOVE P,[-20,,RETCTP]		;AND SET PUSHDOWN POINT~ER
	MOVE	P,[-20,,RETCTP]	;AND SET PUSH DOWN POINT~ER
	DPB T1,[POINT~ 8,T2,23]	;PUT IN THE CHR

{Page 3}
CTYBRK:	POPJ P,			;A GOOD PLACE FOR A BREAKPOINT~
	JRST	[MOVE T1,[POINT~ 7,[ASCIZ /
    B   Break-point~

{Page 4}
	MOVE T4,ORP620		;GET OUTPUR RING POINT~ER
CTOLP:	ANDI T4,MSKORG		;THIS IS THE CONTINUE POINT~
	LDB T1,[POINT~ 8,ORING(T4),BYP1]	;GET TYPE
	LDB T2,[POINT~ 8,ORING(T4),BYP2]
	HRLI T1,(POINT~ 8,0,BYP2)
	MOVEM T1,CTOPNT	;SET UP THE POINT~ER
	SETZM CTOPNT	;CLEAR THE POINT~ER

{Page 5}
ZAPCIR:	LDB T1,[POINT~ 8,ORING(T4),BYP2]	;GET PORT
	MOVE T1,[POINT~ 7,[ASCIZ /

{Page 7}
	MOVE T1,[POINT~ 7,AXSTR]
	MOVEM T1,AXSTRP	;POINT~ER FOR STRING
SUPCHR:	LDB T1,[POINT~ 7,ORING(T4),BYP3]	;GET CHR
SUPFIN:	LDB T1,[POINT~ 7,CONFIG,13]
	LDB T2,[POINT~ 7,CONFIG,20]	;GET THIS SYSTEM NUMBER

{Page 8}
	DPB T3,[POINT~ 8,T2,15]
	LDB T3,[POINT~ 8,ORING(T4),BYP2]	;GET PORT OF REQUESTER
	DPB T3,[POINT~ 8,T2,23]	;AND PUT IN PORT REQUEST
	LDB T3,[POINT~ 8,ORING(T4),BYP2]
	DPB T3,[POINT~ 8,T2,15]
	DPB T1,[POINT~ 8,T2,15]	;NOW LOG IN NEW PORT
	DPB T1,[POINT~ 8,T2,15]
	MOVE T3,[POINT~ 7,AXSTR]
	DPB T3,[POINT~ 8,T2,23]
	DPB T3,[POINT~ 8,T2,31]

{Page 9}
SUPSYW:	LDB T1,[POINT~ 8,ORING(T4),BYP2]
	DPB T1,[POINT~ 8,T2,15]
	HRLI T1,(POINT~ 8,0,BYP2)
	LDB T1,[POINT~ 8,ORING(T4),BYP2]
	DPB T1,[POINT~ 8,T2,15]
	DPB T1,[POINT~ 8,T2,23]
	DPB T1,[POINT~ 8,T2,31]

{Page 10}
	LDB T1,[POINT~ 8,T2,15]
	DPB T1,[POINT~ 8,T2,15]
YELTRN:	LDB T1,[POINT~ 8,ORING(T4),BYP2]
ZAPTRN:	LDB T1,[POINT~ 8,ORING(T4),BYP2]
	DPB T3,[POINT~ 8,T2,15]
GOBTRN:	LDB T2,[POINT~ 8,ORING(T4),BYP2]

{Page 11}
	MOVE T1,[POINT~ 7,[ASCIZ /
CTOPNT:	0	;OUTPUT POINT~ER

SEGCON.MAC	
{Page 2}
COMMENT ! REGISTER PG IS SET TO POINT~ TO THE BASE OF THIS BLOCK
 BY SAVARG ROUTINE. REGISTER P IS ADVANCED TO POINT~ TO THE WORD

{Page 3}
	RUN,RUNSEG/GETSEG. RETURN (PG) SETUP TO POINT~

{Page 4}
; BLOCK SO THINGS CAN STILL BE PUSHED; PG POINT~S TO BASE OF ARG BLOCK
	AOBJP	T1,GNUA1	;UPDATE USER POINT~ER (IF OVERFLOW, DONE)
	AOBJN	T2,GNUALP	;UPDATE OUR POINT~ER (IF OVERFLOW, ERR)

{Page 5}
	AOBJP	T1,GNUAX1	;UPDATE USER POINT~ER (IF OVERFLOW, DONE)
	AOBJN	T2,GNUAXL	;UPDATE OUR POINT~ER (IF OVERFLOW, ERR)

{Page 7}
			(PG) POINT~S AT BLOCK

{Page 8}
	MOVSI P2,(POINT~ 6,0)

{Page 9}
	FAMILIAR PDL STRUCTURE WITH ARG BLOCK POINT~ED TO

{Page 10}
	LDB P3,[POINT~ 9,XPAPRV(PG),8]

{Page 14}
	LDB M,[POINT~ 4,M,12] 	;GET CALLING AC NUMBER

{Page 15}
	MOVE T1,[XWD -100,377777]	;FAKE PDL POINT~ER

{Page 16}
	MOVEI	T1,JOBSV ;POINT~ TO 1ST DATA WORD

{Page 17}
	HRROI	T1,(T2)	;FROM DATA POINT~ER
EXPLP2:	XCTBU <HRRZ	P1,(T1)>	;TO DATA POINT~ER
	SUBI	T2,1(P2)	;POINT~ T2 TO PREVIOUS IOWD
	SOSA	T1		;POINT~ TO DATA

{Page 32}
FUNCTION: RESET PDL POINT~ER AS IT WAS BEFORE GTUARG OR SG1 WAS CALLED;
EXPECTS: (PG) POINT~ING AT 0TH WORD OF ARG BLOCK

{Page 33}
	MOVEI T1,T2	;POINT~ AT ARG BLOCK T2:T3

TMPUUO.MAC	
{Page 9}
	HRRZ	P2,P1		;SAVE OLD POINT~ER

SIMIO.MAC	
{Page 1}
UPYCVP:	POINT~ UPSCVP,%UPT+UPTSIM(W),UPNCVP	;CHANNEL VIRTUAL PAGE
GOTHOL==1B21	;UPTPOS CURRENTLY POINT~S AT A HOLE PAGE

{Page 4}
	LDB PG,[POINT~ UPSCVP,T1,UPNCVP]	;THE VP SLOT WE'RE STEALING
	DPB T4,[POINT~ UPSCVP,T1,UPNCVP] ;OLD CHAN NOW HAS NO PAGE
	DPB PG,[POINT~ UPSCVP,T3,UPNCVP] ;NEW CHAN NOW HAS VP SLOT

{Page 7}
;BEGIN CODE FOR OUTPUT ONLY--AT SOME POINT~ IN THE USAGE ON

{Page 9}
OUBLT1:	;COMPUTE BLT POINT~ERS FOR XFER DATA TO FILE PG 
	POINT~ OF THE ILLEGAL ADDRESS, WHEREAS UNDER THE

IOCSS.MAC	
{Page 7}
;	WORD 2:	BYTE POINT~ER TO CURRENT ITEM.
;		USING THE BYTE POINT~ER IN THE 3 WORD HEADER).

{Page 16}
	AOJA M,UINIT0		;MAKE M POINT~ TO ARG+1(WITH R STILL

{Page 17}
	AOS T2		;POINT~ TO SECOND WORD (BYTE POINT~ER)
	AOS T2		;POINT~ TO THIRD WORD (J COUNT)

{Page 19}
MOVBUF::LDB W,[POINT~ 4,T1,17]	;GET CHANNEL

{Page 20}
UUYCTG: POINT~ ^D10,T1,17
UUYCPR: POINT~ ^D3,T1,7
UUYSVM: POINT~ ^D10,T1,^D35

{Page 23}
	LDB	T4,[POINT~ 2,W,7] ;GET PROTECTION

{Page 27}
MGNBT4:	HRRZ	T2,DEVATB(F)	;DOES THIS DDB POINT~ TO

{Page 29}
	XCTBU <HRRZ U,1(T2)>		;GET BYTE POINT~ER

{Page 30}
;	OF HEADER (J COUNT) ALSO SET BYTE POINT~ER (SECOND

{Page 31}
SETNEW:	XCTBU <HRRM M,(U)>		;POINT~ HEADER TO NEW RING
	HRR T2,M		;AND LOAD NEW POINT~ER
				; AND GET POINT~ER TO NEXT BUFFER
	XCTBU <HRRZ T1,(U)>	;MAKE SURE THIS POINT~S TO CURRENT

{Page 32}
	XCTBU <HRR T1,(T1)>		;GET POINT~ER 1 BUFFER AHEAD OF NEXT BUFFER
	JRST IOSETC	;SET J COUNT AND BYTE POINT~ER
	HRRM T2,DEVIAD(F)	;MAKE SURE USER POINT~S TO THIS RING

{Page 37}
	HRRZ	T1,DEVCLS(F)	;BUFFER POINT~ER
	HRRZ	T1,-2(P2)	;GET OUT POINT~ER

{Page 38}
CTMBS:	HRRZ	T1,DEVCLS(F)	;POINT~ER TO BUFFER

{Page 39}
PTRXF2:	HRRZ	T3,DEVCLS(F)	;BUFFER POINT~ER
PTRXF4:	ADDI	T1,1		;ADVANCE OUT POINT~ER
PTRXF7:	HLRZ	T4,-2(T3)	;GET IN POINT~ER
	ADDI	P3,1		;ADVANCE UB POINT~ER
	ADDI	T1,1		;ADVANCE OUT POINT~ER
	HRRZ	T2,DEVIAD(F)	;POINT~ER TO CKSUM UN UB

{Page 40}
;8) THE J POINT~ER IS INITIATED TO THE CURRENT BUFFER ADDRESS+1

{Page 41}
	XCTBU <HRRZ T1,1(U)>		;GET RH OF BYTE POINT~ER.
	MOVEI T1,0		;YES, SET POINT~ER TO 0

{Page 42}
	HRRM T2,DEVOAD(F)	;NO, MAKE SURE OUTPUT POINT~S HERE BEFORE CONTINUING
	XCTBU <LDB J,[POINT~ 17,(T2),17]>

{Page 44}
	MOVEM	T1,-2(T1)	;STORE IN POINT~ER WORD
	HRRZ	P1,DEVCLS(F)		;MON. BUFFER POINT~ER
	HLRZ	P2,-2(P1)		;GET IN POINT~ER

{Page 46}
	HRLM	T2,DEVBWC(F)	;SET UP WORD COUNT POINT~ER

{Page 47}
	DPB PG,[POINT~ 13,T3,26]	;CONVERT TO PHYSICAL ADDRESS
	LDB PG,[POINT~ 13,T3,26] ;GET PAGE NUMBER
	LDB	PG,[POINT~ 13,T3,26] ;GET PAGE NUMBER

{Page 49}
	LDB P4,[POINT~ 4,DEVIOS(F),35]	;GET MODE (FOR TAPE)

{Page 50}
BLDLST:	PUSH P,T2	;SAVE ORIGINAL POINT~ER IN CASE OF ABORT

{Page 51}
	DPB P3,[POINT~ 14,-1(T2),13]
	LDB T3,[POINT~ 14,-1(T2),13]	;EXTRA AOBJN TO FIND OUT OF ROMM
	POP P,T4	;CLEAR SAVED POINT~ER FROM STACK
	POP P,T2	;AND GET BACK ENDING POINT~ER (NEG FOR ADRS CHECK

{Page 52}
	POP P,T1	;CLEAR SAVED POINT~ER OFF STACK

{Page 53}
	MOVSS	T2		;FORM POINT~ER
	HRRM T2,DEVCLS(F)	;SET LIST POINT~ER

{Page 54}
	HRRZ	P1,DEVCLS(F)	; FOR BUFFER POINT~ER
	HRRZ	T1,-2(P1)	;GET THE OUT POINT~ER
	HLRZ	T2,-2(P1)	; AND THE IN POINT~ER=ADDRESS OF BLOCK

{Page 60}
;CLEARS THE USE BIT (IOUSE:=0) OF THE BUFFER POINT~ED TO BY THE

{Page 62}
;SETS THE USE BIT (IOUSE:=1) OF THE BUFFER POINT~ED TO BY THE

{Page 66}
	PUSH P,U		;SAVE OUTPUT BYTE POINT~ER(TTY) OR INIT. ARG. ADR.

{Page 67}
	LDB T1,[POINT~ 12,DEVCHR(F),35];T1:=BUFFER SIZE

{Page 72}
;ROUTINE TO CLEAR RESIDUE OF WORD POINT~ED TO BY A BYTE POINT~ER
;CALLED WITH A BYTE POINT~ER IN AC T1, IT CLEARS THE REST OF THE
;WORD POINT~ED TO BY THE BYTE POINT~ER.
CLRBYT:	LDB T2,[POINT~ 6,T1,5]	;T2:=P
	DPB T2,[POINT~ 12,T1,11]	;T1 0-5:=0,T1 6-12:=P
	LDB T1,[POINT~ 7,T3,35]	;GET ARGUMENT TO T1
	LDB T3,[POINT~ 8,T1+1,35]	;BACK INTO T3

{Page 78}
;IT PUTS THE J POINT~ER (C(DEVCTR)) OF THE DEVICE SPECIFIED 
IOSET:	MOVE J,DEVCTR(F)	;J:=J POINT~ER=C(DEVCTR)
	XCTBU <LDB T2,[POINT~ 6,(U),11]>	;T2:=BYTE SIZE

{Page 79}
;WHERE BUFFER SIZE:=BITS 1-17 OF THE BUFFER HEADER WORD POINT~ED TO
ITMSET:	XCTBU <LDB J,[POINT~ 17,@DEVADR(F),17]>;J:=BUFFER SIZE-1
ITMCNT:	LDB T2,[POINT~ 6,DEVPTR(F),11];T2:=BYTE SIZE

{Page 81}
CHKMOD:	LDB T2,[POINT~ 4,M,35] ;GET DEVICE DATA MODE
;SETUP BYTE POINT~ER AND J COUNT

{Page 82}
;ROUTINE TO SETUP BYTE POINT~ER ACCORDING TO DATA MODE
	TLZ T1,37		;CLEAR INDEX FIELD OF POINT~ER

UUOCON.MAC	
{Page 1}
 THEN THE NEW PC WORD SELECTED POINT~S AT UUOPTR.

{Page 3}
	MOVE	P,[IOWD EPLLEN,%UPT+UPTPDL] ;SETUP STACK POINT~ER

{Page 6}
;CONTENTS OF USER AC PLACED IN AC T1,M SET TO POINT~

{Page 7}
	X VDSKPT,UVDSKP		;(-102) GET DISK POINT~ER FOR VP

{Page 11}
NINTRP:	POINT~ 6,DEVINT(F),5		;INPUT INTERRUPT
NOUTRP:	POINT~ 6,DEVINT(F),11		;OUTPUT INTERRUPT 
NWATRP:	POINT~ 6,DEVINT(F),17		;IO WAIT INTERRUPT
NERTRP:	POINT~ 6,DEVINT(F),23		;ERROR INTERRUPT
NEFTRP:	POINT~ 6,DEVINT(F),29		;EOF INTERRUPT
NSPTRP:	POINT~ 6,DEVINT(F),35		;SPECIAL INTERRUPT

{Page 12}
EXTERN	DDBLDB				; HOME OF LDB POINT~ER IN DDB

{Page 17}
	LDB T2,[POINT~ 9,T1,8]
	LDB T1,[POINT~ 9,T1,17]

{Page 19}
	MOVE T3,[POINT~ 7,HNMAM]	;MORE CHRS (O HASH

{Page 21}
	HRRI M,1(M)		;INCREMENT POINT~ER TO USER AREA.

{Page 22}
SYSDVF:	HRRM T1,M	;POINT~ M AT THE LOC SPECIFIED IN AC
	ADDI M,1	;POINT~ TO FIRST WORD FOR DDB ETC

{Page 24}
UPEEK1:	TRNN T1,-20		;CHECK IF ADDR POINT~S TO AN AC
	JRST UPEEK2		;AC POINT~ED TO, SO ADDR OK
;AND HAS ONLY ONE RETURN POINT~.
	CLRPTO	%UPS		;SETUP UPS SLOT IN MAP TO POINT~ TO BLOCK
POKCHK:	TRNN T1,-20	;CHECK IF ADDR POINT~S TO AN AC
	JRST CPOPJ1	;AC POINT~ED TO, SO ADDR GOOD

{Page 29}
	ILDB POINT~ER TO NULL-TERMINATED STRING
	XCTFU	<MOVE T2, 1(T1)>	;T2/ BYTE POINT~ER
	XCTTU	<MOVEM T2, 1(T3)>	;UPDATE BYTE POINT~ER
	MOVE	T3,[POINT~ 7,BTSTR]	;PREPARE BTSTR BYTE PTR
	HRLI	T1,(POINT~ 7,)	;PREPARE USER STRING BYTE PTR
	HRLI	T1,(POINT~ 7,)	;PREPARE USER STRING BYTE PTR

{Page 32}
	HRRI M,1(M)		;INCREMENT POINT~ER TO USER'S AREA.
	LDB T1,[POINT~ 12,DEVCHR(F),35]

{Page 34}
;TABLE OF POINT~ERS TO TABLES(STORED WITH JOB NUMBER AS INDEX)

{Page 38}
	LDB T2,[POINT~ 9,NUMTAB(T1),8]	;MAX LEGAL ARG.
GETTB2:	LDB T2,[POINT~ 4,NUMTAB(T1),12]	;GET ACTION TYPE

{Page 43}
	HRRZ T2,LNKHED	;GET POINT~ER TO LIST
	SKIPA T1,1(T2)	;EVEN, NAME POINT~ER
	HLRZ T1,1(T2)	;ODD, DATA POINT~ER

{Page 44}
	JRST XCHF6	;FN 6 TRU COMPONENT CHECKPOINT~ RECORD

{Page 47}
;P2/USER POINT~ER, AFTER AOBJN PTS AT DATA TO LOAD NEXT

{Page 48}
;XCHARG FUNCTION 6 -- TRU COMPONENT CHECKPOINT~

{Page 49}
	LDB	T3,[POINT~ 9,T2,8] ;Check for special case
	LDB	T3,[POINT~ 9,T2,17] ;Pick up SC2

{Page 50}
	LDB P3,[POINT~ 9,P2,8];  P3:=PROPOSED TYPE
	LDB T2,[POINT~ 6,P2,35];USER SIZE FIELD
	MOVE P2,T1	;P2 POINT~ TO USER DATA FROM NOW ON
;MOVE USER BLOCK TO ACTBUF. P2 POINT~S TO USER BLOCK

PATCH.MAC	
DEBUG.MAC	
{Page 4}
07600		MOVSI	T1,-NCTXPG##	;GET AOBJN POINT~ER FOR NUMBER OF CONTEXT PAGES
11900	CNVPAG:	LDB	T3,[POINT~ 8,PAGE,16]
12500	MAPBLK:	BLOCK	2		;POINT~ER, ADDRESS

EDDT.MAC	
DDT.MAC	
{Page 3}
	some point~, we'll want to change this somehow.
	JOBSYM is now updated to point~ to symbols loaded from a file.

{Page 4}
R=<A=2>		;POINT~ERS TO TABLES, CORE, ETC.
;PID IS 20 IF SYM TAB POINT~ER IS INDIRECT JOBSYM
PID==0		;=0 IF SYMBOL TABLE POINT~ER IS IN JOBSYM

{Page 5}
NBP==8	;NUMBER OF BREAKPOINT~S

{Page 13}
	MOVSI	T,(<POINT~ 7,0>)	;SET INPUT POINT~ER
	MOVE W,[POINT~ 6,CRASH]
	MOVE W,[POINT~ 6,CRASH+1]
	MOVE W,[POINT~ 6,UNM]

{Page 15}
	JUMPGE T,NOSYM		;NOT A SYMBOL TABLE POINT~ER
	HRRM W1,JOBSYM		;NOW POINT~ TO FILDDT SYMBOLS

{Page 16}
	MOVE T,[POINT~ 7,TXT]
	MOVE T,[POINT~ 6,TXT6]

{Page 20}
	TRNE T,-1	;NOT POINT~ TO BOTTOM OF REG SYM TAB
	SUB T,W	;SEE IF SYM TBL POINT~ AND PRGM
	JRST	[SKIPN R,1(R)	;YES, GET NEW POINT~ER

{Page 21}
	MOVEI W1,6		;FORM FLOATING POINT~ NUMBER

{Page 23}
	LDB T,[POINT~ 4,(R),3]
	LDB T,[POINT~ 4,(R),3]

{Page 25}
	DPB T,[POINT~ 2,(R),1]	;LEFT 2 BITS IN SYMBOL

{Page 26}
	ADD R,[XWD 2,2]	;AND POINT~ ABOVE IT

{Page 27}
	HRRZ R,R	;POINT~ TO TOP OF SYMBOL TABLE
	JRST	[SKIPN R,1(R)	;LINK, GET NEXT POINT~ER

{Page 28}
	LDB W1,[POINT~ 3,WRD,2]	;CHECK FOR IO INSTRUCTION

{Page 30}
	MOVE S,1(S)	;GET POINT~ER TO ARRAY INFO
	HRLI S,(POINT~ 18,)
	MOVEM S,ARAYLP	;SET UP BYTE POINT~ER FOR MULTS
ARAYDF:	HLRE T,ARSP	;GET POINT~ER TO FREE SPACE
	HRLI S,(POINT~ 18,0,35)	;SO WE WILL INDEX WORD NEXT TIME
	MOVEM T,1(S)	;POINT~ TO US

{Page 36}
SETBUF:	PUSHJ P,MAKBPT	;GET A POINT~ER TO THE BUFFER
	HRLI W1,(POINT~ 7,0)

{Page 37}
	SKIPA W1,[POINT~ 7,[ASCIZ /
	MOVE W1,[POINT~ 7,[ASCIZ /
	LDB T,[POINT~ 9,40,8]
	LDB R,[POINT~ 4,40,12]

{Page 39}
JOBHSM=400006	;HISEG SYMBOL TABLE POINT~ER
TEMPORARILY FOR DEBUGGING.  CHANGES MAY BE MADE AND BREAKPOINT~S
ON THE .HGH FILE FOR THE HISEG, AND BREAKPOINT~S WILL BE REMEMBERED
INTO CORE TO BE EXECUTED (SETTING BREAKPOINT~S DOES NOT CAUSE
MODIFICATION OF THE .HGH FILE).  BREAKPOINT~S MAY BE SAVED FOR
ANY HISEG AND BREAKPOINT~S IN ANY HISEG MAY BE SET ANY
BREAKPOINT~S MAY BE SET IN ANY HIGH SEGMENT (IF THE DESIRED SEGMENT
CARE OF SETTING UP THE PROPER BREAKPOINT~S WHEN A NEW HIGH SEGMENT
	(POINT~ED TO BY THE RH OF SEGTAB) WILL BE RESTORED FIRST
	TRNN R,400000	;CHECK ALL HISEG BREAKPOINT~S
	MOVE W2,[POINT~ 1,HIMAP]	;MAP BIT PTR

{Page 42}
	LDB	T,[POINT~ 5,R,14]	;GET STATE CODE
	LDB	T,[POINT~ 12,T,11
		    POINT~ 12,T,11+12
		    POINT~ 12,T,11+24](W1)

{Page 43}
SIXOUT:	MOVE	W1,[POINT~ 6,T]

{Page 45}
	CAIN	R,XEC1		;JUST HIT BREAKPOINT~ OR DID $X LAST?
	DPB	T,[POINT~ 23,I.NST,35]	;STORE COMPUTED ADR IN CURRENT INST
	LDB	W1,[POINT~ 4,I.NST,12]	;EXTRACT AC FIELD

{Page 48}
;INTERPRET FLOATING POINT~ INSTRUCTIONS

{Page 49}
	LDB	R,[POINT~ 4,T,17]	;LOAD INDEX FIELD

{Page 50}
	DPB	W1,[POINT~ 4,I.XCT,12]>	; USE IN XCT PAGED
	DPB	T,[POINT~ 5,I.NST,17]	;CLEAR I AND AC FIELD
	PUSHJ	P,FETCH		;FETCH PCWORD IT POINT~S TO

{Page 52}
	IBP	@I.NSTEA	;INCREMENT POINT~ER
	MOVEI	T,@I.NSTEA	;GET EFF ADDR OF POINT~ER

{Page 54}
;FIXED POINT~ MULTIPLY AND DIVIDE (NOT INCLUDING IMULX)

{Page 55}
	DPB	T,[POINT~ 4,I.XCT,12]	;SO NEXT INSTRUCTION HAPPENS OK
	TLNE	F,BPE		;C(E) A BYTE POINT~ER

{Page 58}
;   AC'S AND FLAGS ARE SWAPPED, BUT BREAKPOINT~S AND OTHER STUFF

{Page 60}
	ADDI W1,MAP+420-200	;POINT~ TO START OF EXEX MAP
	TLOA W1,(POINT~ 18,0,17)
	HRLI W1,(POINT~ 18,0,35)
	MOVEM T,ACXSPT	;STORE IN AC STACK POINT~ER

{Page 61}
	TLOA W1,(POINT~ 18,0,17)
	HRLI W1,(POINT~ 18,0,35)

{Page 62}
DDTCH1:	HRRE 3,(2)	;CHECK BREAKPOINT~S
	SETZM (2)	;BREAKPOINT~ IN OVERLAY, ZAP IT

{Page 63}
;BREAK POINT~ LOGIC
BP1:	REPEAT NBP,<	0		;JSR TO HERE FOR BREAKPOINT~
	0		;HOLDS INSTRUCTION WHILE BREAKPOINT~ IS IN PLACE
	0		;HISEG PTR FOR BREAKPOINT~ IN HISEG

{Page 64}
	LDB T,[POINT~ 9,LEAV,8]	;GET INSTRUCTION
	HRLI T,(POINT~ 7,0)

{Page 65}
	PUSHJ P,REMOVB		;REMOVE BREAKPOINT~S
	IDIVI A,4		;QUOTIENT IS BREAK POINT~ NUMBER
	HRRM A,BREAK2		;SAVE BREAK POINT~ #
	PUSHJ P,FP7		;PRINT BREAKPOINT~ NUMBER
BREAK2:	ROT S,.-.		;ROT BY # OF BREAK POINT~
PROCEDE: TLNE F,QF		;N$P	;PROCEED AT A BREAKPOINT~
PROC0:	HRRZI R,XEC1		;MODIFIED TO ADDR OF BREAKPOINT~

{Page 66}
	JRST BPLUP		;BREAKPOINT~ LOOPING OR FETCH FAILED
	LDB T,[POINT~ 9,LEAV,8]	;GET INSTRUCTION
	DPB T,[POINT~ 23,LEAV,35]	;STORE EFFECTIVE ADDRESS
IXCT53:	LDB W1,[POINT~ 4,LEAV,12]	;PICK UP AC FIELD
	LDB T,[POINT~ 9,LEAV,8]		;PICK UP INSTRUCTION FIELD
BPLUP:	PUSHJ P,REMOVB		;BREAKPOINT~ PROCEED ERROR

{Page 67}
	DPB W1,[POINT~ 4,T,12]	;STORE USERS POINT~ER AC 
	AOS LEAV		;MAKE LEAV POINT~ TO SUBROUTINE NOW.
;INSERT BREAKPOINT~S
;REMOVE BREAKPOINT~S

{Page 68}
	MOVE T,[XWD B1ADR,B1ADR+1]	;NO, COMMAND IS $B - CLEAR ALL BREAKPOINT~S
	BLT T,AUTOPI		;CLEAR OUT ALL BREAKPOINT~S AND AUTO PROCEDE REGESTER

{Page 71}
FLDUAC:	LDB T,[POINT~ 2,MAPWRD,2]	;GET USER AC BLOCK
	HLRZ TT,ACXSPT	;GET THE AC STACK POINT~ER

{Page 72}
FCHFIL:	MOVEM R,TEM4		;SAVE THE AOBJN POINT~ER
TEM4:	0			;HOLD AOBJN POINT~ER

{Page 75}
LOOK2:	HRR W1,R		;POINT~ER BEST VALUE SO FAR

{Page 76}
	LDB T,[POINT~ 4,(R),3]

{Page 78}
	JRST PAD0	;NOT SYMBOLIC OR NO POINT~ER

{Page 79}
	LDB R,[POINT~ 7,T,9]	;PICK OUT IO DEVICE BITS
	LDB R,[POINT~ 3,T,12]
	DPB R,[POINT~ 6,T,8]	;MOVE IO BITS OVER FOR OP DECODER
	LDB R,[POINT~ 6,T,8]	;SECOND 2 DIGITS.
KSIO1:	LDB R,[POINT~ 6,T,12]	;HERE ON POSSIBLE INTERNAL I/O INSTR.

{Page 81}
	LDB R,[POINT~ 4,T,17]	;GET IR FIELD

{Page 83}
SPT0:	HRRZM W1,SPSAV		;SAVE POINT~ER TO TYPED SYM
	LDB T,[POINT~ 32,(T),35]
SPT1W:	LDB T,[POINT~ 32,0(W1),35]	;GET SYMBOL

{Page 84}
	HRRZ R,SPSAV		;PICK UP POINT~ER TO LAST SYM
	DPB T,[POINT~ 2,(R),1]	;STORE SEMI-DELETE BITS IN SYMBOL

{Page 85}
;FLOATING POINT~ OUTPUT
	PUSHJ P,TOC6		;PRINT DECIMAL POINT~

{Page 87}
SPSAV:	0	;POINT~ER TO LAST SYMBOL TYPED
FRSTR:	0	;STARTING POINT~ OF SYMBOL SEARCHES

{Page 88}
STRING:	0	;STRING POINT~ER FOR INPUT
BMASK:	0	;BYTE POINT~ER MASK
FLGPTR:	0	;POINT~ER TO FLAG TABLES
ACPNTR:	0	;POINT~ER TO ACTABLE

{Page 90}
	HRL R,W			;SET UP AOBJN POINT~ER
	EXCH R,DEFV		;SAVE ADR FOR NEXT BLOCK, GET POINT~ER

{Page 95}
	JRST HLFW	;IF NO POINT~ER USE HALFWORD

{Page 96}
;PRINT BYTE POINT~ERS
	SKIPE WRD2	;T NOW HAS BYTE POINT~ER
	JRST PBYPT1	;PRINT AS BYTE POINT~ER
	MOVE W1,T	;SAVE BYTE POINT~ER PART
PBYPT1:	MOVEM T,LWT	;SAVE BYTE POINT~ER
	MOVE W1,[ASCII /POINT~/]
	LDB A,[POINT~ 6,LWT,11]	;SIZE FIELD
	LDB B,[POINT~ 6,LWT,5]	;GET POSITION

{Page 98}
	MOVSI T,70000	;DECREMENT BYTE POINT~ER
	ADDI	W2,0(T)		;POINT~ TO BEGINNING OF EPT CHUNK

{Page 101}
	REPEAT 4,<IBP CBUF+1>;adjust byte point~er

{Page 102}
BDISP:	POINT~ 12,DISP(R),11
	POINT~ 12,DISP(R),23
	POINT~ 12,DISP(R),35

{Page 104}
; 2.   A POINT~ (.) ASSEMBLES A STOP CODE.
; 4.   A STRING OF LETTERS TERMINATED BY A SPACE, COMMA, OR POINT~,

{Page 106}
;FWT,FIXED POINT~ ARITH,MISC.

{Page 109}
ACXSPT:	0		;FOR EXEC AC STACK POINT~ER
ACSPTR:	0		;POINT~ER TO SAVED ACS FOR ALT AC BLOCKS

{Page 111}
;FWT-FIXED POINT~ ARITH-MISC

{Page 112}
PNTR:	EXP INST	;POINT~ER TO BITS IN INST
CHP:	0		;CHAR POINT~ER INTO TXT, TXT+1
SAVPDL:	0		;SAVE PUSH DOWN LIST POINT~ER
BTAB:	POINT~ 9,TBL	;TABLE USED TO GET NEXT BYTE POINT~ER
	POINT~ 9,TBL,8	;FOR TRANSFER BYTE
	POINT~ 9,TBL,17
	POINT~ 9,TBL,26
	MOVEM T,CHP		;FOR OPEVAL,SETUP POINT~ER TO INPUT TEXT
	MOVE W2,BTAB(W2)	;CALCULATE POINT~ER TO NEXT BYTE

{Page 114}
DC7:	MOVE P,SAVPDL		;RESTORE PUSH DOWN POINT~ER
	LDB R,[POINT~ 3,T,8]
	DPB R,[POINT~ 10,T,12]	;ONLY DONE FOR IO INSTRUCTIONS
	LDB W1,[POINT~ 4,LWT,12]	;IT'S A TTCALL, GET AC
OPTCLI:	LDB W1,[POINT~ 5,LWT,17]

{Page 115}
	SIXBIT /VDSKPT/ ;-102 GET DISK POINT~ER FOR VP

ONCE.MAC	
{Page 4}
;AND THEN SET UP AN AREA OF THE MAP TO POINT~ TO THEM.
	MOVE	T3,TBLNEW-1(T1)	;T3/BYTE POINT~ER.

{Page 5}
	MOVE	T2,[POINT~ 18,EPT+EPTMP0]	;BUILD A POINT~ER
	MOVE	T2,[POINT~ 18,EPT+EPTMP0]
ONCBUG:	JRST	ONCGOP		;AND GO (GOOD PLACE FOR BREAKPOINT~)

{Page 7}
PAGTYP:	HRLI T1,(POINT~ 7,0)

{Page 8}
PATSYM:	JSR MOVSTP		;MOVE SYMBOL TABLE POINT~ER
	MOVEM T1,DDTSYM		;MOVE THE SYMBOL TABLE POINT~ER

{Page 9}
	DPB	T1,[POINT~ 3,T2,11] ;PUT INTO PREVIOUS AC FIELD
	MOVE	T1,[POINT~ 3,CSATAB]
	DPB	T2,[POINT~ 7,T3,33]
	DPB	T1,[POINT~ 3,T2,11] ;PUT INTO PREVIOUS AC FIELD
	LDB	T1,[POINT~ 9,T1,26] ;GET START PAGE NUMBER
	LDB	T2,[POINT~ 9,T2,26] ;GET END PAGE NUMBER

{Page 10}
;HERE IS THE TABLE OF MAP SLOT POINT~ERS FOR THE PCBS.
CNCLBT:	CONFIG,,CONFIG+1	;BLT POINT~ER TO CLEAR CONFIG AREA
CNFCPY:	CONFIG,,CPYFIG		;BLT POINT~ER TO COPY CONFIG NAME/DATE
CPYBPT:	POINT~ 7,CPYFIG		;BYTE POINT~ER TO COPY OF CONFIG AREA
CNFBPT:	POINT~ 7,CONFIG		;BYTE POINT~ER TO CONFIG NAME/DATE

{Page 12}
	DPB	T1,EPYPSN	;SET POINT~ER [EPTPTR(%UPS.N)]

{Page 13}
	LDB T1,[POINT~ 10,T1,9]

{Page 15}
A'HLP:	MOVE	P3,-2(P1)		; Setup AOBJN point~er for messages
	-SIZ'NAM,,TXT'NAM	;AOBJN POINT~ER TO HELP
	-SIZ'NAM,,SCN'NAM	;AOBJN POINT~ER TO NAMES

{Page 19}
	MOVE	T1,CNFCPY	;BLT POINT~ER TO COPY CONFIG NAME/DATE
	MOVE	T3,CPYBPT	;GET POINT~ER TO COPY AREA
	MOVE	T4,CNFBPT	;GET POINT~ER TO CONFIG AREA
GETSYN:	MOVE	T4,CNFBPT	;GET BYTE POINT~ER INTO CONFIG

{Page 20}
DEPENDING ON THE ENTRY POINT~ USED, EITHER (OPCBST)SETS UP OR
OPCBST ALSO SETS PCBTAB AND PGYXXX POINT~ERS.
	MOVEI	T1,OPCBTB	;SET UP POINT~ER TO LIST OF
	JRST	[HRLI T2,(POINT~ 18,0,17)
	HRLI	T2,(POINT~ 18,0,35) ;ODD, USE LEFT HAND SLOT
	TRO	PG,PGE.A!PGE.W!PGE.C ;MAKE INTO MAP SLOT POINT~ER

{Page 21}
	IBP	T2		;DECREMENT THE POINT~ER
	MOVEI	T3,PGE.A+PGE.C+PGE.W+340 ;MAP SLOT POINT~ER
EVASE1:	IDPB	T3,T2		;SET MAP SLOT POINT~ER

{Page 23}
	HRLI	T3,(POINT~ 18,0,35) ;ASSUME ODD
	HRLI	T3,(POINT~ 18,0,17) ;NO, EVEN

{Page 24}
        TABLE OF ADDRS AND POINT~S PCBTAB TO IT.  SETS UP LRU/MRU

{Page 28}
	MOVEM	T1,(T2)		; physical page - point~ to new page

{Page 37}
	MOVEM T1,ONCTIP	;INITIAL STORAGE POINT~ER

{Page 39}
	MOVE T3,LINEP		;INITIAL OUTPUT POINT~ER

{Page 40}
ONCTIP:	0			;TYPE-IN POINT~ER
ONCTOP:	0			;TYPE-OUT POINT~ER
LINEP:	POINT~ 7,LINBUF		;INPUT AND OUTPUT U BUFFER
LINEPI:	POINT~ 7,LINBFI

ONCDSK.MAC	
{Page 1}
;MACRO TO DEFINE ONCE RESTART SYMBOLS AND BYTE POINT~ERS
		  DCNY'DCD: POINT~ DCSIZ,DCN,35-DCSIZ*<DCNUM-1-DCXX>

{Page 3}
	MOVEI	P4,RIBPFS	;P4/ REL ADDR OF RETRIEVAL POINT~ERS.
	TLNN	T1,RBSPAR!RBINDX ;CHECK THAT THE POINT~ER IN T1
	TLNN	T1,RBREAL	;IS A CORRECT POINT~ER.

{Page 7}
A'HLP:	Move	P3,-2(P1)		; Setup AOBJN point~er for messages
	-SIZ'NAM,,TXT'NAM	;AOBJN POINT~ER TO HELP
	-SIZ'NAM,,SCN'NAM	;AOBJN POINT~ER TO NAMES

{Page 8}
;P1 IS A POINT~ER TO THE NAMES TABLE
	JRST	[MOVNI P3,3	;-3 WITH U POINT~ING TO UNIT BLOCK
CMDSC1:	MOVE	P2,-2(P1)	;GET AOBJN POINT~ER TO HELP TABLE
	MOVE	P3,-1(P1)	;GET AOBJN POINT~ER TO NAME TABLE
CMDSC4:	Aoj	P2,		; Increment text point~er
	Hrrz	P2,-2(P1)	; Get AOBJN Point~er for

{Page 12}
UIPHLP:	Move	P3,-2(P1)	; Setup AOBJN point~er for messages

{Page 14}
LNGMES:	HRLI T1,(POINT~ 7,0)

{Page 25}
	TLO	T1,RBREAL	;POINT~ER TO

{Page 32}
ENTRY POINT~ OPAGOT IS TO WRITE A PAGE, ENTRY POINT~ OPAGIN IS TO

{Page 38}
THE ENTRY POINT~ CHKBAT READS THE BAT PAGES AND IF ERRORS ARE

{Page 51}
	PUSH	P,P2		;SAVE THE STR POINT~ER.

{Page 53}
SETRAN:			; Entry point~ to start timer for random number

REFSTR.MAC	
{Page 1}
;ENTRY POINT~S.

{Page 3}
OUT OF RETRIEVAL POINT~ER SPACE IN NON-EXTENDED FILE.
OUT OF RETRIEVAL POINT~ER SPACE IN EXTENDED FILE.

{Page 4}
	MOVEM	T1,SATRBP	;RETREVIAL POINT~ER AREA+1.

{Page 6}
	MOVEI	T2,LPNSAT	;BUILD THE RETRIEVAL POINT~ER TO

{Page 11}
	HRLM	P2,T1		;POINT~ER

{Page 12}
	PUSHJ	P,HOMRBS	;EOF POINT~ER.

{Page 16}
	SETZM	STTAOB(T1)	;CLEAR AOBJN POINT~ER.

{Page 18}
SKIP RETURN IF GET PAGE, WITH THE RETRIEVAL POINT~ER TO THE
SKIP RETURN IF GET PAGE, WITH THE RETRIEVAL POINT~ER TO THE
	DPB	T1,RBYUNI	;RETRIEVAL POINT~ER.

{Page 20}
	MOVEM	T2,%TMP+RIBUSD	;FILES THIS UFD POINT~S TO.

{Page 21}
POINT~ER TO UFD IN CORE.
    ;CALC THE COMPRESSED FILE POINT~ER.
	LDB	T2,[POINT~ 9,FSTPRT(P3),^D26]
	ADD	T4,[XWD 5,5]	;BUMP POINT~ER
	MOVEM	T4,UFDSTP	;RESTORE POINT~ER

{Page 22}
	SKIPA	T2,STTPTR(P1)	;T2/ SAT'S DISK POINT~ER.
	SOJLE	P3,.+2		;DISK POINT~ERS

{Page 23}
RETURNS WITH T2/ DISK POINT~ER TO FIRST PAGE GOTTEN, T1/ NO. OF
SATSRH:	SKIPN	T1,STTAOB(P1)	;T1/ CURRENT AOBJN POINT~ER.
      ;BUILD THE DISK POINT~ER TO IT.
	MOVEM	T1,STTAOB(P1)	;SAVE THE AOBJN POINT~ER.
	POP	P,T2		;RESTORE T2/ DISK POINT~ER.

{Page 25}
VARIOUS SUBRS TO STORE A RETRIEVAL POINT~ER AND INC RIBALP.
EXPECTS T2/ RETRIEVAL POINT~ER TO STORE AND XXXRBP TO BE
AN AOBJN POINT~ER.
STOPCDS IF AOBJN POINT~ER RUNS OUT.
ELSE RETURNS WITH NEW AOBJN POINT~ER STORED AND RIBALC

{Page 27}
EXPECT T2/ DISK POINT~ER OF PAGE TO BE TRANSFERRED.

{Page 28}
SUBR TO STORE A RETRIEVAL POINT~ER IN %TMP ACCORDING TO
RETRIEVAL POINT~ER TO BE STORED, AND F/ DDB.
PTROUT:	POP	P,T2		;RESTORE THE RETRIEVAL POINT~ER.
	POP	P,T1		;RESTORE OUR POINT~ER.

{Page 29}
%TMP TO STORE POINT~ERS.
MORE ROOM, WITH T1/ AOBJN POINT~ER TO ROOM.
MOROOM:	ADDI	T1,%TMP+1	;GET ADDR OF NEXT POINT~ER.

KSIORG.MAC	
RMXKON.MAC	
{Page 5}
	MOVE T2,[POINT~ 18,UNISB(U)]
REGPTR:	POINT~ 6,RM03RG
	POINT~ 6,RP06RG

MAGSER.MAC	
{Page 1}
LOADPT==40000	;Tape at load point~
;These are the only entry point~s:

{Page 3}
	MOVE T2,TKBIUN(T3)	;AOBJN point~er to vector of adrs of UDBs

{Page 7}
point~ed at by DEVDIO.  Wakes jobs waiting for pages which
;Enter with T1 the contents of the IOWD point~ed at by T4.
;Leaves T4 point~ing to the next 0 word in the vector.
;Decrement lock count for page point~ed to by IOWD in T1.
	LDB PG,[POINT~ 13,T1,26] ;GET PHYSICAL PAGE NUMBER.

{Page 8}
SYDTMX:	AOJ M,			;POINT~ M TO THE UNIT NAME.
	MOVE T2,TMX0CB+TKBIUN	;Point~er to vector of UDB addresses

{Page 10}
An additional entry point~ is FT1CM2.
	LDB T1,[POINT~ 2,M,35]	;Yes.  Set up mode information.

{Page 14}
MAGPDP:	-30,,.			;Initial I-level push down point~er.
	MOVEI J,TMX0CB		;KDB.  Here we set up the record point~ers.
CHKSSC:	MOVE T1,TKBIUN(J)	;Point~er to vector of UDB adrs.
	LDB T3,[POINT~ 2,S,^D28]	;Density specification.
	MOVE T1,[POINT~ 18,TUBSB(U)]	;Save registers.

{Page 17}
	LDB T1,[POINT~ 2,S,^D28] ;Requested density.
	LDB T2,[POINT~ 2,DEVMD1(F),35]	;Get software tape format.

{Page 18}
In DEVCLS(F) is a point~er to a vector of "IOWDS" each of which is in the
	LDB M,[POINT~ 14,T4,13]	;Number of words to do on this page.
	  LDB M,[POINT~ 14,(T1),13]	;Yes, this many words to transfer.
	LDB T1,[POINT~ 9,@-1(P),35]	;1. Set BA register.
	LDB T4,[POINT~ 14,@-1(P),13]	;-Total words to transfer to this page.
SETXF1:	LDB T2,[POINT~ 21,@-2(P),35]	;PDP-10 page this -11 page goes to.
	LDB T4,[POINT~ 14,@-2(P),13]	;This many words this page.
	LDB T1,[POINT~ 2,DEVMD1(F),35]	;Software mode.

KSCOMM.MAC	
CTYSIM.MAC	
{Page 2}
	MOVE P,[-20,,RETCTP]		;AND SET PUSHDOWN POINT~ER
	MOVE	P,[-20,,RETCTP]	;AND SET PUSH DOWN POINT~ER
	DPB T1,[POINT~ 8,T2,23]	;PUT IN THE CHR

{Page 3}
CTYBRK:	POPJ P,			;A GOOD PLACE FOR A BREAKPOINT~
	JRST	[MOVE T1,[POINT~ 7,[ASCIZ /
    B   Break-point~

{Page 4}
	MOVE T4,ORP620		;GET OUTPUR RING POINT~ER
CTOLP:	ANDI T4,MSKORG		;THIS IS THE CONTINUE POINT~
	LDB T1,[POINT~ 8,ORING(T4),BYP1]	;GET TYPE
	LDB T2,[POINT~ 8,ORING(T4),BYP2]
	HRLI T1,(POINT~ 8,0,BYP2)
	MOVEM T1,CTOPNT	;SET UP THE POINT~ER
	SETZM CTOPNT	;CLEAR THE POINT~ER

{Page 5}
ZAPCIR:	LDB T1,[POINT~ 8,ORING(T4),BYP2]	;GET PORT
	MOVE T1,[POINT~ 7,[ASCIZ /

{Page 7}
	MOVE T1,[POINT~ 7,AXSTR]
	MOVEM T1,AXSTRP	;POINT~ER FOR STRING
SUPCHR:	LDB T1,[POINT~ 7,ORING(T4),BYP3]	;GET CHR
SUPFIN:	LDB T1,[POINT~ 7,CONFIG,13]
	LDB T2,[POINT~ 7,CONFIG,20]	;GET THIS SYSTEM NUMBER

{Page 8}
	DPB T3,[POINT~ 8,T2,15]
	LDB T3,[POINT~ 8,ORING(T4),BYP2]	;GET PORT OF REQUESTER
	DPB T3,[POINT~ 8,T2,23]	;AND PUT IN PORT REQUEST
	LDB T3,[POINT~ 8,ORING(T4),BYP2]
	DPB T3,[POINT~ 8,T2,15]
	DPB T1,[POINT~ 8,T2,15]	;NOW LOG IN NEW PORT
	DPB T1,[POINT~ 8,T2,15]
	MOVE T3,[POINT~ 7,AXSTR]
	DPB T3,[POINT~ 8,T2,23]
	DPB T3,[POINT~ 8,T2,31]

{Page 9}
SUPSYW:	LDB T1,[POINT~ 8,ORING(T4),BYP2]
	DPB T1,[POINT~ 8,T2,15]
	HRLI T1,(POINT~ 8,0,BYP2)
	LDB T1,[POINT~ 8,ORING(T4),BYP2]
	DPB T1,[POINT~ 8,T2,15]
	DPB T1,[POINT~ 8,T2,23]
	DPB T1,[POINT~ 8,T2,31]

{Page 10}
	LDB T1,[POINT~ 8,T2,15]
	DPB T1,[POINT~ 8,T2,15]
YELTRN:	LDB T1,[POINT~ 8,ORING(T4),BYP2]
ZAPTRN:	LDB T1,[POINT~ 8,ORING(T4),BYP2]
	DPB T3,[POINT~ 8,T2,15]
GOBTRN:	LDB T2,[POINT~ 8,ORING(T4),BYP2]

{Page 11}
	MOVE T1,[POINT~ 7,[ASCIZ /
CTOPNT:	0	;OUTPUT POINT~ER

DZKON.MAC	
{Page 1}
DCTDN:	POINT~ 3,DCTABL(T1),3
DCTLN:	POINT~ 3,DCTABL(T1),6
DCTSPE:	POINT~ 4,DCTABL(T1),10
DCTFIL:	POINT~ 4,DCTABL(T1),14
	LDB T2,[POINT~ 8,T2,15]
	DPB T1,[POINT~ 8,T2,15]	;Login on this port.
	DPB T1,[POINT~ 8,T2,23]
	LDB T3,[POINT~ 2,T1,30]
DZBRK:	 RET			;Traditional breakpoint~ location.
	DPB T1,[POINT~ 8,T2,15]
PROOR:	SKIPA T4,ORP620		;Output ring point~er.
	LDB T1,[POINT~ 8,ORING(T4),BYP1]	;Get type of this packet.
	LDB T2,[POINT~ 8,ORING(T4),BYP2]	;Data.
	HRLI T2,(<POINT~ 8,0,BYP2>)
	DPB T3,[POINT~ 8,T2,15]
	DPB T1,[POINT~ 8,T2,23]
	DPB T1,[POINT~ 8,T2,31]
	HRLI T4,(<POINT~ 8,0,BYP2>)

{Page 3}
P.IBMO:	LDB T2,[POINT~ 8,ORING(T4),BYP2]	;Destination port number
P.NBIP:	LDB T2,[POINT~ 8,ORING(T4),BYP2]	;Destination port number

{Page 4}
	MOVE T1,[POINT~ 7,AXSTR]
P.SLC:	LDB T1,[POINT~ 7,ORING(T4),BYP3]	;Supervisor login character.
P.SLC3:	LDB T1,[POINT~ 7,CONFIG,13]
	LDB T2,[POINT~ 7,CONFIG,20]	;Find Host's system number
	DPB T1,[POINT~ 8,T3,15]
	LDB T2,[POINT~ 8,ORING(T4),BYP2]	;Get port of requester.
	DPB T2,[POINT~ 8,T3,23]	;And put in port request.
	LDB T3,[POINT~ 8,ORING(T4),BYP2]
	DPB T3,[POINT~ 8,T2,15]
	DPB T1,[POINT~ 8,T2,15]	;Now log in new port.
	DPB T1,[POINT~ 8,T2,15]
	MOVE T3,[POINT~ 7,AXSTR]
	DPB T3,[POINT~ 8,T2,23]
	DPB T3,[POINT~ 8,T2,31]

{Page 5}
SUPSYW:	LDB T1,[POINT~ 8,ORING(T4),BYP2]
	DPB T1,[POINT~ 8,T2,15]
SOAOR:	LDB T2,[POINT~ 8,ORING(T4),BYP2]	;Send over aux circuit or ignore
	DPB T2,[POINT~ 8,ORING(T4),BYP2]
P.YELL:	LDB T2,[POINT~ 8,ORING(T4),BYP2]
P.CZ:	LDB T2,[POINT~ 8,ORING(T4),BYP2]	;Circuit zapper.
	DPB T1,[POINT~ 8,T2,15]
	LDB T2,[POINT~ 8,ORING(T4),BYP2]
P.CG:	LDB T2,[POINT~ 8,ORING(T4),BYP2]	;Character gobbler.

{Page 6}
CTOPNT:	0	;OUTPUT POINT~ER
LINTOR:	LOOP(LINORS-1+ORBSIZ,<001100,,>)	;Point~er to first byte above this
;Line characteristics table and byte point~ers.
;Byte point~ers are set up assuming the port number will be in T2.
LCIS:	POINT~ 3,LINCHR(T2),11
LCOS:	POINT~ 3,LINCHR(T2),14
	OS.OP==2	;Outputting from a block output type point~er.
	OS.LGI==5	;Outputting from a block output type point~er,
LCTYP:	POINT~ 2,LINCHR(T2),16
	;point~er to line type:  0, CTY; 1, DZ-11; 2, Aux circuit; 3, Unused.
LCFIL:	POINT~ 4,LINCHR(T2),20
LCAUX:	POINT~ 6,LINCHR(T2),26
LCSPE:	POINT~ 4,LINCHR(T2),30

DR11C.MAC	
{Page 1}
BLXPNT:	0		;BUFFER WORD FOR BLOCK MODE OUTPUT POINT~ER
BLKPNT:	0		;BLOCK MODE OUTPUT BYTE POINT~ER
IRPD:	MOVEM	T2,IRP620	;UPDATE INPUT PUTTER POINT~ER TO MAKE THIS
	LDB	T2,[POINT~ 7,T1,27];YES-GET BYTE COUNT
IRDA:	MOVE	U,T2		;BUMP RING PUTTER POINT~ER
	DPB	T1,[POINT~ 16,IRING(T2),15];NO-STORE PDP-11 WORD IN RING
IRDB:	DPB	T1,[POINT~ 16,IRING(T2),31];STORE PDP-11 WORD IN RING
	ADDI	T2,1		;BUMP POINT~ER
	MOVE	T2,IRP620	;YES-GET POINT~ER
	DPB	T1,[POINT~ 16,IRING(T2),15];NO-STORE FIRST PDP-11 WORD
IR1B:	DPB	T1,[POINT~ 16,IRING(T2),31];STORE 2ND WORD
	ADDI	T2,1		;BUMP POINT~ER
	MOVEM	T2,IRP620	;UPDATE POINT~ER IN MEMORY (THIS MAKES THE
IR2OE:	LDB	T2,[POINT~ 6,T1,27];IS THIS AN ESCAPE?
	MOVE	T2,IRP620	;NO-ITS A 2 WORD MESSAGE-GET POINT~ER
	DPB	T1,[POINT~ 16,IRING(T2),15];NO-STORE DATA IN RING
IR2B:	DPB	T1,[POINT~ 16,IRING(T2),31];STORE IT IN THE RING TOO
	ADDI	T2,1		;BUMP RING POINT~ER
	HRLI	P2,442000	;MAKE INTO BYTE POINT~ER TO THE DATA
	MOVE	M,P2		;GET BYTE POINT~ER IN A SAFE AC (??)
	MOVEM	P2,BLXPNT	;STORE BYTE POINT~ER FOR BLOCK MODE OUTPUT
;HERE WHEN THE BASE-HOST RING IS FULL.  SAVE THE DATA AND POINT~ER AWAY AND
IRFUL:	DMOVEM	T1,IROVF	;STORE DATA AND POINT~ER
	MOVE	T3,ORP620	;NO-GET OUTPUT TAKER POINT~ER
	LDB	T4,[POINT~ 16,ORING(T3),15];NO-GET DATA FROM THE RING
ODLH1:	LDB	T4,[POINT~ 16,ORING(T3),31];GET 2ND 16 BIT BYTE IN THE WORD
	AOJ	T3,		;BUMP RING POINT~ER
	MOVEM	T3,ORP620	;UPDATE RING POINT~ER IN MEMORY
	MOVE	T4,BLXPNT	;AND THE POINT~ER
	MOVE	T4,BLXPNT	;AND THE POINT~ER
	MOVE	T3,ORP620	;GET RING POINT~ER
	LDB	T4,[POINT~ 16,ORING(T3),15];GET DATA FROM RING
	MOVE	T2,IROVF+1	;GET SAVED RING POINT~ER
	DMOVE	T1,IROVF	;GET NEXT PDP-11 WORD FOR RING AND RING POINT~ER
	DPB	T1,[POINT~ 16,IRING(T2),15];STORE IT IN THE RING
	IBP	DBOPNT		;BUMP POINT~ER
	MOVE	T1,[POINT~ 18,DBORNG];INITIALIZE DEBUG OUTPUT RING POINT~ER

KMCSER.MAC	
{Page 2}
;  IRP620 - 620 point~er to input ring,unchanged
;Now set up the point~ers to the rings in KMC address format
   	aoj t3,			;point~ to iring size word
	movei t3,irp620+1	;address of point~er to oring
	aoj t3,			;point~ to oring size word

KMCDDT.MAC	
{Page 1}
	MOVE	ADR,[3,,760540]	;POINT~ TO THE KMC
	MOVE	C,[POINT~ 18,SVCRAM];GET BYTE POINT~ER FOR SAVE AREA
	MOVE	C,[POINT~ 18,SVCRAM];POINT~ TO SAVED DATA
OUTSTR:	HRLI	A,(POINT~ 7,0)	;MAKE INTO A BYTE POINT~ER
OUTWRD:	LDB	C,[POINT~ 1,A,20];GET FIRST DIGIT
	LDB	C,[POINT~ 3,A,23];GET 2ND DIGIT
	LDB	C,[POINT~ 3,A,26];GET 3RD DIGIT
	LDB	C,[POINT~ 3,A,29];GET 4TH DIGIT
OUTBYT:	LDB	C,[POINT~ 2,A,29];GET FIRST DIGIT
	LDB	C,[POINT~ 3,A,32];GET 2ND DIGIT
	LDB	C,[POINT~ 3,A,35];GET 3RD DIGIT

BPXKON.MAC	
{Page 4}
00300	;AT THIS POINT~ J POINT~S TO THE KONTROLER DATA BLOCK
00800		LDB P3,[POINT~ 4,T1,23]	;GET UNIT FIELD
01600		MOVE T1,UNICOM(U)	;GET POINT~ER TO CONTROL BLOCK
01700		LDB T2,[POINT~ 8,(T1),15]	;AND GET FIRST COMMAND

{Page 5}
02000		DPB T3,[POINT~ 8,T2,7]	;SET IT UP
02200		ADD T3,P3	;SET TO POINT~ TO LIST

{Page 8}
00400		LDB P3,[POINT~ 24,UNISND+5(U),23]	;GET SYNDROM BYTES
00700		LDB P1,[POINT~ 16,UNISND+4(U),15]
00800		LDB P2,[POINT~ 8,UNISND+3(U),31]
00900		DPB P2,[POINT~ 8,P1,19]	;HERE ISS THE RESTART DISP
01000		LDB P2,[POINT~ 16,UNISND+4(U),31]	;HERE IS THE ERROR DISP
01950	GORCV:	HRRZ T1,CHNSTB(PG)	;GET POINT~ER TO COMMAND CHAIN
02000		SOS P2,1(T1)	;POINT~S TO FIRST DATA WORD OF RECORD
02050		SKIPL (P2)	;POINT~ER ALWAYS POINT~S 1 AFTER 1ST DATA WD
02100		AOJA P2,.-1	;GET IT TO POINT~ TO LAST
02300	LOKRCV:	LDB T1,[POINT~ 11,(P2),11]	;GET COUNT
03500	FNDRCV:	LDB T2,[POINT~ 24,(P2),35]
03800		LDB T1,[POINT~ 13,T2,26]	;PAGE NUMBER

{Page 9}
00800		HRRZ T2,UNICOM(U)	;POINT~ER TO COMMAND LIST
02500	DTATRN:	LDB T4,[POINT~ 11,(T2),11]	;GET COUNT FIELD
03400	LSTCNT:	LDB T1,[POINT~ 11,T1,11]	;PARTIAL TRANS, GET REMAINING COUNT

{Page 10}
01800		DPB T1,[POINT~ 8,(P3),23]	;RECORD 1
02100		LDB T1,[POINT~ 16,T1,15]	;NOW GET JUST THE HEAD
03200		HRL P3,BPBRK1	;NOT IMMEDIATE IN CASE CHANGED FOR BREAKPOINT~S

{Page 12}
00500	READ OR WRITE. UNICOM(U) POINT~S TO THE COMMAND LIST AREA.
02700	P1 LEFT HALF POINT~S TO THE SEARCH (#1)
02800	P1 RIGHT HALF POINT~S TO THE FIRS FREE COMMAND LOCATION (#2+1)
03400	P3 RIGHT HALF CONTAINS A POINT~ER TO THE NEXT PLACE TO PUT A

{Page 13}
00600		DPB T3,[POINT~ 8,T2,23]
02200		HRLS P1		;SAVE POINT~ER TO THE SEARCH ID
02400		ADDI P1,2	;POINT~ AFTER WHERE TRANSFER WILL GO
03800	PLANTING BREAKPOINT~S IS NOW A PROBLEM. CHANGE BPBRK1 TO

{Page 14}
01200		DPB T3,[POINT~ 32,(P3),31]	;SET CYL AND 2 BYTES OF 0
02200		DPB T3,[POINT~ 16,1(P3),15]	;SET HEAD NUMBER
02300		DPB T4,[POINT~ 8,1(P3),23]	;AND RECORD NUMBER
02400		SUBI P3,2	;ADJUST DATA POINT~ER
02800	;T2.  P3 POINT~S TO THE SEEK ARG

{Page 17}
00300		LDB T3,[POINT~ 8,(T2),23]	;GET UNIT NUMBER
00400		DPB T3,[POINT~ 8,T2,7]	;STORE IN COMMAND
02200		HRRM P3,1(P1)	;UPDATE SEARCH POINT~ER

{Page 19}
00300		LDB P2,[POINT~ 8,3(P3),23]	;GET LAST RECORD NUMBER
02900		MOVE P2,P4	;NOW HAVE RESET END OF LIST POINT~ERS

{Page 20}
01100		HRLM P1,UNISWC(U)	;SAVE END OF UNIT POINT~ER
04400	BPXLTM:	PUSHJ P,BPXSET	;SET UP COMMAND POINT~ERS

{Page 21}
00400		LDB T3,[POINT~ 4,(T2),11]	;GET THE CONTROL CODE
00700		HRRZ T2,KONCHN(J)	;GET A POINT~ER TO CHANNEL
02400		LDB T2,[POINT~ 7,CHNGO(T3),9]	;GET DEVICE
02600		DPB T2,[POINT~ 7,T1,9]
03900		MOVEM T1,-1(T4)	;RESET LIST BASE POINT~ER TO BLOCK MULTIPLEXER MODE
05000	DOIT:	MOVE T4,CHNSTB(T3)	;POINT~ER TO BASE ADR
05100		DPB T2,[POINT~ 8,(T1),23]	;SET DEVICE

{Page 22}
03600		DPB T1,[POINT~ 8,(T2),23]
03800		DPB T1,[POINT~ 8,(T2),23]	;AND IN SEEK
04000		DPB T1,[POINT~ 8,(T2),23]	;AND IN SEARCH ID =
04200		DPB T1,[POINT~ 8,(T2),23]	;AND IN WRITE
04800		DPB T3,[POINT~ 8,(T2),23]	;AND PUT UNIT NUMBER IN SENSE CMD

{Page 23}
03900	CPYBPT:	POINT~ 6,CPYDAT(T3),5	;BLOCKS/TRACK
04000	CPYBPY:	POINT~ 10,CPYDAT(T3),15	;BLOCKS/CYLINDER
04100	CPYBPU:	POINT~ 20,CPYDAT(T3),35	;BLOCKS/UNIT

CDRSER.MAC	
{Page 2}
01210		LDB T4,[POINT~ 6,CDRPTR,11]; GET BYTE SIZE
01240		SUBI	T2,1		;ADJUST ADDRESS FOR BYTE  POINT~ER

{Page 4}
01300	DISRET:	IBP	CDRPTR	;ADVANCE POINT~ER
01621		HRRM	T2,CDRPTR	;AND POINT~ER ADDRESS
01635		LDB T4,[POINT~ 6,CDRPTR,11]

FTASER.MAC	
{Page 6}
00100	;BYTE POINT~ERS FOR SENSE DATA.
00350	BYUUN7:	POINT~ 1,UNICMD+3(T3),^D11    ;UNIT HAS 7 TRACK CAPABILITY.
00400	BYULDP: POINT~ 1,UNICMD+3(T3),^D12    ;LOAD POINT~.
00500	BYUTAB: POINT~ 2,UNICMD+3(T3),^D10    ;TU A AND B.
00600	BYUWPT: POINT~ 1,UNICMD+3(T3),^D14    ;FILE PROTECTED.
00700	BYUTIN: POINT~ 1,UNICMD+4(T3),2       ;TAPE INDICATE.
00900	BYUDUL:	POINT~ 1,UNICMD+4(T3),^D18    ;UNIT IS DUAL DENSITY.
01000	BYUMDL:	POINT~ 1,UNICMD+4(T3),^D20    ;UNIT MODEL NUMBER.
01100	BYUK62:	POINT~ 1,UNICMD+5(T3),^D12    ;KONT CAN 6250.
01200	BYUK79:	POINT~ 2,UNICMD+6(T3),9       ;KONT NRZI CAPABILITY.
01500	BYKNOI: POINT~ 1,FTXSTS(J),8	     ;NOISE BIT.
01600	BYKLDP:	POINT~ 1,FTXSTS(J),^D12       ;LOAD POINT~.
01700	BYKNTC:	POINT~ 1,FTXSTS(J),^D15       ;NOT CAPABLE.
01800	BYKIDB:	POINT~ 1,FTXSTS+1(J),^D11     ;ID BURST CHECK.
01850	BYK160: POINT~ 1,FTXSTS+1(J),^D19     ;MODE OF TAPE UNIT,
01887	BYKMDL: POINT~ 4,FTXSTS+1(J),^D23     ;UNIT MODEL NO.

{Page 11}
05100		DPB	T4,[POINT~ 8,(T1),7] ;DEV LIST.

{Page 12}
00100	FIGO:	MOVEI	T4,UNICMD(T3)	;POINT~ THE DEV LIST
00400		DPB	T4,[POINT~ 4,(T1),^D11] ;LIST.

{Page 17}
02300		LDB	T1,[POINT~ 3,DEVADD(F),^D23] ;T1=UNIT NO.
02500		LDB	T1,[POINT~ 4,(T2),^D11] ;T1=CODE.
05100		LDB	T1,[POINT~ 4,(T2),^D11] ;IF THE DEVICE LIST ENTRY
05900		DPB	T1,[POINT~ 4,(T2),^D11] ;DEV LIST ENTRY.
07000	@@ENTRY EXPECTS F=DDB AND T1=FNP.  ADDITIONAL ENTRY POINT~ IS

{Page 18}
00500	DEVDIO POINT~S AND THE END OF THE LIST.
03800	WORDS BETWEEN WHERE DEVDIO POINT~S AND THE NEXT ZERO.  LEAVES
03900	DEVDIO POINT~ING AT THE WORD AFTER THE ZERO WORD.
07300		LDB	PG,[POINT~ 13,T1,26] ;GET PHYSICAL PAGE NUMBER.

{Page 19}
00300	SYDFTA:	ADDI	M,1		;POINT~ M TO THE UNIT NAME.
00625		MOVE	U,DEVUDB+FTA0DB	;POINT~ TO UNIT BLOCK

{Page 20}
00900				BIT 3 -- LOAD POINT~

{Page 21}
03200		DPB	T2,[POINT~ 2,T1,2] ;AND STORE THEM.
03700		JUMPE	T2,.+2		;LOAD POINT~?

{Page 22}
00900	AN ADDITIONAL ENTRY POINT~ IS FT1CM2.

{Page 26}
01900		LDB	P3,[POINT~ 3,DEVADD(F),^D23] ;GET UNIT NO.
02600		DPB	T2,[POINT~ 8,(T1),7] ;

{Page 28}
01100	;		   DID NOT HIT THE LOAD POINT~ WHILE TC).

{Page 29}
00500		LDB	P3,[POINT~ 3,T1,^D23] ;P3=UNIT NO.

{Page 30}
10500	FXWN23:	LDB	M,[POINT~ ^D11,(T1),^D11] ;FIND
11200		LDB	T2,[POINT~ ^D24,(T1),^D35] ;ADJUST
11500		DPB	T4,[POINT~ ^D11,T2,^D11] ;DATA

{Page 35}
03900		LDB	T1,[POINT~ 1,FTXSMY(J),0] ;OLD STATUS
04000		DPB	T1,[POINT~ 1,CHNSTB(PG),0] ;AND
05900		MOVEI	T1,-1(T1)	;POINT~ T1 TO LAST DATA WORD TO
08200	FXUCG1:	DPB	P3,[POINT~ 3,FTXSNS(J),^D23] ;SET UP A SENSE.
08300		MOVEI	T1,FTXSNS(J)	;POINT~ THE
08800		DPB	T1,[POINT~ 4,(T2),^D11] ;CODE INTO IT.
08900		LDB	T1,[POINT~ 8,DEVADD(F),^D23] ;PUT THE DEVICE ADDR
09000		DPB	T1,[POINT~ 8,(T2),7] ;INTO IT.
11500		HRRZI	M,UNICMD(T3)	;POINT~ THE DEV LIST
11800		DPB	M,[POINT~ 4,(T4),^D11] ;IN THE DEVICE LIST ENTRY.
15700	SSTALL:	HRLZ	T1,FTXSMY(J)	;GET BUSY BITS. (ENTRY POINT~)
16400	SSTONE:	HLRZ	T4,KONBMX(J)	;GET BMX ADDR. (ENTRY POINT~).
16700		DPB	M,[POINT~ 4,(T4),^D11] ;CODE.

{Page 36}
00100	    ;HERE ON AN ERROR OR HITTING LOAD POINT~ OR INTERV. REQ.
05300		LDB	T2,BYKLDP	;NO.  LOAD POINT~?
05600	    ;HERE ON LOAD POINT~.
10620		ADDI	T1,1		;YES, PRETEND U POINT~ED TO

{Page 38}
02200		PUSHJ	P,SGDEV1	;POINT~ DEVER1 TO

{Page 39}
16000		DPB	T2,[POINT~ 8,T1,^D15] ;IN

{Page 40}
00500	@@PURPOSE SUBR WHICH POINT~S THE DEV LIST
01400	SUBSTI:	HLRZ	T2,KONBMX(J)	;GET POINT~ER TO
01600		HRRM	T1,(T2)		;POINT~ IT.
01800		DPB	T1,[POINT~ 4,(T2),^D11] ;START CODE.
03100	SUBTRM:	HLRZ	T4,KONBMX(J)	;GET POINT~ER TO
03400		DPB	T1,[POINT~ 4,(T4),^D11] ;STORE IT.
04000	POINT~S THE DEV LIST ENTRY TO UNICMD AND DPBS START INTO IT.
04208	ENTRY POINT~ SUBRST CLEARS IOBOT; ENTRY POINT~ SUBRS0 DOES NOT.
05800		LDB	P3,[POINT~ 3,DEVADD(F),^D23]
06200		HRRM	T1,(T2)		;POINT~ THE DEV LIST.
06400		DPB	T1,[POINT~ 4,(T2),^D11] ;CODE.
07908	ENTRY POINT~ SUBRGO SETS UP AND GOES; ENTRY POINT~ SUBRG2 DOES THE
07910	SAME, EXCEPT IT DOES NOT CLEAR IOBOT; ENTRY POINT~ SUBRG1 JUST

{Page 43}
01700		LDB	T1,[POINT~ 2,S,^D28] ;GET DENSITY ASKED.

{Page 44}
09700	SCMDR3:	LDB	T4,[POINT~ ^D14,M,^D13] ;GET THE
10900		DPB	T4,[POINT~ ^D14,M,^D13] ;UP
13100		LDB	T4,[POINT~ ^D14,M,^D13] ;SET

{Page 45}
05800		DPB	PG,[POINT~ ^D11,(T2),^D11]
07104	@@EXIT ON EXIT T1 POINT~S TO THE 0 DDB WORD AND T2 POINT~S TO THE NEXT
07400	STODS1:	LDB	T4,[POINT~ ^D14,M,^D13] ;GET THE
07702	STOD15:	TLZ	M,MSKMMD	;POINT~ TO CORRECT
10400	SDTCL1:	LDB	T4,[POINT~ ^D14,(T1),^D13] ;GET THE COUNT

{Page 46}
00400	(T1 MUST POINT~ TO A LOCATION > 1ST CMD).
01400		AOJ	T2,.+1		;POINT~ TO 1ST DATA WORD.

{Page 47}
00200	COUNTS BETWEEN THE DATA WORD POINT~ED TO BY (T1) AND THE PREVIOUS
00300	READ CMD INCLUSIVE.  ON EXIT, T1 POINT~S TO THE PREVIOUS READ
00354	(T1 MUST POINT~ TO A LOC > 1ST CMD.).
01500		LDB	T2,[POINT~ ^D11,(M),^D11] ;GET A COUNT.
02700	COUNTS BETWEEN THE DATA WORD POINT~ED TO BY (T1) AND THE
03002	(T1 MUST POINT~ TO A LOC > 1ST CMD.).
04500	WORD POINT~ED TO BY T1 AND THE PREVIOUS READ CMD, INCLUSIVELY,

{Page 48}
03200	@@PURPOSE SUBR, WITH VARIOUS ENTRY POINT~S, WHICH GENERATES
03800	@@ENTRY EXPECTS T4 AS A POINT~ER, T3=UNIT DB, P3=UNIT NUMBER, AND F=DDB.
03850	SCMGN5 IS THE ADDITIONAL ENTRY POINT~.
08100		MOVEI	M,UNIERO+1(T3)	;M IS POINT~ER TO ERROR SPACE.
08602	SCMG36:	AOJA	T1,SCMGN3	;POINT~ TO NEXT REQUEST.

{Page 49}
00200	POINT~ DURING TAPE CLEANING.
03500		MOVEI	T1,UNIERO(T3)	;POINT~ THE

{Page 50}
01500	SREVR2:	LDB	M,[POINT~ ^D11,(T1),^D11] ;DATA
01600		LDB	T2,[POINT~ ^D24,(T1),^D35] ;WORDS
02800		DPB	M,[POINT~ ^D11,T2,^D11] ;CREATE NEW DW.

{Page 51}
01600		LDB	T2,[POINT~ ^D12,1(U),^D11] ;GET COUNT.
03300		LDB	T1,[POINT~ ^D11,-1(T1),^D11] ;THE
04200	SLTGR:	SOJ	T1,.+1		;POINT~ T1 TO THE LAST DATA WORD.

{Page 52}
00551	SNEW4 IS AN ADDITIONAL ENTRY POINT~.
06500		MOVEI	T1,UNIERO(T3)	;SET UP DEV LIST TO POINT~ TO THE

{Page 53}
04100		LDB	T1,[POINT~ ^D12,1(U),^D11] ;OR

PLTSER.MAC	
{Page 2}
02600		PUSHJ P,PLTSET	;SETUP BYTE POINT~ER AND COUNTER

{Page 3}
01400	PLT1:	JSR PLTSAV		;SAVE AC'S, SET UP PUSH DOWN POINT~ER
01900		PUSHJ P,PLTSET	;SETUP BYTE POINT~ER AND COUNTER

{Page 4}
00200	;THIS SUBROUTINE CALCULATES A BYTE POINT~ER AND A BYTE COUNTER FOR
00875		SUBI	T1,1		;ADJUST FOR POINT~ER
00900		ADD T1,[POINT~ 6,0,35]	;CONVERT TO 6 BIT BYTE POINT~ER WITH
01200		TLO T1,(POINT~ 7,0,35)	;YES, CONVERT TO 7 BIT BYTE POINT~ER
01300		MOVEM T1,PLTPTR	;SAVE BYTE POINT~ER

PTPSER.MAC	
{Page 5}
03100		HRR	T1,DEVCLS(F)	;BUFFER POINT~ER
03110		SUBI	T1,1		;ADJUST FOR POINT~ER
03115		MOVEM	T1,PTPPTR	;SET UP BYTE POINT~ER

{Page 8}
00500	PTP1:	HRRZ	T1,DEVCLS(F)	;BUFFER POINT~ER
01050		IBP	PTPPTR		;ADVANCE POINT~ER MANUALLY
01450		HRRM	T3,PTPPTR	;ALSO IN POINT~ER

{Page 9}
04500		HRLM	P1,-2(T1)	;STORE NEW POINT~ER
05700		HRRZ	P1,DEVCLS(F)	;GET BUFFER POINT~ER

{Page 10}
00400	PTPADV:	HRRZ	T1,DEVCLS(F)	;BUFFER POINT~ER

PTRSER.MAC	
{Page 2}
01840	PTRTMB:	0			;BYTE POINT~ER TO MONITOR BUFFER

{Page 4}
01100		PUSHJ	P,SETBYT		;SET UP DEV. TO MB. POINT~ER
01400		MOVEM	T1,PTRTMB	;STORE POINT~ER IN DDB

{Page 6}
01600		IBP	PTRTMB		;ADVANCE POINT~ER MANUALLY
01700	STOM3:	HRRZ	T1,PTRTMB	;CHECK POINT~ER
02500		HRRM	T1,PTRTMB	;ALSO IN BYTE POINT~ER
03000	PTRSTE:	LDB	P1,[POINT~ 6,PTRTMB,5]; GET POSITION
03100		LDB	P2,[POINT~ 6,PTRTMB,11]; AND BYTE SIZE
03800		IBP	PTRTMB		;ADVANCE POINT~ER

RMTSER.MAC	
{Page 1}
04300	EXTERN RMTDDP	;INDEXED BY PORT, RH POINT~S TO DDB FOR THIS PORT, LH AS DEFINED BELOW

{Page 2}
04300	EXTERN QFRMST,QFRMND,QTOST,QTOND  ;START & END POINT~S OF THE 2 BUFFERS TO & FROM 620
04400	QTO:	QTOST		;POINT~ER TO DEPOSIT SOMETHING IN THE TO BUFER
04500	QFRM:	QFRMST		;POINT~ER TO REMOVE SOMETHING FROM THE FROM BUFFER
04800	QPP:	-1		;POINT~ER TO PUT PORT ON Q
04900	QPJ:	-1		;POINT~ER TO PUT JOB ON Q

{Page 3}
02400	STSDEV:	POINT~ 4,DEVSTS(F),35		;RIGHT MOST 4 BITS IN DEVSTS, USED BY CKRC12

{Page 4}
01400	MSGTYP:	POINT~ 4,T1,3
01500	PRTFLD:	POINT~ 3,T1,7
01800	ADRFLD:	POINT~ 22,T1,31

{Page 8}
00200	THAT THIS MESSAGE IS NOT LEGAL AT THIS POINT~ AND THE 620 SHOULD

{Page 14}
01600	DEVNAM AT THIS POINT~ WILL BE 0, RELZAP CAN USE THIS AS A FLAG

{Page 19}
02200		MOVE	T1,[XWD	QFRMST,QFRMST+1]	;ZERO ALL Q'S AND INITIALIZE Q POINT~ERS
04900		CAIN T1,(F)		;IS RMTDDP STILL POINT~ED HERE

{Page 23}
00700		HRLI	T1,(POINT~ 7,0)	;T1 POINT~S TO USER-SUPPLIED PASSWORD
00900		HRLI	T2,(POINT~ 8,0)	;T2 POINT~S TO MONITOR BUFFER

{Page 25}
02000	;HERE TO SET UP U AND F GIVEN F A POINT~ER TO A DDB
02300		MOVE F,RMTDDP(U)	;F STILL POINT~S TO DDB

{Page 28}
00800		LDB T1,[POINT~ 5,U,5]	;GET DESIRED PORT NUMBER

{Page 29}
00300		HRRZ	T3,RMTBUF(F)	;BYTE POINT~ER IN T3
00400		HRLI	T3,(POINT~ 8,0)
03900		HRLI	T1,(POINT~ 8,0)

{Page 30}
00600		LDB T2,[POINT~ 6,U,5]

{Page 33}
03300	ZAPRM1:	SKIPGE DEVIOS(F)	;AT THIS POINT~, F AND U, SET

{Page 35}
03000		HRLI T1,(POINT~ 7,0)
03200		HRLI T3,(POINT~ 8,0)

{Page 39}
02000		JUMPE T2,CKRMS1	;NO POINT~ IN UPDATE IF 0 SEC.
03100		MOVEM	T2,QFRM		;ADJUST Q POINT~ER

{Page 42}
00900		LDB U,[POINT~ 4,T1,7]	;GET PORT NUMBER (1 BIT LARGER)
02300		LDB J,PJOBN	;GET JOB NUMBER FROM DDB (POINT~ER IN F)

{Page 43}
02600		MOVEI T1,QTOST	;YES, RESET POINT~ER TO START

{Page 45}
01100		DPB T1,[POINT~ 32,DEVSTS(F),31]

{Page 46}
03400		SOS QPJ		;DEC POINT~ER TO SATISFIED REQS

{Page 47}
00300	RCVIDL:	LDB T2,[POINT~ 4,T1,15]	;GET MSG

{Page 50}
02200	SIK3:	AOS T1,QPJ	;INCREMENT THE SATISFY POINT~ER
02300		CAMLE T1,QPP	;STILL POINT~ING TO A REQUEST?
04300	SIKCOP:	PUSH P,RMTBUF(F)	;SAVE THE BUFFER POINT~ER

{Page 51}
01800		POP	P,RMTBUF(F)	;RMTBUF POINT~S TO BUFFER

1) "point"	2411   o@ 