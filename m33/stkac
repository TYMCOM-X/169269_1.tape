IFCPU (KI),<
;KI10 EXEC MODE TRAP

UUOKTR:	MOVEM 17,@%UPT+UPTACP	;STACK AC'S IN UPT
	JSP 17,STKAC
	PUSH P,%UPT+UPTMUP	;SAVE RETURN ADDRESS
	JRST @%UPT+UPTMUU	;DISPATCH ON ADDRESS FROM UUO

STKAC:	EXCH 17,%UPT+UPTACP
	HLLM 17,%UPT+UPTACP
	HRRZS 17
	CAIN 17,%UPT+UPTAC0+20*XACSTL
	STOPCD
	SUBI 17,17
	MOVEM 16,16(17)
	MOVE 16,17
	BLT 16,15(17)
	ADDI 17,37
	CAIN 17,%UPT+UPTAC0+20*XACSTL+17
	MOVEI 17,%UPT+UPTAC0+20*XACSTL
	HLRZ T1,%UPT+UPTACP
	ADDI T1,20000
	RDEBR	T2
	TRZ T2,760000
	IOR T2,T1
	WREBR	(T2)
	HRL 17,T1
	EXCH 17,%UPT+UPTACP
	JRST (17)

KTRRT1:	POP P,%UPT+UPTMUP	;RESTORE RETURN ADR
KTRRET:	MOVSI T1,PC.TRP	;RETURN FROM EXEC TRAP
	ANDCAM T1,%UPT+UPTMUP
	HRRZ 17,%UPT+UPTACP
	CAIN 17,%UPT+UPTAC0+20*XACSTL
	MOVEI 17,%UPT+UPTAC0+20*XACSTL+17
	SUBI 17,20
	HRRM 17,%UPT+UPTACP
	SUBI 17,17
	MOVSS 17
	HLRZ 16,%UPT+UPTACP
	SUBI 16,20000
	HRLM 16,%UPT+UPTACP
	RDEBR	T2
	TRZ T2,760000
	IOR T2,16
	WREBR	(T2)
	BLT 17,17
	JRSTF @%UPT+UPTMUP
>;END IFCPU KI

PGFUIO:	XWD	PC.UIO,PGFAIL	;ADDRESS POINTER USED IN ONCE

PGFAIL::MOVEM	16,@%UPT+UPTACP ;SAVE SOMEONE'S AC 16
	MOVE	16,%UPT+UPTOPP	;GET PAGE FAIL PC
	TLNN	16,PC.USR	;FROM USER?
	JRST	PGFAI1		;NO, EXEC. GO STACK ACS.
IFN BADTRP,<;THIS CODE TO GET AROUND KL TRAP INSTRUCTION BUG
	TLNE	16,PC.TRP	;ANY TRAP FLAGS ON
	JRST	PGFPCT		;YES, GO DO SPECIAL CHECK
>;END IFN BADTRP
	MOVE	16,@%UPT+UPTACP	;GET AC 16 BACK FOR USER
	EXECAC			;FIRST LEVEL OF EXEC ACS
	MOVE	P,[IOWD EPLLEN,%UPT+UPTPDL]
	PUSH	P,%UPT+UPTOPP
	JRST	@%UPT+UPTPGT	;DISPATCH TO PROPER FAULT HANDLING ROUTINE FOR USER.

PGFAI1:	JSP	16,STKAC	;STACK REST OF THE ACS
	PUSH	P,%UPT+UPTOPP	;STACK THE PC
	JRSTF	@[EXCMPE]	;CLEAR USER IOT AND GO DO EXEC FAULT.

IFN BADTRP,<

;THE FOLLOWING CODE IS AN ATTEMPT TO COMPENSATE FOR A KL10 HARDWARE
; BUG. THE BUG: IF A TRAP INSTRUCTION (ARITH OVERFLOW, PDL OVERFLOW, TRAP 3)
; CAUSES THE PC TO CHANGE, AND FETCHING THE NEW PC CAUSES A PAGE FAULT,
; THE RELEVANT TRAP FLAGS IN THE LH OF PC ARE STILL SET EVEN THOUGH
; THE TRAP CYCLE HAS COMPLETED. (FETCHING THE FIRST WORD OF THE
; TRAP ROUTINE IS NOT PART OF THE ACTUAL TRAP INSTRUCTION).
; THIS WILL CAUSE A SECOND TRAP, AS IF ONE HAD OCCURRED AT THE
; LOCATION IMMEDIATELY BEFORE THE START OF THE TRAP ROUTINE.
; THE TEMPORARY FIX IS TO SEE IF VIRTUAL ADDRESS AND PC MATCH
; WHEN WE GET A PAGE FAIL OLD PC WITH ANY TRAP FLAGS ON,
; AND TURN THE TRAP FLAGS OFF IF THIS IS TRUE. THE ONLY CASE WHERE
; THIS FAILS IS IF THE TRAP INSTRUCTION CANNOT COMPLETE BECAUSE
; OF A PAGE FAULT FOR THE WORD IMMEDIATELY FOLLOWING THE INSTRUCTION
; THAT CAUSED THE TRAP. THIS CIRCUMSTANCE IS CONSIDERED INFREQUENT
; ENOUGH TO JUSTIFY INSTALLING THIS FIX.

PGFPCT:	MOVE	16,@%UPT+UPTACP	;RESTORE USER'S AC 16
	EXECAC			;SWITCH TO EXEC ACS
	MOVE	P,[IOWD EPLLEN,%UPT+UPTPDL]
	MOVE	T1,%UPT+UPTOPP	;GET OLD PAGE FAIL PC
	PUSH	P,T1		;SAVE ON STACK LIKE REGULAR
	XOR	T1,%UPT+UPTPFW	;1S IN RH WHERE PC AND VA ARE DIFFERENT
	TRNE	T1,-1		;SKIP IF NO DIFFERENCES IN PC AND VA
	JRST	@%UPT+UPTPGT	;LEGIT PAGE FAIL DURING TRAP INSTRUCTION
	MOVSI	T1,PC.TRP	;MOST LIKELY THIS IS THE BUG. CLEAR TRAP
	ANDCAM	T1,(P)		;FLAGS IN PC WORD ON STACK
	ANDCAM	T1,%UPT+UPTOPP	;AND IN OPP (IN CASE SOMEONE LOOKS THERE)
	JRST	@%UPT+UPTPGT	;AND DISPATCH TO PROPER ROUTINE.
>;END IFN BADTRP

;STILL IN FTKL10
SUBTTL KL10 AC STACK ROUTINES

COMMENT !

THE FOLLOWING IS A STATE TABLE SHOWING WHERE AC DATA LIVES.

CURRENT		PREVIOUS	STACK [CONTEXT SWITCH]
-------		--------	----------------------
USRACB		USRACB		-EMPTY-
EX0ACB(1)	USRACB		-EMPTY-
EX1ACB(1)	EX0ACB(1)	-EMPTY- [EX0ACB(1)]
EX0ACB(2)	EX1ACB(1)	EX0ACB(1) [EX1ACB(1)]
EX1ACB(2)	EX0ACB(2)	EX0ACB(1) EX1ACB(1) [EX0ACB(2)]
EX0ACB(3)	EX1ACB(2)	EX0ACB(1) EX1ACB(1) EX0ACB(2) [EX1ACB(2)]

NOTES:
IF CODE HAS PC.UIO OFF AND WISHES TO TURN IT ON IN ORDER
TO REFERENCE USER SPACE, CONTEXT SWITCHING CODE AND AC STACK
CODE WILL SET PREVIOUS AC BLOCK IN HARDWARE (WRUBR	)
TO USRACB, EVEN THOUGH UPTACP INDICATES THE ORIGINAL
PREVIOUS AC BLOCK.

AT CONTEXT SWITCH TIME, THE CURRENT EXEC ACS ARE SAVED
IN UPTXAC IF THE PC IS IN EXEC MODE.

WHEN SETTING USER IOT IN THE PC WORD, IT IS NOT NECESSARY
TO DO A WRUBR  TO SET PREVIOUS AC BLOCK TO USER ACS
UNLESS NECESSARY - HOWEVER, IF PAGE FAULT OR RESCHEDULE
OCCURS PREVIOUS AC BLOCK WILL BE SET TO USER. THEREFORE,
CODE THAT SETS USER IOT IN PC SHOULD ALWAYS RESTORE
STATE OF PREVIOUS AC BLOCK WITH "WRUBR	%UPT+UPTACP"
IN THE PLACE WHERE IT RESTORES THE ORIGINAL SETTING
OF USER IOT.

WHILE THE USER IS RUNNING, BOTH CURRENT AND PREVIOUS
AC BLOCKS ARE SET TO USRACB, BUT UPTACP CONTAINS
EX0ACB AS CURRENT AC BLOCK, USRACB AS PREVIOUS AC BLOCK.

!
COMMENT ;

@@SUBROUTINE STKAC
@@PURPOSE PROVIDE A STACK OF PREVIOUS CONTEXT ACS IN ORDER
TO ALLOW NESTING OF PAGE FAULTS AND UUOS
@@ENTRY
	MOVEM	16,@%UPT+UPTACP
	JSP	16,STKAC
	<ONLY RETURN>
LH OF UPTACP MUST BE SETUP TO REFLECT STATE OF CURRENT
AC STACK.
@@ACCUM PRESERVES DATA IN ALL ACS IN THE BLOCK SET AS CURRENT
AT TIME OF CALL. ON RETURN, CONTENTS OF ALL ACS
EXCEPT FOR P ARE UNSPECIFIED.
@@EXIT AC P SET TO VALUE OF AC P IN ORIGINAL CURRENT BLOCK.
@@RESTRICTIONS ADDRESSES IN AC STACK MUST BE LESS THAN 400000,
SO WRUBR	%UPT+UPTACP DOES NOT SET 400000 (INHIBIT ACCT METER STORE)
AC STACK MUST START ON 16 WORD BOUNDARY, SO TRNE 17 CAN BE
USED FOR OVERFLOW CHECK.
;
IFN USRACB,<PRINTX USER AC BLOCK MUST BE BLOCK 0>
IFN EX0ACB-1,<PRINTX EX0ACB MUST BE SET TO 1>
IFN EX1ACB-2,<PRINTX EX0ACB MUST BE SET TO 2>
COMMENT ; THIS IS SO TLNE AC,(LG.PAC) IS QUICK CHECK FOR PREVIOUS
BLOCK SET TO USER, AND A TLC CAN BE USED TO QUICKLY SWAP
EX0ACB AND EX1ACB.
@@FUNCTION
IF PREVIOUS AC BLOCK SET TO USER, SET CURRENT AC BLOCK
TO EX1, PREVIOUS TO EX0, COPY AC P FROM EX0 TO ACP IN EX1,
AND RETURN.
IF PREVIOUS AC BLOCK SET TO AN EXEC BLOCK (EVEN IF USER IOT
IS ON AND HARDWARE PREVIOUS BLOCK IS REALLY SET TO USRACB)
SWAP PREVIOUS AND CURRENT AC BLOCKS, SAVE "NEW" CURRENT
(OLD PREVIOUS) ON AC STACK (CRASH IF OVERFLOW),
SETUP P FROM PREVIOUS ACS, AND RETURN.
@@;

STKAC:	EXCH	16,%UPT+UPTACP	;SAVE PC, GET AC POINTER
	TLNE	16,(LG.PAC)	;PREVIOUS ACS USER?
	JRST	STKAC1		;NO, GO STACK PREVIOUS ACS
	HRLI	16,(LG.LAB+<EX1ACB>B8+<EX0ACB>B11)
	EXCH	16,%UPT+UPTACP	;EX0 NOW PREVIOUS
	EXCH	16,@%UPT+UPTACP	;GET AC 16 BACK, SAVE PC IN AC STACK
	WRUBR	%UPT+UPTACP	;NEW AC BLOCK ASSIGNMENTS NOW.
	XCTFU	<MOVE P,P>	;GET COPY OF P TO USE
	MOVE	16,@%UPT+UPTACP	;GET PC IN AC 16
	JRST	(16)		;AND RETURN.

;HERE IF PREVIOUS AC BLOCKS SET TO AN EXEC BLOCK - NEED TO STACK IT

STKAC1:	TLC	16,(3B8+3B11)	;2_1 AND 1_2
	EXCH	16,%UPT+UPTACP	;SAVE POINTER, GET PC
	EXCH	16,@%UPT+UPTACP	;GET AC 16 BACK, SAVE PC IN STACK.
	WRUBR	%UPT+UPTACP	;NEW AC BLOCKS NOW.
	EXCH	16,@%UPT+UPTACP	;SAVE OLD PREVIOUS AC 16 IN STACK,GET PC
	EXCH	16,%UPT+UPTACP	;GET AC POINTER, SAVE PC
	MOVEM	17,1(16)	;SAVE 17 IN AC STACK (16 THERE TOO)
	MOVEI	17,-16(16)	;0,,WORD 0 OF STACK
	TRNE	17,17		;OVERFLOW?
	STOPCD			;YES, CRASH
	BLT	17,-1(16)	;SAVE 0-15 IN STACK
	ADDI	16,20		;ADVANCE STACK POINTER
	HRRZ	17,16		;COMPARE ONLY RIGHT HALF
	CAIN	17,%UPT+UPTAC0+20*XACSTL+16	;MORE ROOM??
	  HRRI	16,%UPT+UPTAC0+20*XACSTL	;NO - CRASH NEXT TIME
	EXCH	16,%UPT+UPTACP	;SAVE NEW POINTER, GET PC
	XCTFU	<MOVE P,P>	;GET COPY OF P FROM PREVIOUS ACS
	JRST	(16)		;AND RETURN.
;HERE TO UNSTACK ACS AFTER PAGE FAIL OR UUO WHICH HAS NESTED.
; ENTER AT KTRRT1 IF PC IS ON STACK, KTRRET IF PC IS IN
; UPTMUP.

KTRRT1:	POP	P,%UPT+UPTMUP	;GET PC INTO MUP
KTRRET:	MOVSI	T1,PC.TRP	;CLEAR THESE SO HE WON'T TRAP AGAIN.
	ANDCAM	T1,%UPT+UPTMUP
	HRRZ	17,%UPT+UPTACP	;GET STACK POINTER ADDRESS
	CAIE	17,%UPT+UPTAC0+16 ;ANYTHING STACKED?
	JRST	KTRRT2		;YES, MUST RESTORE IT.
	HRLI	17,(LG.LAB+<EX0ACB>B8+<USRACB>B11)
	MOVEM	17,%UPT+UPTACP	;NO, SET TO TOP LEVEL STATE AGAIN
	WRUBR	17		;AND
	JRSTF	@%UPT+UPTMUP	;RETURN.

;HERE TO UNSTACK SOME EXEC ACS

KTRRT2:	CAIN	17,%UPT+UPTAC0+20*XACSTL ;FULL AT THE MOMENT?
	MOVEI	17,%UPT+UPTAC0+20*XACSTL+16 ;YES, RESET POINTER TO REAL PLACE
	SUBI	17,20		;POP A LEVEL OF ACS OFF
	HLL	17,%UPT+UPTACP	;GET AC BLOCK INFO
	TLC	17,(3B8+3B11)	;1_2 AND 2_1
	MOVEM	17,%UPT+UPTACP	;SET NEW POINTER
	MOVE	16,%UPT+UPTMUP	;DID HE HAVE USER IOT SET?
	TLNE	16,PC.UIO
	JRST	KTRRT3		;YES, DO THIS DIFFERENTLY.
	MOVSI	17,-16(17)	;1ST LOC,,0
	BLT	17,17		;RESTORE "PREVIOUS" AC DATA
	WRUBR	%UPT+UPTACP	;NOW MAKE THAT BLOCK PREVIOUS
	JRSTF	@%UPT+UPTMUP	;AND RETURN.

;HERE IF USER IOT WAS SET AT TIME OF PAGE FAULT OR UUO AND
; UPTACP SAID PREVIOUS AC BLOCK WAS NOT USER. PROGRAM
; TURNED ON USER IOT TO REFER TO USER SPACE, SO RESTORE
; THE SAVED PREVIOUS EXEC ACS AND THEN INSTEAD OF
; MAKING THEM PREVIOUS AC BLOCK, MAKE USER AC BLOCK PREVIOUS
; SO THAT ALL EXECUTIVE XCTS REFER TO USER'S DATA.

KTRRT3:	MOVSI	17,-16(17)	;1ST STACK LOC,,0
	BLT	17,17		;RESTORE "REAL" PREVIOUS AC DATA
				;AC 16 STILL IN AC STACK.
	HLLZ	16,%UPT+UPTACP	;GET AC BLOCK INFO
	TLZ	16,(LG.PAC)	;USE SPECIFIED CURRENT BLOCK, BUT PREVIOUS BLOCK = USER.
	EXCH	16,@%UPT+UPTACP	;RESTORE 16, PUT WRUBR  WORD IN AC STACK
	WRUBR	@%UPT+UPTACP ;SET NEW AC BLOCKS 
	JRSTF	@%UPT+UPTMUP	;ANDRN.
>;END IFNCPU KI
   @@}