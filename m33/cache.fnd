
FHXKON.MAC	
IFADF.MAC	
FTBOOT.MAC	
TMPUUO.MAC	
CNFNRB.MAC	
CNFN30.MAC	
CNFN28.MAC	
MAPIO.MAC	
CONFPC.MAC	
CNFN55.MAC	
CORE1.MAC	
CONF36.MAC	
LOGINN.MAC	
SCNSER.MAC	
{Page 94}
...
	HRRZ	T3, LDBBIO(U)	;T3/ INPUT BUFFER ADDR
IFCPU (KL),<
	MOVE	T1, BIOCSH(T3)	;T1/ SWEEP NUMBER
	CAME	T1, CSUCNT	;UNLOAD ALREADY DONE?
	JRST	[
		AOS CSHSAV	;PAT OURSELVES ON THE BACK
		JRST GOBIN1
	]
	CSHUNL			;UNLOAD THE CACHE
	CAMN	T1, CSUCNT
	JRST	.-1		;WAIT 'TIL IT'S DONE
GOBIN1:>;END IFCPU (KL)
IFKMC	<CSHIVL>		;INVALIDATE 2020 CACHE
	MOVSI	P3, TYPI TYPBIN	;P3/ MESSAGE TYPE
	PUSHJ	P, GOBIO2	;OUTPUT THE MESSAGE
	  JRST	FINLIN		;(NO ROOM FOR MORE)
	JRST	MORLIN		;(ROOM FOR MORE)
...
	HLRZ	T3, LDBBIO(U)	;T3/ OUTPUT BUFFER ADDR
IFCPU (KL),<
	MOVE	T1, BIOCSH(T3)	;T1/ SWEEP NUMBER
	CAME	T1, CSVCNT	;IF A SWEEP'S ALREADY BEEN DONE,
	JRST	[
		AOS CSHSAV	;PAT OURSELVES ON THE BACK
		JRST GOBOT1
	]
	CSHVAL			;START VALIDATE
	CAMN	T1, CSVCNT
	JRST	.-1		;AND WAIT 'TIL IT'S DONE
GOBOT1:>;END IFCPU (KL)
	MOVSI	T1, LDLNOP
	IORM	T1, LDBDCH(U)	;PREVENT FUTURE OUTPUT UNTIL
				;BLOCK OUTPUT IS COMPLETE
	MOVSI	P3, TYPI TYPBKO	;P3/ MESSAGE TYPE
	PUSHJ	P, GOBIO2	;OUTPUT THE MESSAGE

CLOCK1.MAC	
ONCE.MAC	
MONMK1.MAC	
FTALOD.MAC	
BEG.MAC	
VALID.MAC	
RMTSER.MAC	
FRMDDT.MAC	
SETETC.MAC	
KSIORG.MAC	
CKS118.MAC	
PATCH.MAC	
CNFN56.MAC	
CNFN38.MAC	
CNFN29.MAC	
CNFNF3.MAC	
CNFNUN.MAC	
FTF310.MAC	
REFSTR.MAC	
CONFPD.MAC	
DDT.MAC	
FILFND.MAC	
FRMSER.MAC	
CONF30.MAC	
CONF37.MAC	
CONFRB.MAC	
SA10D.MAC	
PTPSER.MAC	
KSPCOP.MAC	
KSFEFS.MAC	
BTXN.MAC	
NOKMC.MAC	
KISYM.MAC	
JOBDAT.MAC	
CNFNTW.MAC	
CNFN39.MAC	
F3FUDG.MAC	
DZKON.MAC	
CPTYMC.MAC	
ERRMSG.MAC	*Null
CONF92.MAC	
CONF29.MAC	
CONF22.MAC	
CONFUN.MAC	
COMMON.MAC	
CONF56.MAC	
CONFMA.MAC	
DFCKON.MAC	
UPDATE.MAC	
KOSTM.MAC	
END.MAC	
PROJEC.MAC	
SXFUDG.MAC	
IFOID.MAC	
CDRSER.MAC	
KSTLOD.MAC	
KSCOMM.MAC	
MONMAK.MAC	
BOOTS.MAC	
EDDT.MAC	
CNFN24.MAC	
F3SYM.MAC	
{Page 18}
00100	SUBTTL CACHE SWEEP CONTROL MACROS
00200	
00300	;MACRO TO START CACHE UNLOAD
00400	
00500	DEFINE CSHUNL<
00600		PUSHJ	P,CSUNL##>
00700	
00800	;MACRO TO START CACHE VALIDATE
00900	
01000	DEFINE CSHVAL <PUSHJ P,CSVAL##>
01100	
01200	;MACRO TO MAKE SURE EDGES OF USER'S BUFFER DID NOT GET INTO
01300	; CACHE DURING INPUT TRANSFER BY USER OR OTHER ENTITY
01400	; REFERENCING ADJACENT WORD TO BUFFER. RESTRICTION - BUFFER
01500	; CANNOT BE IN MONITOR PAGES 0-337, OR ELSE ONE OF THE
01600	; FOUR REFERENCES MAY BE TO THE BUFFER ITSELF.
01700	; T1 HAS ADDRESS OF WORD TO THROW OUT OF CACHE.
01800	

APXKON.MAC	
COMTXT.MAC	
RMXKON.MAC	
SIMKL.MAC	
CONF57.MAC	
CONF39.MAC	
CONFTW.MAC	
CONFG3.MAC	
BOTLOD.MAC	
TDDT.MAC	
PTRSER.MAC	
BPXKON.MAC	
{Page 21}
...
04900	
05000	DOIT:	MOVE T4,CHNSTB(T3)	;POINTER TO BASE ADR
05100		DPB T2,[POINT 8,(T1),23]	;SET DEVICE
05200		TLO T1,(1B1)
05300		EXCH T1,-1(T4)	;SET CMD
05400		SETZM (T4)
05500		PUSH P,T1
05510	IFCPU (KL),<;IF KL, MUST SWEEP CACHE TO GET COMMAND TO MEMORY.
05520		CSHUNL			;START SWEEP, GET OLD NUMBER IN T1
05530		CAMN T1,CSUCNT		;WAIT UNTIL NUMBER INCREMENTS
05540		JRST	.-1		;BEFORE SETTING GO FLAG IN CHANNEL.
05550	>;END IFCPU (KL)
05600		MOVE T1,CHNGO(T3)
05700		TRZ T1,7
05800		XCT T1
05900		MOVEI T1,^D50000
06000		SKIPN (T4)

MAGWRT.MAC	
FAKJDA.MAC	
CKS024.MAC	
MONED.MAC	
DADD.MAC	
SIMIO.MAC	
CNFN59.MAC	
CNFN34.MAC	
SWAMP.MAC	
GFD.MAC	
IOCSS.MAC	
{Page 46}
...
; (THIS ROUTINE USED TO BE COMMON TO DISK & TAPE DEFORE
;  VM SYSTEM. ENTRY WAS DTIDR2: TDZA P4,P4 ; FOR TAPE
;   DTIDK2: MOVEI P4,200  ;FOR DSK.

;


DTIDR2:
IFCPU (KL),<CSHUNL			;DO SWEEP, RETURNS OLD NUMBER IN T1.
	CAMN T1,CSUCNT		;WAIT TILL ITS DONE
	JRST	.-1>
	MOVEI P4,0		;MAG TAPE CANNOT SPLIT RECORDS
	PUSHJ	P,DTIDR1	;MAKE SURE ALL ADVANCED
	JFCL
	HRRZ	T3,DEVIAD(F)	;NEXT BUFFER
	XCTBU <SKIPGE T1,(T3)>	;BUFFER FULL?
	POPJ	P,		;YES. NO LIST TO SET UP

{Page 48}
...
;DTODK2: MOVEI P4,200 ;DSK CAN SPLIT RECORDS

;  CALLED TO BUILD COMMAND LIST IN LIST AREA.

IFCPU (KL),<EXTERNAL CSVCNT,CSUCNT,CSHSAV>

;
DTODR2:
IFCPU (KL),<CSHVAL		;START A VALIDATE
	CAMN T1,CSVCNT
	JRST	.-1>
	MOVEI P4,0	;TAPE CANT SPLIT RECORDS
	PUSHJ	P,DTODR1	;MAKE SURE BUFFERS HAVE BEEN ADVANCED
	JFCL
	HRRZ	T3,DEVOAD(F)	;NEXT BUFFER
	XCTBU <SKIPL T1,(T3)>	;BUFFER FULL?
	POPJ	P,		;NO. NO LIST TO SET UP

{Page 49}
...
 GET THE DEVICE GOING,WAIT. QUIT ON END OF USER LIST OR ERROR
NOTE: THIS WAS ONCE COMMON DSK/TAPE CODE BEFORE VM SYSTEM
EXPECTS: M/ USER ADDR OF IOWDS
	F/ DDB		S/DEVIOS
!

DTIDR3:
IFCPU (KL),<
	CSHUNL		;START AN UNLOAD
	CAMN	T1,CSUCNT
	JRST	.-1>		;WAIT TILL ITS DONE.
	LDB P4,[POINT 4,DEVIOS(F),35]	;GET MODE (FOR TAPE)
	CAIE P4,DR
	TDZA P4,P4	;IF NOT DUMP RECORD, CAN NOT SPLIT
	MOVEI P4,200	;MTA DUMP RECORD CAN SPLIT
DTID36:	MOVSI S,IOBEG
	IORB S,DEVIOS(F)	;SET IOBEG IN CASE DUMP RECORDS

UUOCON.MAC	
CONF24.MAC	
TRUTST.MAC	
MTASER.MAC	
SFUDGE.MAC	
SPAWN.MAC	
PLTSER.MAC	
FOO1.MAC	
SEFUDG.MAC	
KMCDDT.MAC	
SYMSRC.MAC	
CKS059.MAC	
FTASER.MAC	
KLSYM.MAC	
{Page 18}
00100	SUBTTL CACHE SWEEP CONTROL MACROS
00200	
00300	;MACRO TO START CACHE UNLOAD
00400	
00500	DEFINE CSHUNL<
00600		PUSHJ	P,CSUNL##>
00700	
00800	;MACRO TO START CACHE VALIDATE
00900	
01000	DEFINE CSHVAL <PUSHJ P,CSVAL##>
01100	
01200	;MACRO TO MAKE SURE EDGES OF USER'S BUFFER DID NOT GET INTO
01300	; CACHE DURING INPUT TRANSFER BY USER OR OTHER ENTITY
01400	; REFERENCING ADJACENT WORD TO BUFFER. RESTRICTION - BUFFER
01500	; CANNOT BE IN MONITOR PAGES 0-337, OR ELSE ONE OF THE
01600	; FOUR REFERENCES MAY BE TO THE BUFFER ITSELF.
01700	; T1 HAS ADDRESS OF WORD TO THROW OUT OF CACHE.
01800	

FILDDT.MAC	
MONCOP.MAC	
CNFNFZ.MAC	
CNFN35.MAC	
F3TSER.MAC	
PCBIO.MAC	
LOGOUT.MAC	
CONF34.MAC	
CNFNPB.MAC	
INITIA.MAC	
BIOBAS.MAC	
{Page 1}
...
patprg:	0
patcnt:	0
patprt:	0
patbfs:	0
patfre:	0
patbuf:	Exp	0,1,2,3,4

patunl:	push	p,t1		; Save T1 across cache sweep
	CSHUNL			; UNLOAD
	camn	t1,csucnt	; Wait for unload to finish
	jrst	.-1
	CSHUNL			; UNLOAD
	camn	t1,csucnt	; Wait for unload to finish
	jrst	.-1
	pop	p,t1		; Restore register
	popj	p,

patcpy:	push	p,t1		; Save a working register
	hrli	t1,biochr(t1)	; Get addr of buffer
	hrri	t1,patbuf	;  addr of 5-wd patch buffer

S.MAC	
CONF25.MAC	
CONFPA.MAC	
CONF59.MAC	
620CHK.MAC	
DPXKON.MAC	
TSTFAK.MAC	
KSBLOD.MAC	
DISK.MAC	
PD3330.MAC	
INITST.MAC	
DEBUG.MAC	
T.MAC	
CNFN90.MAC	
CNFN54.MAC	
CNFN36.MAC	
COMFAK.MAC	
CONFPB.MAC	
CONFFZ.MAC	
CNFN79.MAC	
COMCON.MAC	
COMMOD.MAC	
CNFN27.MAC	
FILUUO.MAC	
CONFCA.MAC	
SETETW.MAC	
FAKFAK.MAC	
CNFN37.MAC	
CIOPR.MAC	
LALL.MAC	
FTKI10.MAC	
CONFMF.MAC	
CONF90.MAC	
CONF88.MAC	
CONF72.MAC	
CONF27.MAC	
CNFNPD.MAC	
CONF54.MAC	
CONF79.MAC	
CNFN23.MAC	
SCHED1.MAC	
ACTSER.MAC	
CNFNG3.MAC	
COMCO.MAC	
ENDSYM.MAC	
ERRCON.MAC	
CONF38.MAC	
CNFN57.MAC	
CONFF3.MAC	
CNFN32.MAC	
CONFFO.MAC	
CONF83.MAC	
FAKDDT.MAC	
CRSUPD.MAC	
CLUBS.MAC	
FTKL10.MAC	
FTKS10.MAC	
CONF32.MAC	
CONF23.MAC	
CNFN33.MAC	
PICON.MAC	
{Page 7}
...
	AOS	CSUCNT		;WAS AN UNLOAD, COUNT ONE MORE
	MOVE	T1,SAVT1	;GET T1 BACK
	JEN	@APRCHL		;DISMISS.

;ROUTINES FOR CACHE SWEEPING.

COMMENT #
THE PROCEDURE TO DO A CACHE SWEEP IS AS FOLLOWS: CALL THE APPROPRIATE
ROUTINE (CSHUNL, CSHVAL MACROS). THEY WILL RETURN THE CURRENT SWEEP
NUMBER FOR THE REQUESTED OPERATION IN T1. THE CALLING ROUTINE THEN
MAY DO SOME EXTRA PROCESSING. BEFORE STARTING THE IO THAT NEEDED THE SWEEP,
CALLER IS RESPONSIBLE FOR WAITING FOR HIS SWEEP TO COMPLETE
BY CAME T1,CS?CNT. WHEN THE NUMBERS NO LONGER MATCH, THE REQUESTED
SWEEP HAS FINISHED.
IN AN IO SYSTEM WHERE REQUESTS THAT NEED SWEEPS ARE QUEUED, THE CURRENT
SWEEP NUMBER AT THE TIME THE REQUEST ENTERS THE QUEUE CAN BE STORED
WITH THE REQUEST. WHEN THE REQUEST IS SERVICED, A SWEEP ONLY NEED
BE INITIATED IF THE CURRENT SWEEP COUNT AND THE ONE STORED WITH
THE REQUEST ARE THE SAME.
#

;CSHUNL MACRO PUSHJS HERE.

CSUNL::WRPI	LI.PIF	;MUST NOT ALLOW VALIDATE TO SNEAK IN
	SWPUA			;START THE UNLOAD.
;	WRAPR	LP.CSF+LP.CSD+APRCHN ;IN CASE A PREVIOUS SWEEP FINISHED AFTER LI.PIF
	MOVSI	T1,(SWPUA)	;ANYONE WHO DOES VALIDATE MUST REALLY DO AN UNLOAD NOW.
	MOVEM	T1,CSVINS
	MOVE	T1,CSUCNT	;RETURN WITH CURRENT SWEEP NUMBER
	WRPI	LI.PIN		;BACK ON
	POPJ	P,

;CSHVAL MACRO PUSHJS TO HERE

CSVAL::WRPI	LI.PIF	;TURN OFF PI SYSTEM, DON'T LET SWEEP DONE SNEAK IN
CSVINS:	SWPVA			;START OUT WITH VALIDATE ALL, CHANGE
				; TO UNLOAD ALL WHEN UNLOAD IS IN PROGRESS.
;	WRAPR	LP.CSF+LP.CSD+APRCHN ;IN CASE IT SET BEFORE INTERRUPT GOT A CHANCE TO GET IN
	MOVE	T1,CSVCNT	;PICKUP PROPER VALIDATE COUNT
	WRPI	LI.PIN		;TURN PI BACK ON
	POPJ	P,		;AND RETURN.

TYFOON.MAC	
LNN.MAC	
ERRCHK.MAC	
FAKMAC.MAC	
BOOTS1.MAC	
CNFN72.MAC	
MAGSER.MAC	
FILRIB.MAC	
DSKCLN.MAC	
CNFNMF.MAC	
SEGCON.MAC	
CNFNPC.MAC	
CONF26.MAC	
CONF35.MAC	
VTEST.MAC	
CNFN70.MAC	
CNFN25.MAC	
DR11C.MAC	
FILIO.MAC	
{Page 15}
...
SWPSTD:
IFCPU (KL),<MOVE	T3,S	;GET DIRECTION OF IO
	MOVE	T4,CSNSAV	;GET LARGEST SWEEP NUMBER
	CAME	T4,@[CSUCNT
		     CSVCNT](T3) ;NEED A SWEEP?
	 PJRST	[AOS CSHSAV	;NO,  A SAVED SWEEP
		 PJRST @KONFIN(J)] ;AND START TRANSFER UP.
	JUMPN	T3,SWPCSV	;DO VALIDATE IF ITS OUTPUT
	CSHUNL			;INPUT, START AN UNLOAD.
	CAMN	T1,CSUCNT	;SWEEP NUMBER CHANGE YET?
	JRST	.-1		;NO, WAIT FOR APR INTERRUPT
	PJRST	@KONFIN(J)	;YES, CAN START I/O NOW.

SWPCSV:	CSHVAL			;IT WAS AN OUTPUT, DON'T UNLOAD CACHE
	CAMN	T1,CSVCNT	;WAIT UNTIL VALIDATE COMPLETES
	JRST	.-1
>;END IFCPU (KL)
IFCPU (KS),<SKIPN	S		;SKIP IF OUTPUT
	CSHIVL			;ON INPUT INVALIDATE CACHE
>;END IFCPU (KS)
	PJRST	@KONFIN(J)	;GO START UP I/O


CNFNPA.MAC	
CONF33.MAC	
CTYSIM.MAC	
Z.MAC	
LPTSER.MAC	
CNFN26.MAC	
KSSYM.MAC	
KMCSER.MAC	
CONF70.MAC	
CNFNCA.MAC	
CNFN65.MAC	
CNFN74.MAC	
CHKPNT.MAC	
CNFNMA.MAC	
CONF28.MAC	
CONF55.MAC	
CNFNFO.MAC	
ASP.MAC	
ONCDSK.MAC	
CONF65.MAC	
CONF74.MAC	
SETETY.MAC	 k 	î