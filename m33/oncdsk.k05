TITLE	ONCDSK	OPTIONAL & MANDATORY ONCE ONLY CODE

INTERN FILOPT,FILMAN,TYPONL,ONDSTT,ONDLNP,ONDLNR
INTERN MIN,MAX,LNGMES,DECLOP,CMDSCN,CMDSCF,ASKQMM,OPAGIN,OPAGOT
INTERN GETHOM,WTBOTH,GETBAT

EXTERN CONMES,CRLF,CTEXT,DECIN,GETLIN,OCONM,OCTIN,OPOUT,DSKDDB
EXTERN CORZER,SCNBAT,STTPTR,UNTTBL,SWPUNI,WRDSPP,STTFPC,BLKSPP,UNTLEN
EXTERN STTLEN,SATCNT,UFDHSI
EXTERN NMRBPC,CPOPJ,CPOPJ1,MFDRIB
EXTERN %HOM.P,%BAT.P,%STR.P,%STA.P
EXTERN COMTYO,SWPMAX,BRMAX,INLMES,NMSTPC
EXTERN CLRSND,PRNAME,RADX10,TPOPJ,CMPLOG,RB1UN,NMUFDS
EXTERN PAGIN,PAGOUT,PCISTS,PGYUNI,PGYPNO,STDREA,PGYERR,OHTNUM,OHTINI
EXTERN PCBPAG,PAKREF,HBBPGS,STDWRT,SWCLSN,SWPTAB,SWPTBE,GETPEV
EXTERN BATFIR,BATREG,BAYNBB,PAGCOD,PAGNAM,PAGSLF,HICORE
EXTERN CODBAT,CODHOM,CODRIB,DDBLEN,DDSTAR,ONCDDB
EXTERN ICPFAC,JFYSEC,KONDWN,KONUPA,KOPDWN,KONLTM,KONCPY
EXTERN LIMP4S,LPNHOM,LP2HOM,LPNBAT,LP2BAT,LPNSAT,SYSUNI,SYSSIZ
EXTERN PROT,PROT0,CLRDDB,YESNO
EXTERN REFSTR,SAVE4,SETDDO,IOSEL,CCOD,CWCOD

EXTERN HOMEND,HOMDAT,HOMCFS,HOMSUN,HOMMFD,HOMHSH,HOMRAN
EXTERN HOMHID,HOMP4C,HOMP4S,HOMLOG,HOMLUN,HOMNXT,HOMOVR
EXTERN HOMPRV,HOMREF,HOMSID,HOMSLB,HOMSNM,HOMSPU

EXTERN RIBLST,RIBPFS,RIBNAM,RBSPAR,RBREAL,RBINDX,RBMASK
EXTERN RBYUNI,RBYPNO
EXTERN RBYUN4,RBYUN1,RBLVPR,RBLVSP

EXTERN STRPPU,STRP4C,STRUNI,STRUNM,STRDDB,STRLEN,STRHSH
EXTERN STRNAM,STROVR,STRREF,STRTAL,SRPNDS,STRBTS

EXTERN UNIPPU,UNIDES,UNIERR,UNIHID,UNISYS
EXTERN UNINAM,UNIPTR,UNISLB,UNISTT,UNISTR,UNISUN,UNISWP
EXTERN UNITAL,UNPCHG,UNPHWP,UNPMSB,UNPOFL,UNVRSF,UNYPPY
EXTERN UNYCFS,UNYP4S,UNYKTP,UNYLN1,UNYLUN,UNYSPU,UNYUTP
EXTERN UNIBLK,UNIKON,UNILOG,UNICHN,UNPPRV,UNISTS

EXTERN DCN,STRPID,REPSID,RE.DCD,HOMDCT,HOMDCV

EXTERN CH7
ENTRY ONCMOD

ONCMOD:

ONDSTT:
PHASE %OND

;MACRO TO DEFINE ONCE RESTART SYMBOLS AND BYTE POINTERS
;
DEFINE DCNDEF (DCD)<
  INTERN  REONCE
	REONCE:	0
	DCNUM==0
	IRP DCD, <DCNUM==DCNUM+1>
	DCNTAB:
	DCXX==0
	IRP DCD, <DCN.'DCD==(1B<DCXX>)
		  DCNY'DCD: POINT DCSIZ,DCN,35-DCSIZ*<DCNUM-1-DCXX>
		  Intern DCN.'DCD,DCNY'DCD
		  DCXX==DCXX+1>
>
DCSIZ==DC.SIZ			;(FROM S).
DCNDEF (<OP,ON,UR,MN,HM,DF>)	;DSKCLN TYPE CAN BE SPECIFIED BY:
				; 'OP' - OPER in ONCE (FULL COMMAND)
				; 'ON' - OPER IN ONCDSK
				; 'UR' - USER PROG VIA .REST SETUUO
				; 'MN' - MONITOR IN CRASH CODE
				; 'HM' - HOME BLOCKS
				; 'DF' - DEFAULT
INTERN DCNDFT			;IN THAT ORDER OF PRIORITY
DCNDFT==DCN.HM!DCN.DF		; SETUP DEFAULT TO HOME-BLOCKS ! DEFAULT

SUBTTL

FILMAN:	SETOM	BATMAN		;MANDATORY CODE.
	PUSHJ	P,RDHOME	;READ HOME PAGES OF ALL UNITS.
	JRST	MANOK		;ALL OK.
	JRST	MANQST		;MINOR ERRORS.
	MOVEI	T1,[ASCIZ /
ERRORS which prevent bringing the system UP/]
MANCM1:	PUSHJ	P,CONMES
MANCOM:	PUSHJ	P,FILOPT
	JRST	FILMAN

MANREF:	MOVEI	T1,[ASCIZ /
File structure NEEDS refreshing/]
	JRST	MANCM1

MANQST:	MOVEI	T1,[ASCIZ /
MINOR ERRORS - Bring system UP anyway? /]
	PUSHJ	P,ASKQUE
	JRST	MANCOM		;NO.
MANOK:	PUSHJ	P,REDBAT	;READ THE BAT PAGES OF ALL UNITS.
	HLLZ	T1,STRDDB+STRREF
	JUMPN	T1,MANREF	;NEEDS REFRESH.


    ;HERE TO REWRITE HOME PAGES, WITH INCREMENTED PACK SET ID.
	HLRZ	U,STRDDB+STRUNI	;
	AOS	T1,RANNO
	TLNN	T1,-1
	JRST	.+3
	MOVEI	T1,(SIXBIT/CAT/)	;
	HRRZM	T1,RANNO	;
	HRLM	T1,STRDDB+STRPID
	PUSHJ	P,UPDHOM	;
	HLRZ	U,UNISTR(U)	;
	JUMPN	U,.-2		;
	PUSHJ	P,SPCDKP	;GET CURRENT DC MODE AND PRIORITY
	CAIE	T3,^L<(DCN.DF)>	;IS MODE DEFAULT
	JRST	.+4		;NO, DON'T QUERY OPER FOR MODE
	MOVE	T1,STRDDB+STRBTS	;DOES STR REQUIRE
	TRNE	T1,SRPNDS	; DSKCLN TO BE RUN
	PUSHJ	P,SPCDKN	;YES, ASK OPER TO SELECT MODE
	LDB	T1,DCNYON	;GET MODE
	MOVEM	T1,DCN		; AND SAVE IT FOR DSKCLN TO GETTAB

;HERE TO READ THE RIB FOR SAT.SYS AND SET UP THE STTPTR
;ENTRIES IN STT.

	HLRZ	U,STRDDB+STRUNI	;GET THE PRIME (AND ONLY)
RDRBS1:	PUSHJ	P,GETSRB	;RIB INTO %STR.
	STOPCD
	MOVEI	P4,RIBPFS	;P4/ REL ADDR OF RETRIEVAL POINTERS.
	HLRZ	U,STRDDB+STRUNI	;

      ;HERE FOR EACH UNIT.
RDRBS2:	LDB	T4,UNYLUN	;
	HRRZ	P2,UNISTT(U)	;P2/ STT ENTRY ADDRESS.
	LDB	P3,UNYSPU	;P3/ # SATS ON THE UNIT.

      ;HERE FOR EACH SAT.
RDRBS3:	CAIG	P4,RIBLST	;MUSTN'T RUN OUT OF RIB ROOM.
	SKIPN	T1,%STR(P4)	;NOT EXPECTING EOF HERE.
	STOPCD
	TLNN	T1,RBSPAR!RBINDX ;CHECK THAT THE POINTER IN T1
	TLNN	T1,RBREAL	;IS A CORRECT POINTER.
	STOPCD
	LDB	T3,RBYUN1	;IS THIS THE UNIT
	CAME	T3,T4		;THAT WE EXPECT TO SEE?
	STOPCD
	TLZ	T1,RBMASK-RBREAL ;
	MOVEM	T1,STTPTR(P2)	;YES.  SET STTPTR.
	ADDI	P4,1		;INC PNTR TO PNTRS.
	ADDI	P2,STTLEN	;ADJUST P2 TO NEXT STT ENTRY.
	SOJG	P3,RDRBS3	;LOOP AGAIN IF MORE SATS ON THIS UNIT.
	SETZM	STTPTR(P2)	;

	HLRZ	U,UNISTR(U)	;IS THERE ANOTHER
	JUMPN	U,RDRBS2	;UNIT?
	SKIPE	%STR(P4)	;NO.  CHECK THAT EOF IS PRESENT.
	STOPCD

;NOW READ ALL THE SATS ON EACH UNIT IN THE STR, AND SET STTFPC
;IN THE SATS.

RDSATS:	SETZM	STRDDB+STRTAL	;CLEAR THE TOTAL COUNT FOR THE STR.
	HLRZ	U,STRDDB+STRUNI	;
RDSTS1:	HRRZ	P3,UNISTT(U)	;P3/PNTR INTO STT FOR THIS UNIT.
RDSTS4:	SKIPN	T2,STTPTR(P3)	;OUT OF SATS ON THIS UNIT?
	JRST	RDSTS5		;YES, GO TO NEXT UNIT.
	LDB	T4,RBYPNO	;SAT
	MOVEI	PG,%STA.P	;INTO
	PUSHJ	P,OPAGIN	;%STA.
	JRST	.+2		;ERROR ON READ.
	JRST	RDST45		;READ OKAY.
	SETZM	%STA		;PRETEND ALL F BITS IN USE,
	MOVE	T1,[XWD %STA,%STA+1] ;AND LET
	BLT	T1,%STA+377	;DSKCLN WORRY.
RDST45:	SETOM	%STA+400	;SET ALL THE
	MOVE	T1,[XWD %STA+400,%STA+401] ;M BITS
	BLT	T1,%STA+777	;FREE.
	MOVE	T1,[XWD -400,%STA] ;AOBJN PNTR FOR SATCNT.
	PUSHJ	P,SATCNT	;T4/ NO. FREE PAGES IN THIS SAT.
	MOVEM	T4,STTFPC(P3)	;
	ADDM	T4,UNITAL(U)	;
	MOVE	T2,STTPTR(P3)	;WRITE  OUT THE SAT
	LDB	T4,RBYPNO	;SO THE CLEARED M BITS
	MOVEI	PG,%STA.P	;GET
	PUSHJ	P,OPAGOT	;OUT THERE.
	STOPCD
	ADDI	P3,STTLEN	;ADJUST PNTR TO STT.
	JRST	RDSTS4

    ;COMPUTE SAFETY FACTOR FOR UNIT AND ADJUST STRTAL.
RDSTS5:	MOVE	T1,UNIPPU(U)	;COMPUTE
	LDB	T2,UNYP4S	;THE SAFETY
	SUB	T1,T2		;FACTOR FOR
	IDIVI	T1,UNVRSF	;THE UNIT.
	LDB	T2,UNYSPU	;
	IMULI	T1,(T2)		;
	MOVNS	T1		;
	ADDB	T1,UNITAL(U)	;ADD TO UNIT'S COUNT.
	JUMPGE	T1,.+3		;DO NOT ALLOW
	SETZM	UNITAL(U)	;UNITAL TO GO
	JRST	RDSTS6		;NEGATIVE.
	ADDM	T1,STRDDB+STRTAL ;ADJUST STRTAL.

RDSTS6:	HLRZ	U,UNISTR(U)	;
	JUMPN	U,RDSTS1	;

	MOVE	T1,HICORE
	MOVEM	T1,SYSSIZ	;RESET FOR EVERYONE ELSE.
	MOVE	U,SWPTAB	;GET ADR. OF 1ST. UNIT DATA BLOCK IN ASL
	LDB	T3,UNYKTP	;FORM INDEX FOR TABLES
	LSH	T3,2
	LDB	T1,UNYUTP
	ADD	T3,T1
	MOVEI	T1,^D400	;COMPUTE AV. TRANSFER TIME IN JIFFIES FOR 1P.
	IDIV	T1,BKPREV(T3)
	IMUL	T1,MSPREV(T3)
	IMUL	T1,JFYSEC
	SUBI	T1,1
	IDIVI	T1,^D100000
	ADDI	T1,1
	IMULI	T1,ICPFAC	;TIMES IN CORE PROTECT TIME FACTOR
	MOVEM	T1,PROT		;SAVE FOR SWAPPER
	MOVE	T1,MSPREV(T3)	;COMPUTE AV. SEEK TIME IN JIFFIES
	LSH	T1,-1
	ADD	T1,AVSEEK(T3)
	IMUL	T1,JFYSEC
	SUBI	T1,1
	IDIVI	T1,^D1000
	ADDI	T1,1
	IMULI	T1,ICPFAC
	ADD	T1,PROT
	MOVEM	T1,PROT0	;SAVE FOR SWAPPER.
	MOVSI	T1,UNPCHG
	HLRZ	U,SYSUNI	;GET ADR. OF 1ST. UNIT DATA BLOCK IN SYSTEM
	ANDCAM	T1,UNIDES(U)	;CLEAR CHANGE BIT
	HLRZ	U,UNISYS(U)	;GET ADR. OF NEXT UNIT DATA BLOCK IN SYSTEM
	JUMPN	U,.-2		;REPEAT IF ANY LEFT
	SKIPE	F,DDSTAR		;IF A DDB SETUP
	PUSHJ	P,CLRDDB		;THEN CLEAR IT.
	POPJ	P,		;NO - RETURN

;BLOCKS PER REVOLUTION TABLE

BKPREV:	0	;NEW DRUM
	0	;DITTO
	0
	0
	^D20	;RD10
	^D30	;RM10B
	0	;?
	0	;?
	^D5	;RP01
	^D10	;RP02
	^D10	;RP07
	^D10	;RP03
	^D11	;DUAL POSITIONER MD10
	^D11	;SINGLE POSITIONER MD10
	0	;?
	0	;?
	^D18	;3330
	0
	0
	0
	^D30	;RM03
	^D20	;RP06
	^D32	;F3
	0

;MILLESECONDS PER REVOLUTION TABLE

MSPREV:	0	;NEW DRUM
	0	;DITTO
	0
	0
	^D33	;RD10
	^D17	;RM10B
	0	;?
	0	;?
	^D25	;RP01
	^D25	;RP02
	^D25	;RP07
	^D25	;RP03
	^D50	;DUAL POSITIONER MD10
	^D50	;SINGLE POSITIONER MD10
	0	;?
	0	;?
	^D17	;3330
	0
	0
	0
	^D17	;RM03
	^D17	;RP06
	^D17	;F3
	0

;AV. SEEK TIME(MS) TABLE

AVSEEK:	0	;NEW DRUM
	0	;DITTO
	0
	0	;?
	0	;RD10
	0	;RM10B
	0	;?
	0	;?
	^D50	;RP01
	^D35	;RP02
	^D25	;RP07
	^D35	;RP03
	^D110	;DUAL POSITIONER MD10
	^D110	;SINGLE POSITIONER MD10
	0	;?
	0	;?
	^D30	;3330
	0
	0
	0
	^D30	;RM03
	^D29	;RP06
	^D30	;F3
	0


COMMENT #
@@SUBROUTINE GETSRB
@@PURPOSE
SUBR TO READ THE RIB BLOCK FOR SAT.SYS INTO %STR.
@@ENTRY
EXPECTS U/ UNIT DB AND F/ DDB.
@@ACCUM
DESTROYS
@@CALLS
RDCHEK.
@@EXIT
SKIP RETURNS IF THE PAGE READ SUCCESSFULLY.
@@ #


GETSRB:	MOVEI	T4,LPNSAT	;T4/ LOG. PAGE NO. ON UNIT.
	MOVE	P3,[EXP CODRIB]	;GET CODE WORD FOR RIB PAGES.
	MOVSI	P2,(SIXBIT .SAT.)
	MOVEI	PG,%STR.P	;
	SETOM	WHICH		;INDICATE READING FIRST (AND
	SETZM	NOERH		;ONLY) PAGE.
	PJRST	RDCHEK		;READ & VERIFY RIB PAGES.

;SOME MACROS FOR COMMAND WORK

	DEFINE SCAN (A,B) <
IFB <B>,<
PRINTX	SCANNER TABLE 'A' Has an undefined SETxM statement
>
	MOVEI	P1,SCN'A		; Get address of Scan Table
	SET'B'M	CMDSCF			; Specify NO STR/UNIT stuff
	PUSHJ	P,CMDSCN		; Call Scanning routine
	  JRST	HLP'A			; No good!
	XCT DSP'A'(P3)			; Yes?
	JRST	A'CMD			; Return as if cr typed.

A'HLP:	Move	P3,-2(P1)		; Setup AOBJN pointer for messages
A'HL1:	Hrrz	T1,(P3)			; Get address of message
	Pushj	P,LNGMES		; Print a long message
	Aobjn	P3,A'HL1		; Next?
	Jrst	A'CMD			; Return.
>

;MACRO TO MAKE SCAN TABLE
;UNI IS PLACE TO JRST TO IF UNIT
;STR IS PLACE TO JRST TO IF STR
;NAM IS TABLE NAME  Generates SCN'NAM, DS, TXT'NAM, SIZ'NAM
; Assumes MK'NAM as the macro defining the X arguments
; JRST to NUL'NAM on <CR> and HLP'NAM on error
; Defines NAM'HLP for a standard typeout of help texts

	Extern Ab.Ack,Ab.Nak,Ab.Ver,Ab.Tcv ; Bits for abbrev - See ONCE.MAC
	DEFINE SCNTB (UNI,STR,NAM) <

	DEFINE X(SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3) <
	INS>	;INSTRUCTION TO EXECUTE

	JRST UNI		;FOR -3 RETURN
	JRST STR		;FOR -2 RETURN
	JRST NUL'NAM		;FOR -1 RETURN
DSP'NAM: MK'NAM			;GENERATE DISPATCH TABLE
	SIZ'NAM==.-DSP'NAM
	-SIZ'NAM,,TXT'NAM	;AOBJN POINTER TO HELP
	-SIZ'NAM,,SCN'NAM	;AOBJN POINTER TO NAMES
	DEFINE X (SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3)
<	<SIXBIT /SYM/>>
SCN'NAM: MK'NAM			; Define Table to read

	$XZ==0			; Need a counter
	define xz$(argh)<lit$'argh==.>
	DEFINE X (SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3)
<	xz$(\$XZ)
Ifnb <TEXT>,<ASCIZ \TEXT'TEXT1'TEXT2'TEXT3\>
	$XZ==$XZ+1>
	MK'NAM

	$XZ==0
	define xz$(argh)<lit$'argh>
	DEFINE X (SYM,INS,BIT,TEXT,TEXT1,TEXT2,TEXT3) <
	<Xwd	Bit,xz$(\$XZ)>
	$XZ==$XZ+1>
TXT'NAM: MK'NAM

>

;P1 IS A POINTER TO THE NAMES TABLE
;The command scanning routine - Copied and munged from ONCDSK

CMDSCN:	PUSHJ	P,CTEXT		; Get text
	 JUMPE	T2,[CAIL T3,40	;  EOL?
		    POPJ P,	;NOT NULL LINE, SPC CHR
		    MOVNI P3,1	;RETURN P3=-1 FOR NULL STRING
		    JRST CPOPJ1]
	MOVE	T1,T2		;GET TEXT IN T1
	SKIPN	CMDSCF		; Skip IF we want to do UNI/STR stuff
	  Jrst	CMDSC1		; NO!  Don't Bother.
	MOVEM	U,SVU
	PUSHJ	P,FNDSTR	;IS IT A STR?
	JRST	[MOVNI P3,2	;-2 FOR STR WITH P2 TO STR BLOCK
		 JRST CPOPJ1]
	PUSHJ	P,FNDUNI	;CHECK ON UNIT
	  SKIPA			;NO
	JRST	[MOVNI P3,3	;-3 WITH U POINTING TO UNIT BLOCK
		 JRST CPOPJ1]
	MOVE	U,SVU
CMDSC1:	MOVE	P2,-2(P1)	;GET AOBJN POINTER TO HELP TABLE
	MOVE	P3,-1(P1)	;GET AOBJN POINTER TO NAME TABLE
	MOVEI	P4,0		;NOTHING SEEN SO FAR
	MOVSI	T3,770000	;MAKE A MASK
CMDSC2:	TDNE	T1,T3		; Did we type something?
	TDO	T1,T3		; If something there, set mask bits
	LSH	T3,-6		; Shift
	  JUMPN	T3,CMDSC2	; While we have more to check...
CMDSC3:	CAMN	T2,(P3)		; Compare !
	  JRST	CMDSC5		; Exact match
	Move	T3,(P2)		; Get Bits,,Text-Adr
	TLNE	T3,AB.NAK	; See if we can abbreviate it
	  JRST	CMDSC4		; No! -- Don't bother
	MOVE	T3,(P3)		;NO - CHECK MORE
	AND	T3,T1		;MASK OUT UN-TYPED STUFF
	CAME	T3,T2		;CHECK AFTER MASK
	  JRST	CMDSC4		;NO
	JUMPN	P4,[MOVEI P4,1	;SET POSITIVE FOR MULTI MATCH
		    JRST   CMDSC4]
	MOVE	P4,P3		;SAVE MATCH
CMDSC4:	Aoj	P2,		; Increment text pointer
	AOBJN	P3,CMDSC3	; Loop through the table
	SKIPL	P3,P4		;ANY MASKED MATCHES
	  POPJ	P,		;NONE OR MORE THAN 1
CMDSC5:	SUB	P3,P1		;CONVERT TO RELATIVE INDEX
	Hrrz	P2,-2(P1)	; Get AOBJN Pointer for
	Add	P2,P3		; Add offset
	Move	P2,(P2)		; Get Bits,,Text-Addr
	TLNN	P2,AB.VER	; Should we Verify?
	  JRST	CPOPJ1		; No! Just Return "SAFE"
	TLNN	P2,AB.TCV	; Is it a TYPE/CHANGE item?
	  CAIA			; No.. Don't worry!
	SKIPL	TYPONL		;  Type ONLY?
	  CAIA			; No.. Keep going!
	 Jrst	CPOPJ1		; YES! Don't verify.
	Hrrz	T1,P2		; Get Text Address
	Pushj	P,LNGMES	; Type it out.
	Movei	T1,[Asciz\

Are you SURE you want to do this? \]
	PJRST	YESNO		; A "Y" will skip, else assume NO.


CMDSCF:	0			; Flag for checking UNI/STR Stuff
				; 0==No checking, -1==Check!
SVP2:	0
SVU:	0

FILOPT:	MOVEI	T1,[ASCIZ /
Entering FILES (ONCDSK) dialogue...
  Type "GO" to return to ONCE./]
	PUSHJ	P,CONOUT
	SETZM BATMAN
	PUSHJ P,RDHOME
	 JFCL
	 JFCL
	PUSHJ	P,REDBAT	;READ BAT PAGES.

HLPFIL:	MOVEI T1,[ASCIZ /
  Type "HELP" for a list of options.
/]
HLPTY1:	PUSHJ P,OCONM
	PUSHJ P,OPOUT

TYPCMD:
CHGCMD:
SRPCMD:
NULFIL:
FILCMD:	MOVEI T1,[ASCIZ /
FILES* /]
	PUSHJ P,OCONM
	PUSHJ P,OPOUT
	SETOM KNOUNI
	SETOM DBLSTD
	PUSHJ P,GETLIN
	 JRST FILCMD	;NOTHING THERE
	SCAN (FIL,Z)

	DEFINE MKFIL <
	X DSKCLN,<PUSHJ P,SPCDKN>,Ab.Nak!Ab.Ver,<
DSKCLN  Query or Select DSKCLN mode.
        List the current mode and allow the operator to change it.>
	X TYPE,<JRST TYPIT>,Ab.Ack,<
TYPE    List information about the structure.
        Type "TYPE HELP" for a list of options.>
	X CHANGE,<JRST CHGIT>,Ab.Ack,<
CHANGE  Change information about the structure.
        Type "CHANGE HELP" for a list of options.>
	X ADD,<PUSHJ P,ADDUNI>,Ab.Nak!Ab.Ver,<
ADD     Add a unit to the structure.
        Reconfigure the disk structure and add another pack.>
	X DISOLVE,<PUSHJ P,STSDSL>,Ab.Nak!Ab.Ver,<
DISOLVE Disolve the structure.
        Remove all units from the system structure.>
	X DEFINE,<PUSHJ P,STSDEF>,Ab.Nak!Ab.Ver,<
DEFINE  Define a NEW structure.
        Create a completely new system structure.>
	X REFRESH,<PUSHJ P,STSREF>,Ab.Nak!Ab.Ver,<
REFRESH Refresh the structure.
        Erase the current file system and start over
        with a "FRESH" disk.>
	X GO,<JRST FILGO>,Ab.Ack,<
GO      Terminate the ONCDSK dialogue.
        Return to the ONCE dialogue.>
	X HELP,<JRST FILHLP>,Ab.Ack,<
HELP    Type this message.
>
>
	SCNTB (HLPFIL,HLPFIL,FIL)

TYPIT:	SETOM TYPONL	;ONLY TYPEOUT
	SCAN (TYP,O)

NULTYP:
HLPTYP:	MOVEI T1,[ASCIZ /
Type "TYPE HELP" for a list of options.
/]
	JRST HLPTY1

	DEFINE MKTYP <
	X STR,<PUSHJ P,TYPSTR>,Ab.Nak,<
STR     Name of the STRUCTURE and UNITS on it.>
	X UNITS,<PUSHJ P,TYPUNS>,Ab.Nak,<
UNITS   Names of all units NOT in a file structure.>
	X SWAP,<PUSHJ P,TYPASL>,Ab.Nak,<
SWAP    Names of all units in the Active Swapping list.>
	X BAT,<PUSHJ P,TYPBAT>,Ab.Nak,<
BAT     Number of BAD pages and regions for a unit.>
	X SATPCBS,<PUSHJ P,TYPSPC>,Ab.Nak,<
SATPCBS Number of SAT PCBs.>
	X RIBPCBS,<PUSHJ P,TYPRPC>,Ab.Nak,<
RIBPCBS Number of RIB PCBs.>
	X ALL,<JRST TYPALL>,Ab.Nak,<
ALL     All of the above.>
	X HELP,<JRST TYPHLP>,Ab.Ack,<
str-name  Type information about the structure.
unit-name Type information about the unit.
HELP    Type this message.
>
>
	SCNTB (TYPUIP,TYPSRP,TYP)
CHGIT:	SETZM TYPONL
	SCAN (CHG,O)
NULCHG:
HLPCHG:	MOVEI T1,[ASCIZ /
Type "CHANGE HELP" for a list of options.
/]
	JRST HLPTY1

	DEFINE MKCHG <
	X SWAP,<PUSHJ P,CHGASL>,Ab.Nak!Ab.Ver,<
SWAP      Change the active swapping list.>
	X SATPCBS,<PUSHJ P,CHGSPC>,Ab.Nak!Ab.Ver,<
SATPCBS   Change the number of SAT PCBs.>
	X RIBPCBS,<PUSHJ P,CHGRPC>,Ab.Nak!Ab.Ver,<
RIBPCBS   Change the number of RIB PCBs.>
	X BAT,<PUSHJ P,CHGBAT>,Ab.Nak!Ab.Ver,<
BAT       Refresh the BAT pages for a UNIT.>
	X HELP,<JRST CHGHLP>,Ab.Ack,<
str-name  Change parameters for the structure
unit-name Change parameters for a unit.
HELP    Type this message.
>
>
	SCNTB (TYPUIP,TYPSRP,CHG)

TYPUIP:	HRRZ	P2,UNISTR(U)	;IN CASE IN FS
	MOVEM	P2,UIPSVU	;SAVE IT!
	MOVEI	P1,SCNUIP	; Get address of Scan Table
	SETOM	CMDSCF		; Specify STR/UNIT stuff
	PUSHJ	P,CMDSCN	; Call Scanning routine
	  JRST	HLPUIP		; No good!
	MOVE	P2,UIPSVU	;RESTORE in case needed.
	XCT	DSPUIP(P3)	; Yes?
	JRST	FILCMD		; Return as if cr typed.
UIPSVU:	0

UIPHLP:	Move	P3,-2(P1)	; Setup AOBJN pointer for messages
UIPHL1:	Hrrz	T1,(P3)		; Get address of message
	Pushj	P,LNGMES	; Print a long message
	Aobjn	P3,UIPHL1	; Next?
	Jrst	FILCMD		; Return.
NULUIP:
HLPUIP:	MOVEI T1,[ASCIZ /
Type "TYPE unit-name HELP" for a list of options./]
	SKIPL TYPONL
	MOVEI T1,[ASCIZ /
Type "CHANGE unit-name HELP" for a list of options./]	;WAS A CHANGE
	JRST HLPTY1

	DEFINE MKUIP <
	X ID,<PUSHJ P,UNITID>,Ab.Nak!Ab.Ver!Ab.Tcv,<
... ID    Unit ID.>
	X SWAP,<PUSHJ P,UNITSW>,Ab.Nak!Ab.Ver!Ab.Tcv,<
... SWAP  Pages for swapping.>
	X ALL,<JRST UNITPA>,Ab.Nak!Ab.Ver!Ab.Tcv,<
... ALL   All of the ABOVE.
          The Unit-ID, Pages for Swapping.>
	X HELP,<JRST UIPHLP>,Ab.Ack,<
... HELP  Type this message.
>
>
	SCNTB (HLPUIP,HLPUIP,UIP)


UNATP1:	PUSHJ P,UNITID
	PUSHJ P,UNITSW
	PUSHJ P,UNITST
	JRST FILCMD

UNITPA:	SKIPGE TYPONL
	JRST UNATP1	;ONLY TYPING
	MOVEI T1,[ASCIZ /Do you want the STANDARD values?
/]
	PUSHJ P,ASKQUE
	 JRST UNATP1	;NO
	PUSHJ P,UNCHKA		;CALL THE CHANGE PAR ROUTINE
	JRST FILCMD

UNCHKA:	SKIPN UNIHID(U)
	PUSHJ P,UNITID
	SKIPL UNISUN(U)		;IF IN ACTIVE SWAP DON'T CHANGE SWAP
	JRST UNATP3
	JUMPE P2,UNATP2	;IF NOT IN STR, OK TO CHANGE
	HLRZ T1,STRREF(P2)
	JUMPE T1,UNATP3	;IF IN STR, DO NOT CHANGE UNLESS NEEDES REF
UNATP2:	LDB T1,UNYKTP
	XCT SWPDEF(T1)
	MOVEM T2,DBLSTD
	LDB	T1,UNYP4S	;GET CURRENT SWAP SPACE
	PUSH	P,T1		;AND SAVE IT.
	PUSHJ P,UNITSW
	POP P,T1
	JUMPN T1,UNATP3	;ALREADY HAD SWAP SPACE
	LDB	T1,UNYP4S
	JUMPE T1,UNATP3	;OR DID NOT GET ANY
	PUSHJ P,FTYUNI	;TYPE NAME IF NECESSARY
	 JFCL
	MOVEI T1,[ASCIZ /Unit HAS swapping space, suggest changing swapping list/]
	PUSHJ P,CONOUT	;TELL SOMEONE ABOUT CHANGE
UNATP3:	PJRST	UNITST


TYPSRP:	SCAN (SRP,O)
NULSRP:
HLPSRP:	MOVEI T1,[ASCIZ /
Type "TYPE str-name HELP" for a list of options./]
	SKIPL TYPONL
	MOVEI T1,[ASCIZ /
Type "CHANGE str-name HELP" for a list of options./]
	JRST HLPTY1

	DEFINE MKSRP <
	X OVERDRAW,<PUSHJ P,STRTOV>,Ab.Nak!Ab.Ver!Ab.Tcv,<
... OVERDRAW  The number of pages for overdraw.>
	X CRASH,<PUSHJ P,STRTCH>,Ab.Nak!Ab.Ver!Ab.Tcv,<
... CRASH     The number of pages for CRASH.SAV.>
	X ALL,<JRST STRTPA>,Ab.Nak!Ab.Ver!Ab.Tcv,<
... ALL       All of the ABOVE.
              The number of pages for Overdraw, for CRASH.SAV.>
	X HELP,<JRST SRPHLP>,Ab.Ack,<
... HELP      Type this message.
>
>
	SCNTB (HLPSRP,HLPSRP,SRP)

STRTPA:	PUSHJ P,STRTOV
	PUSHJ P,STRTCH
	JRST SRPCMD

;HELP INFORMATION

LNGMES:	HRLI T1,(POINT 7,0)
LNGMS1:	ILDB T3,T1
	JUMPE T3,CPOPJ
	PUSHJ P,COMTYO
	CAIE T3,12
	JRST LNGMS1
	PUSH P,T1
	PUSHJ P,OPOUT
	POP P,T1
	JRST LNGMS1

COMMENT #
@@SUBROUTINE RDHOME
@@PURPOSE
SUBR TO READ & VERIFY HOME PAGES FOR ALL UNITS AT SYSTEM
INITIALIZATION.  BUILDS THE SYSTEM STR AND THE ACTIVE
SWAPPING LIST.  SETS INFO IN THE STR DB AND IN THE UNIT DBS.
@@CALLS

@@EXIT
NON-SKIP RETURNS IF AN ERROR WAS DETECTED WHILE READING THE
HOME PAGES OF 1 OR MORE UNITS AND/OR NO STR WAS CREATED
AND/OR MORE THAN ONE STR WAS CREATED.
SKIP RETURNS IF ALL HOME PAGES THAT WERE NOT DOWN READ OK.
@@ #

RDHOME:	MOVE	T1,SYSSIZ
	MOVEM	T1,HICORE	;SAVE THIS FOR LOCAL USE.
	SETZM	DSKDDB+DEVIOS	;
	WRPI	LI.PIN		;TURN PI SYSTEM ON FOR WAITS
	SKIPE F,DDSTAR		;IS THERE A DDB SETUP?
	PUSHJ P,CLRDDB		;YES, CLEAR IT
	MOVE	 T1,ONCDDB		;GET LOCATION OF ONCE ONLY DDB
	MOVEM T1,DDSTAR
	PUSHJ	P,SETDDO	;CREATE A DDB FOR ONCE ONLY I/O
	 STOPCD .
	HRRZS	SWPUNI		;INITIALLY THERE ARE NO UNITS IN ASL
	SETZM	SWPUNM		;CLEAR OUT # UNITS IN ASL WORD
	MOVSI	T1,-SWPMAX	;CLEAR OUT TABLE OF UNIT ADRS. IN ASL
	SETZM	SWPTAB(T1)
	AOBJN	T1,.-1
	PUSH	P,STRDDB+STRBTS	;PRESERVE NEED DSKCLN FLAG.
	PUSHJ	P,CLRSTR	;INITIALLY THERE IS NO STR.
	POP	P,T3		;RESTORE THE STATE
	MOVEI	T1,SRPNDS	;OF THE NEED DSKCLN
	TDNE	T1,T3		;FLAG FOR
	IORM	T1,STRDDB+STRBTS ;THIS STR.
	SETZM	RANNO		;
	HLRZ	U,SYSUNI	;GET ADR. OF 1ST UNIT DATA BLOCK IN SYSTEM.
	JUMPE	U,RDHOM2	;
	MOVSI	T3,UNPPRV	;
RDHOM1:	IORM	T3,UNIDES(U)	;SET UNIT TO BE A PRIVATE PACK.
	HLRZ	U,UNISYS(U)	;
	JUMPN	U,RDHOM1	;
RDHOM2:	HLRZ	U,SYSUNI	;
	SETZM	ERRHOM		;CLEAR ERROR(S) WHILE READING HOME PAGES FLAG
	SETZM ERRHM2
	TDZA T1,T1
SCNUNI:	MOVE T1,J		;SAVE OLD KON
	HRRZ	J,UNIKON(U)	;GET ADR. OF KONTROLLER DATA PAGE FOR THIS UNIT
	SKIPGE	KONUPA(J)	;HAS KONTROLLER BEEN FLAGGED AS DOWN?
	JRST	FLGDWN		;YES - FLAG UNIT AS DOWN ALSO
	CAMN T1,J		;IS IT THE SAME
	JRST KONTOK		;YES, DO NOT NEED TO TRY AGAIN
TRYKON:	PUSHJ	P,@KONUPA(J)	;SEE IF KONTROLLER IS UP
	  SKIPA	P1,UNINAM(U)	;IT'S DOWN
	JRST	KONTOK		;NOW SEE IF UNIT IS OK

;HERE IF KONTROLLER IS DOWN.
	HLLZS	P1		;GET SIXBIT KONTROLLER NAME
	MOVEI	T3,[ASCIZ .DO YOU WANT IT TO BE 1)ON-LINE, OR 2)DOWN? (TYPE #)
.]
	PUSHJ	P,MCKKON	;PRINT MSG & GET ANSWER
	  JRST	TRYKON		;ILLEGAL RESPONSE
	CAIE	T2,2		;WAS "2" TYPED?
	JRST	TRYKON		;NO - CHECK AGAIN IF "1" OR ANYTHING ELSE WAS TYPED
	MOVSI	T1,KOPDWN	;KONTROLLER DOWN BIT(SIGN BIT)
	IORM	T1,KONDWN(J)	;FLAG KONTROLLER AS DOWN
	JRST	FLGDWN		;FLAG UNIT DOWN AS WELL

;HERE IF KONTROLLER ON-LINE - TO CHECK IF UNIT OK
KONTOK:	MOVSI	T1,UNPOFL
	TDNE	T1,UNIDES(U)	;IS UNIT OFF-U OR DOWN?
	JRST	SCNUN1		;YES - CONTINUE SCAN ON NEXT UNIT
	PUSHJ P,DSKCPY		;GET CAPACITY AND SEE IF UP
	SKIPL T4,UNIBLK(U)
	JRST WCKUNI		;IF POSITIVE, UNIT IS UP
	PUSHJ P,UNTDWN

;HERE TO FLAG UNIT AS DOWN & OFF-U.
FLGDWN:	MOVEI	T2,SYSUNI-UNISYS ;SYSUNI - UNISYS
FLGDN1:	HLRZ	T1,UNISYS(T2)	;NEXT UNIT IN SYSTEM
	CAMN	T1,U		;SKIP IF NOT FOUND DOWN UNIT
	JRST	FLGDN2
	HLRZ	T2,UNISYS(T2)	;NEXT UNIT IN SYSTEM
	JUMPN	T2,FLGDN1
	JRST	FLGDN3		;NOT THERE?
FLGDN2:	HLRZ	T1,UNISYS(T1)	;LINK TO NEXT UNIT
	HRLM	T1,UNISYS(T2)	;STORE IN PREVIOUS
FLGDN3:	SKIPA	T2,U		;T2 = THIS UNIT
FLGDN4:	HLRZ	T2,UNIKON(T2)	;NEXT UNIT IN KONTROLLER RING
	HLRZ	T1,UNIKON(T2)	;NEXT BACK TO US?
	CAME	T1,U
	JRST	FLGDN4		;NO
	HLRZ	T1,UNIKON(T1)	;YES, LINK TO NEXT
	HRLM	T1,UNIKON(T2)	;STORE IN PREVIOUS
	SKIPA	T2,U		;T2 = THIS
FLGDN5:	HLRZ	T2,UNICHN(T2)	;T2 = NEXT UNIT IN CHANNEL RING
	HLRZ	T1,UNICHN(T2)
	CAME	T1,U		;BACK TO US?
	JRST	FLGDN5		;NO
	HLRZ	T1,UNICHN(T1)	;LINK TO NEXT
	HRLM	T1,UNICHN(T2)	;STORE IN PREVIOUS
	MOVSI	T1,UNPOFL	;OFF-U BIT
	IORM	T1,UNIDES(U)	;SET BIT IN LH. OF UNIDES WORD
	JRST	SCNUN1		;CONTINUE SCAN ON NEXT UNIT

;HERE IF UNIT ON-LINE - TO CHECK IF UNIT WRITE ENABLED
WCKUNI:	MOVSI T1,UNPHWP
	TDNN T1,UNIDES(U)
	TLNN T4,(1B1)		;IS IT WRITE PROTECTED?
	JRST CHKHOM		;UNIT IS OK OR HAVE BEEN HERE BEFORE
	MOVEI	T3,[ASCIZ .DO YOU WANT IT TO BE 1)WRITE-ENABLED, OR 2)WRITE-PROTECTED? (TYPE #)
.]
	PUSHJ	P,WRPUNM	;PRINT MSG & GET ANSWER
	  JRST	TRYKON		;ILLEGAL RESPONSE
	CAIE	T2,2		;WAS "2" TYPED?
	JRST	TRYKON		;NO - CHECK AGAIN IF "1" OR ANYTHING ELSE WAS TYPED
	MOVSI	T1,UNPHWP	;HARDWARE WRITE-PROTECT BIT
	IORM	T1,UNIDES(U)	;FLAG UNIT AS WRITE PROTECTED

;HERE IF UNIT ON-LINE & LEGALLY WRITE PROTECTED OR ENABLED - CHECK ITS HOME PAGES

CHKHOM:	PUSHJ	P,GETHOM	;GET HOME PAGE INTO CORE.
	  CAIA			;ERROR(S) ON BOTH HOME PAGES - T3 RETURNED NON 0.
	JRST	HMBOK		;AT LEAST ONE HOME PAGE OK
				;FORCE TO BE A NULL PAGE, NO OPTIONS
	MOVEI	T1,%HOM		;
	PUSHJ	P,CORZER	;
	MOVEM	P2,%HOM+PAGNAM	;STORE SIXBIT "HOM"
	MOVEM	P3,%HOM+PAGCOD	;STORE HOME PAGE CODE
	SETOM	%HOM+HOMSUN	;INDICATE UNIT NOT IN ASL
	PUSHJ	P,SETCHG	;FLAG THAT THIS UNIT'S HOME PAGE MUST BE REWRITTEN
	PUSHJ	P,MOVUNI	;MOVE PARAMS FROM HOME PAGE TO UNIT DATA BLOCK.
	JRST	NTISTR		;

;HERE IF HOME PAGE(S) READ INTO CORE OK
; GENERATE STR DB & LINK UNIT DBS CORRECTLY.

HMBOK:	JUMPE	T3,.+2		;ERR WHILE READING HOME PAGES?
	PUSHJ	P,SETCHG	;YES. FLAG THEY NEED REWRITING.
	PUSHJ	P,MOVUNI	;MOVE PARAMS FROM HOME PAGE TO UNIT DB
	MOVEI	P2,0		;SET STR DB ADR. = 0 IN CASE NO STR FOUND
	MOVE	T1,%HOM+HOMSNM	;GET STR NAME FROM HOME PAGE.
	JUMPN	T1,HMBOK2	;DON'T LOOK FOR OR CREATE A ZERO STR NAME.
	LDB	T1,UNYP4S	;ONLY WAY TO STAY
	JUMPN	T1,NOTPRV	;PRIVATE IS TO NOT BE IN A STR
	JRST	OLDSTR		;AND TO HAVE NO SWAPPING SPACE.
HMBOK2:	PUSHJ	P,FNDSTR	;DOES THIS STR EXIST?
	JRST	NOTPRV		;YES. UNIT IS NOT A PRIVATE PACK.
	SKIPE	STRNAM(P2)	;NO, DOES ANY STR EXIST?
	JRST	NOSTR		;YES, ONLY ONE STR IS LEGAL. DIE.
				;NO, THIS IS THE SYSTEM STR.
	PUSHJ	P,MOVSTR	;MOVE PARAMS FROM HOME PAGE TO STR DB.
	MOVE	T2,REONCE	;GET ONCE COPY OF RESTRT WORD
	TLZ	T2,DCN.UR!DCN.MN	;IN CASE STR IS MODIFIED
	HRRZ	T1,%HOM+HOMRAN	;GET PACK SET ID
	CAME	T1,REPSID	;HAS NEW PACK SET BEEN MOUNTED?
	JRST	HMBOK3		;YES: IGNORE RESTRT
	SETZ	T1,		;ZERO DSKCLN TYPE SPEC FLAG WORD
	TRNE	T2,RE.DCD	;DID USER SELECT A DSKCLN TYPE?
	TLO	T1,DCN.UR	;YES: SO INDICATE
	TLO	T1,DCN.MN	;IND MON SELECTED A DSKCLN TYPE
	IORM	T1,DCN
HMBOK3:	MOVE	T1,%HOM+HOMDCT	;INITIALIZE FOR VERIFICATION OF
	DPB	T1,DCNYHM	; HOME BLOCK DSKCLN TYPE VALIDITY
NOTPRV:	PUSHJ	P,SETPUB	;SET THE UNIT PUBLIC.

    ;HERE WHEN STR UNIT BELONGS IN EXISTS - SEE IF UNIT IS IN ASL.
OLDSTR:	JUMPE	P2,OLDST8	;SKIP OVER RAN & HSH CHK IF NO STR.
	LDB	T1,DCNYHM	;SET UP TO VERIFY THAT HOME
	HRLI	T1,HOMDCV	; DSKCLN TYPE IS VALID/CONSISTENT
	HRLZI	T2,DCN.HM
	CAME	T1,%HOM+HOMDCT	;IS TYPE GOOD?
	ANDCAM	T2,DCN		;NO: SO INDICATE
	HLRZ	T1,%HOM+HOMHSH	;T1/ UNIT'S HASH CONSTANT.
	JUMPE	T1,OLDST1	;MUST BE NON-ZERO.
OLDST2:	HRRZ	T2,STRHSH(P2)	;T2/ STR'S HASH CONSTANT SET
	JUMPN	T2,.+3		;YET?
	HRRM	T1,STRHSH(P2)	;NO, JUST STORE FIRST FOUND.
	JRST	OLDST4		;GO TO RAN LOOK.
	CAIN	T1,(T2)		;YES, BETTER MATCH OTHERS'.
	JRST	OLDST4		;OKAY.
OLDST1:	MOVEI	T1,[ASCIZ /MISSING OR INCONSISTENT HASH CONSTANT FOR UNIT /]
	PUSHJ	P,MSGUNI	;
OLDST4:	HRRZ	T1,%HOM+HOMRAN	;T1/ UNIT'S PACK SET ID.
	JUMPE	T1,OLDST5	;CAN'T BE ZERO.
OLDST6:	SKIPE	T2,RANNO	;ALREADY SEEN ID?
	JRST	.+3		;YES.
	HRRZM	T1,RANNO	;NO, JUST STORE FIRST FOUND.
	JRST	OLDST8		;
	CAIN	T1,(T2)		;YES, BETTER MATCH OTHERS'.
	JRST	OLDST8		;OKAY.
OLDST5:	MOVEI	T1,[ASCIZ /MISSING OR INCONSISTENT PACK SET ID FOR UNIT /]
	PUSHJ	P,MSGUNI	;
OLDST8:	SKIPGE	P4,UNISUN(U)	;IS UNIT IN ACTIVE SWAPPING LIST?
	JRST	NOTISL		;NO - TRY TO LINK UNIT WITH OTHER UNITS IN STR
	SKIPE	%HOM+HOMSID	;IS UNIT LAST UNIT IN SWAPPING LIST?
	JRST	NOTLSL		;NO
	SKIPN	SWPUNM		;HAS THERE ALREADY BEEN A LAST UNIT?
	JRST	LSTASL		;NO - GO INDICATE THAT THERE HAS NOW
	MOVEI	T1,[ASCIZ .
MORE THAN ONE LAST UNIT IN ACTIVE SWAPPING LIST.]
	PUSHJ	P,SVMOT2	;O/P MSG. & ADD CRLF & SET ERRHOM

;HERE WHEN UNIT READ IS THE LAST IN THE ACTIVE SWAPPING LIST

LSTASL:	ANDI	P4,7		;MAX. OF 8 UNITS IN ASL AT PRESENT!!!!!!!!!!!!
	MOVEM	P4,SWPUNM	;STORE LOG. # OF LAST UNIT IN ASL
	AOS	SWPUNM		;MAKE IT # OF UNITS IN ASL

;HERE WHEN UNIT READ IS NOT LAST IN THE ACTIVE SWAPPING LIST
; LINK UNIT TO OTHER UNITS IN ASL & STORE ITS DB ADR IN SWPTAB.

NOTLSL:	MOVEI	T4,SWPUNI	;GET ADR. OF LINK TO 1ST UNIT DB IN ASL
	JRST	SINKT1
SINKIT:	MOVE	T3,UNISUN(T1)	;GET LOG. UNIT # OF NEXT UNIT IN ASL
	CAMLE	T3,P4		;IS IT GREATER THAN UNIT JUST READ?
	JRST	INSENT		;YES - INSERT UNIT DB HERE
	MOVEI	T4,UNISWP(T1)	;GET ADR. OF LINK TO NEXT UNIT
SINKT1:	HLRZ	T1,(T4)		;GET ADR. OF NEXT UNIT DB IN ASL
	JUMPN	T1,SINKIT	;MORE DATA BLOCKS?
INSENT:	HRLM	T1,UNISWP(U)	;SAVE LINK TO NEXT UNIT DB
	HRLM	U,(T4)		;SAVE THIS UNIT ADR. IN PREVIOUS UNIT DB
				; (OR SWPUNI)
	MOVEM	U,SWPTAB(P4)	;PUT THIS UNIT DB ADR. IN ASL

;HERE WHEN UNIT READ IS NOT IN THE ACTIVE SWAPPING LIST

NOTISL:	JUMPE	P2,NTISTR	;IF UNIT NOT IN STR, JUMP OVER THIS.
	LDB	T2,UNYLUN	;GET LOGICAL UNIT # WITHIN STR
	SKIPE	%HOM+HOMNXT	;IS THIS LAST UNIT IN STR?
	JRST	NLSUNI		;NO - GO LINK UNIT DATA BLOCK INTO STR
	HRRZ	T1,STRUNM(P2)	;HAVE WE ALREADY SEEN A LAST UNIT FOR THIS STR?
	JUMPE	T1,LSTUNI	;NO - NOW WE HAVE
	PUSH	P,T2		;SAVE LOG. UNIT #
	MOVEI	T1,[ASCIZ .
MORE THAN ONE LAST UNIT IN STR .]
	PUSHJ	P,MSGSTR	;PRINT MSG FOLLOWED BY SIXBIT STR NAME
	POP	P,T2		;RESTORE LOG. UNIT #

;HERE WHEN UNIT READ IS THE LAST IN A STR.

LSTUNI:	ANDI	T2,77		;MAX. OF 64 UNITS IN STR!!!!!!!
	HRRM	T2,STRUNM(P2)	;STORE LOG. # OF LAST UNIT IN STR
	AOS	STRUNM(P2)	;LEAVE T2 ALONE BUT MAKE MEMORY OK

;HERE WHEN UNIT READ ISN'T LAST IN THE STR
; LINK UNIT TO STR & OTHER UNITS IN STR

NLSUNI:	MOVEI	T4,STRUNI(P2)	;GET ADR. OF LINK TO 1ST. UNIT DATA BLOCK IN STR
	JRST	LINKT1
LINKIT:	LDB	T3,UNYLN1	;YES - GET LOG. UNIT # OF NEXT UNIT
	CAMLE	T3,T2		;IS IT GREATER THAN UNIT JUST READ?
	JRST	INSERT		;YES - INSERT UNIT DATA BLOCK HERE
	MOVEI	T4,UNISTR(T1)	;GET ADR. OF LINK TO NEXT UNIT
LINKT1:	HLRZ	T1,(T4)		;GET ADR. OF NEXT UNIT DATA BLOCK IN STR
	JUMPN	T1,LINKIT	;MORE DATA BLOCKS?
INSERT:	HRLM	T1,UNISTR(U)	;SAVE LINKS TO STR & NEXT UNIT DATA BLOCK
	HRRM	P2,UNISTR(U)	; IN THIS UNIT DATA BLOCK
	HRLM	U,(T4)		;SAVE THIS UNIT ADR. IN PREVIOUS UNIT DATA BLOCK
				; (OR STR DATA BLOCK)
	JRST	CRESTT		;TRY & SETUP SAB RING & SPT TABLE FOR THIS UNIT

NOSTR:	MOVEI T1,[ASCIZ /
TOO MANY STR'S /]
	PUSHJ P,OCONM
	MOVE	T2,%HOM+HOMSNM
	PUSHJ P,NAMFLO
	STOPCD



NTISTR:	SETZM	UNILOG(U)	;INDICATE UNIT NOT IN A STR.

;HERE TO CREATE STT TABLE AND SWAPPING SAT TABLE FOR THIS UNIT.
;(EVEN IF NOT IN STR, MAY ADD TO STR LATER.).

CRESTT:	PUSHJ	P,SPUCLC	;CALC NO. SATS ON UNIT.
	LDB	P3,UNYSPU	;
	IMULI	P3,STTLEN	;COMPUTE LENGTH OF
	ADDI	P3,1		;STT TABLE.
	LDB	T2,UNYP4S	;COMPUTE THE NO. OF
	ADDI	T2,^D35		;WORDS NEEDED FOR THE SAT
	IDIVI	T2,^D36		;FOR THE SWAPPING SPACE.
	MOVN	T1,T2		;MAKE LENGTH -VE FOR AOBJN WORD
	HRLM	T1,UNIPTR(U)	;STORE IT IN UNIT DATA BLOCK.
	ADD	T2,P3		;GET TOTAL NO. OF WORDS NEEDED
	PUSHJ	P,CORGRB	;FOR BOTH STT AND SWPNG SAT TBL.
	HRRM	T1,UNISTT(U)	;STORE ADR OF STT IN UNIT DB.
	SETZM	(T1)		;
	HRLZI	T2,(T1)		;BUILD A
	HRRI	T2,1(T1)	;BLT AC.
	ADDI	T1,-1(P3)	;ADR OF LAST WORD IN STT TABLE.
	BLT	T2,(T1)		;CLEAR THE STT.
	ADDI	T1,1		;ADR OF SWAPPING SAT TABLE TO
	HRRM	T1,UNIPTR(U)	;UNIT DB FOR AOBJN WORD.


SCNUN1:	HLRZ	U,UNISYS(U)	;GET NEXT UNIT DB ADR IN SYSTEM.
	JUMPN	U,SCNUNI	;AROUND AGAIN IF ANY LEFT




    ;HERE TO CREATE UNTTBL.
	SETZM	UNTTBL		;CLEAR OUT
	MOVE	T1,[UNTTBL,,UNTTBL+1] ;ALL OF
	BLT	T1,UNTTBL+UNTLEN-1 ;UNTTBL.

	HLRZ U,SYSUNI		;GET SET TO GENERATE UNTTBL
	MOVEI T1,UNTLEN-1
SETUNT:	JUMPE U,CHKASL	;DONE
	SKIPE UNILOG(U)		;IS IT IN A STR?
	JRST SETUTS		;YES
	MOVEM U,UNTTBL(T1)
	DPB T1,UNYLUN
	HLRZ U,UNISYS(U)
	SOJA T1,SETUNT		;AND GO

SETUTS:	LDB T2,UNYLUN
	MOVEM U,UNTTBL(T2)
	HLRZ U,UNISYS(U)
	JRST SETUNT

;HERE WHEN ALL UNITS IN SYSTEM HAVE TRIED TO BE READ
; NOW CHECK THAT THE ACTIVE SWAPPING LIST LOOKS CORRECT

CHKASL:	HLRZ	U,SWPUNI	;GET ADR. OF 1ST. UNIT DATA BLOCK IN ASL
	JUMPN	U,SOMUSL	;ARE THERE ANY UNITS IN ASL?
	MOVEI	T1,[ASCIZ .
NO UNITS IN ACTIVE SWAPPING LIST.]
	PUSHJ	P,SVMOT2	;O/P MSG. & ADD CRLF & SET ERRHOM
	JRST	SCNSTR		;GO CHECK STRS

;HERE WHEN THERE IS AT LEAST ONE UNIT IN ASL

SOMUSL:	MOVEI	T1,[ASCIZ .LAST UNIT IN ACTIVE SWAPPING LIST NOT FOUND.]
	SKIPN	SWPUNM		;LAST UNIT IN ASL FOUND?
	PUSHJ	P,SVMOTE	;NO - O/P MSG. & ADD CRLF & SET ERRHOM
	SETOM	P4		;SETUP FAKE PREVIOUS LOGICAL UNIT #
CHKUSL:	MOVE	P1,UNISUN(U)	;GET LOG. UNIT # IN ASL OF THIS UNIT
	EXCH	P1,P4		;PUT THIS & PREVIOUS LOG. UNIT #'S IN PROPER ACS
	CAME	P4,P1		;ARE LOG. UNIT #'S THE SAME
	JRST	MISUSL		;NO - SEE IF ANY LOG. UNITS MISSING FROM ASL
	MOVEI	T1,[ASCIZ .
TWO LOGICAL UNIT .]
	PUSHJ	P,TYPMSN	;TYPE MSG. FOLLOWED BY A DECIMAL #
	MOVEI	T1,[ASCIZ .'S FOUND IN ACTIVE SWAPPING LIST.]
	PUSHJ	P,SVMOTE	;O/P MSG. & ADD CRLF & SET ERRHOM
	JRST	CHKUS1		;CHECK NEXT PAIR OF UNITS

MISUSL:	CAIN	P4,1(P1)	;IS THIS UNIT 1 GREATER THAN PREVIOUS UNIT
	JRST	CHKUS1		;YES - CHECK NEXT PAIR OF UNITS
	ADDI	P1,1		;INCREMENT TO GET CORRECT MISSING LOG. UNIT #
	MOVEI	T1,[ASCIZ .
LOGICAL UNIT .]
	PUSHJ	P,TYPMSN	;TYPE MSG. FOLLOWED BY A DECIMAL #
	MOVEI	T1,[ASCIZ . MISSING FROM ACTIVE SWAPPING LIST.]
	PUSHJ	P,SVMOTE	;O/P MSG. & ADD CRLF & SET ERRHOM
	JRST	MISUSL		;REPEAT UNTIL ALL MISSING ARE TYPED OUT

CHKUS1:	HLRZ	U,UNISWP(U)	;GET ADR. OF NEXT UNIT DATA BLOCK IN ASL
	JUMPN	U,CHKUSL	;REPEAT IF ANY LEFT

;HERE WHEN ALL UNITS IN SYSTEM HAVE TRIED TO BE READ &
; THE STR DATA BLOCK HAS BEEN CREATED IF IT CAN BE.  NOW
; CHECK THAT ALL UNITS THAT SHOULD BE ARE PRESENT IN THE STR.

SCNSTR:	MOVEI	P2,STRDDB	;GET ADR. OF STR DATA BLOCK.
	SKIPN	STRNAM(P2)	;IS THERE A STR?
	JRST	SCNSTD		;NO, NON-SKIP RETURN
	HRRZ	T1,STRUNM(P2)
	JUMPN	T1,LSTRED	;WAS THE LAST UNIT IN THIS STR FOUND?
	MOVEI	T1,[ASCIZ .
LAST UNIT WASN'T FOUND IN STR .]
	PUSHJ	P,MSGSTR	;NO - PRINT MSG. FOLLOWED BY SIXBIT STR NAME
	HLRZ	U,STRUNI(P2)	;GET ADR. OF 1ST. UNIT DATA BLOCK IN STR
	JRST	.+2		;
SCNST2:	MOVE	U,T1
	HLRZ	T1,UNISTR(U)	;GET ADR. OF NEXT UNIT DATA BLOCK IN STR
	JUMPN	T1,SCNST2	;REPEAT UNTIL LAST ONE FOUND
	LDB	T1,UNYLUN	;GET ITS LOG. UNIT # IN STR
	ADDI	T1,1		;MAKE INTO # UNITS IN STR
	HRRM	T1,STRUNM(P2)	; & STORE IT

;HERE TO CHECK FOR THE PRESENCE OF ALL UNITS BUT THE LAST IN A STR.

LSTRED:	HLRZ	U,STRUNI(P2)	;GET ADR. OF 1ST. UNIT DATA BLOCK IN THIS STR
	SETOM	P4		;SETUP FAKE PREVIOUS LOG. UNIT #
CHKUNI:	LDB	P1,UNYLUN	;GET LOG. UNIT # OF THIS UNIT WITHIN STR
	EXCH	P1,P4		;PUT THIS & PREVIOUS LOG. UNIT #'S IN PROPER ACS
	CAME	P4,P1		;ARE LOG. UNIT #'S THE SAME?
	JRST	MISUNI		;NO - CHECK FOR MISSING UNITS
	MOVEI	T3,[ASCIZ .
TWO LOGICAL UNIT .]
	MOVEI	T1,[ASCIZ .'S FOUND IN STR .]
	PUSHJ	P,MSGLNG	;PRINT MSGS FOLLOWED BY SIXBIT STR NAME
	JRST	CHKUN1		;CHECK NEXT PAIR OF UNITS

MISUNI:	CAIN	P4,1(P1)	;IS THIS UNIT 1 GREATER THAN LAST ONE?
	JRST	CHKUN1		;YES - CHECK NEXT PAIR OF UNITS
	ADDI	P1,1		;INCREMENT TO GET CORRECT MISSING LOG. UNIT #
	MOVEI	T3,[ASCIZ .
LOGICAL UNIT .]
	MOVEI	T1,[ASCIZ . MISSING FROM STR .]
	PUSHJ	P,MSGLNG
	JRST	MISUNI		;REPEAT UNTIL ALL MISSING ARE TYPED OUT

CHKUN1:	HLRZ	U,UNISTR(U)	;GET ADR. OF NEXT UNIT DATA BLOCK IN STR
	JUMPN	U,CHKUNI
	JRST	SCNSD2

;HERE WHEN THROUGH CHECKING ALL UNITS WITHIN A STR.

SCNSTD:	MOVEI	T1,[ASCIZ .
?NO SYSTEM STRUCTURE.]
	PUSHJ	P,SVMOT2	;NO, TYPE MESSAGE
SCNSD2:	SKIPE	ERRHOM		;ANY ERRORS?
	AOS	(P)		;NO - SKIP RETURN
	SKIPE ERRHM2
	AOS (P)
	POPJ	P,

ERRHOM:	0			;FLAG FOR ERRORS WHILE READING A HOME PAGE.
ERRHM2:	0			;"BAD" ERROR DETECTED.

SWPUNM:	0			;# OF UNITS IN ACTIVE SWAPPING LIST - 0 MEANS:-
				; 1)EMPTY LIST OR 2)LAST UNIT IN LIST NOT YET READ

INTERN RANNO
RANNO: Z

WRPUNM:	MOVEI	T4,[ASCIZ . IS WRITE PROTECTED.]

	MOVE	P1,UNINAM(U)	;GET SIXBIT UNIT NAME
	MOVEI	T1,[ASCIZ .
.]
	PJRST	NASTYP		;TYPE MSGS. & GET USER'S RESPONSE

;SUBROUTINE TO PRINT "CONTROLLER" FOLLOWED BY A "NAME" FOLLOWED BY "IS OFF-U"
; FOLLOWED BY A MESSAGE ASKING WHAT STATE OF THE KONTROLLER IS DESIRED
; THEN IT WAITS FOR OPERATOR TO TYPE AN OCTAL NUMBER TERMINATED BY CRLF
;CALL	MOVE	P1,SIXBIT KONTROLLER NAME
;	MOVEI	T3,MSG. ADR.
;	PUSHJ	P,MCKKON
;	  ERROR RETURN	MSG. PRINTED BUT RESPONSE WASN'T AN OCTAL #
;	OK RETURN	 "      "    T2 CONTAINS OCTAL # TYPED

MCKKON:	MOVEI	T1,[ASCIZ .
.]
	MOVEI	T4,[ASCIZ . IS OFF-LINE.]
NASTYP:	JSP	T2,SVOTAC	;SAVE P4,F,U & J
	PUSH	P,T3		;SAVE 2ND. MSG ADR.
	PUSH	P,T4		;SAVE 1ST. MSG. ADR.
	PUSHJ	P,OCONM		;PUT MSG IN BUFFER
	MOVE	T2,P1		;GET UNIT/KONTROLLER SIXBIT NAME
	PUSHJ	P,PRNAME	;PUT IT IN BUFFER
	POP	P,T1		;RESTORE 1ST. MSG. ADR.
	PUSHJ	P,CONMES	;PUT MSG. IN BUFFER
	PUSHJ	P,CRLFOP	;ADD CRLF & O/P MSG.
	POP	P,T1		;RESTORE 2ND. MSG ADR.
	PUSHJ	P,CONOUT	;O/P MSG. & ADD CRLF
	PUSHJ	P,GETLIN	;GET USER'S RESPONSE
	  POPJ	P,		;CR TYPED
	PUSHJ	P,OCTIN		;READ IT AS AN OCTAL NO.
	  POPJ	P,		;NOTHING BUT A BREAK CH.
	  POPJ	P,		;ILLEGAL CH.
	JRST	CPOPJ1		;OK RETURN WITH NO. IN T2

UNTDWN:	JSP T2,SVOTAC
IFKMC<
	MOVE T1,UNIBLK(U)
	CAIGE T1,4		;IF NO RESPONSE DON'T GIVE MESSAGE
	  POPJ P,
>;END.IFKMC
	MOVEI T1,[ASCIZ .
.]
	PUSHJ P,CONMES
	MOVE T2,UNINAM(U)
	PUSHJ P,PRNAME
	MOVEI T1,[ASCIZ . IS OFF-LINE.]
	PUSHJ P,CONOUT
	MOVE T1,UNIBLK(U)
	SKIPE T1,OFLTAB(T1)
	PJRST CONOUT
	POPJ P,

	%%ZZQ==.
OFLTAB:	PHASE 0
	0
%OFLER:! [ASCIZ /ERROR INDICATIONS/]
%OFLFM:! [ASCIZ /INCORRECT FORMAT/]
%OFLMT:! [ASCIZ /MAINT. MODE/]
%OFLRS:! [ASCIZ /NO RESPONSE./]
	PHASE .+%%ZZQ

INTERNAL %OFLER,%OFLFM,%OFLMT,%OFLRS

COMMENT #
@@SUBROUTINE FNDSTR
@@PURPOSE
SUBR TO SET UP THE STR DB ADDRESS IN P2 IF THE STR HAS THE
SIXBIT NAME IN T1.
@@ENTRY
EXPECTS SIXBIT STR NAME IN T1.
@@ACCUM
DESTROYS T1 AND P2.
@@EXIT
NON-SKIP RETURNS ONLY IF THE SYSTEM STR HAS BEEN SET UP AND IT
HAS THE NAME IN T1.  ELSE SKIP RETURNS.
@@ #

FNDSTR:	MOVEI	P2,STRDDB	;GET ADDR OF STR DB TO P2.
	TRZ	T1,7777		;STR NAMES ARE A MAX OF 4 CHARS.
	CAME	T1,STRNAM(P2)	;
	AOS	(P)		;
	POPJ	P,



;SUBROUTINE TO GRAB CORE FOR THE ONCE ONLY CODE
; ENTER WITH T2 = # WORDS TO GRAB IN UPPER CORE
; RETURN WITH T1 = ADR. OF THE GRABBED CORE
; & T2 = ADR. OF 1ST. FREE WORD

CORGRB:	MOVE	T1,HICORE
	ADDB	T2,HICORE
	POPJ	P,

;SUBROUTINE TO MOVE PARAMETERS FROM HOME PAGE TO UNIT DATA BLOCK

MOVUNI:	MOVE	T1,%HOM+HOMLOG
	MOVEM	T1,UNILOG(U)
	MOVE	T1,%HOM+HOMHID
	MOVEM	T1,UNIHID(U)
	MOVE	T1,%HOM+HOMLUN
	DPB	T1,UNYLUN
	MOVE	T1,%HOM+HOMSUN
	MOVEM	T1,UNISUN(U)
	MOVE	T1,%HOM+HOMSLB
	MOVEM	T1,UNISLB(U)
	MOVE	T1,%HOM+HOMP4S
	DPB	T1,UNYP4S
	MOVE	T1,%HOM+HOMCFS
	DPB	T1,UNYCFS
	MOVE	T1,%HOM+HOMSPU
	DPB	T1,UNYSPU
	MOVSI	T2,UNPMSB
	ANDCAM	T2,UNIDES(U)
	CAIE	T1,1
	IORM	T2,UNIDES(U)
	POPJ	P,

;SUBROUTINE TO MOVE PARAMETERS FROM HOME PAGE TO STR DB.

MOVSTR:	MOVE	T1,%HOM+HOMSNM
	MOVEM	T1,STRNAM(P2)
	MOVE	T1,%HOM+HOMP4C
	MOVEM	T1,STRP4C(P2)
	MOVE	T1,%HOM+HOMMFD	;SAVE RETRIEVAL
	TLO	T1,RBREAL	;POINTER TO
	MOVEM	T1,MFDRIB	;MFD (IT'S ON UNIT 0).
	MOVE	T1,UNIPPU(U)
	CAMLE	T1,STRPPU(P2)
	MOVEM	T1,STRPPU(P2)
	MOVE	T1,%HOM+HOMOVR
	MOVEM	T1,STROVR(P2)
	MOVE	T1,%HOM+HOMREF
	HLLM	T1,STRREF(P2)
	POPJ	P,

MSGLNG:	JSP	T2,REFSAV	;SAVE P4,T3,F,U & J AND INDICATE STR NEEDS REFRESHING
	PUSH	P,T1		;SAVE 2ND. MSG ADR. IN T1
	MOVE	T1,T3		;GET ADR OF 1ST. MSG
	PUSHJ P,CLRSND
	PUSHJ	P,TYPDEC	;PUT MSG. & UNIT # IN BUFFER
	PUSHJ	P,OPOUT		;O/P BUFFER
	POP	P,T1		;RESTORE 2ND. MSG ADR.
	CAIA

MSGSTR:	JSP	T2,REFSAV	;SAVE P4,T3,F,U & J AND INDICATE STR NEEDS REFRESHING
	PUSHJ	P,OCONM		;PUT MSG. IN BUFFER
	SETOM	ERRHOM		;INDICATE ERROR IN "RDHOME"
	SETOM ERRHM2		;"BAD" ERROR
	MOVE	T2,STRNAM(P2)	;GET SIXBIT STR NAME
NAMFLO:	PUSHJ	P,PRNAME	;PUT IT IN THE BUFFER FOLLOWED BY CRLF & START O/P
	PJRST	CRLFOP


MSGUNI:	JSP	T2,REFSAV
	PUSH	P,UNINAM(U)
	PUSHJ	P,OCONM
	SETOM	ERRHOM
	SETOM	ERRHM2
	POP	P,T2
	PJRST	NAMFLO

COMMENT #
@@SUBROUTINE GETHOM
@@PURPOSE
SUBR TO TRY TO READ BOTH OF A UNIT'S HOME PAGES SUCCESSFULLY
INTO %HOM.
@@ENTRY
EXPECTS U/ UNIT DB AND F/ DDB.
PRINTS NO ERROR MESSAGES IF NOERH <> 0.
@@ACCUM
DESTROYS
@@EXIT
SKIP RETURNS IF AT LEAST ONE OF THE PAGES READ SUCCESSFULLY.
@@ #

GETHOM:	MOVSI	P2,(SIXBIT .HOM.)
	MOVE	P3,[EXP CODHOM]	;CODE WORD FOR HOME PAGES.
	MOVE	P4,[LPNHOM,,LP2HOM] ;P4/ NO. 1ST PAGE,,2ND PAGE.
	MOVEI	PG,%HOM.P
	PJRST	RDBOTH		;READ & VERIFY HOME PAGES.




COMMENT #
@@SUBROUTINE GETBAT
@@PURPOSE
SUBR TO TRY TO READ BOTH OF A UNIT'S BAT PAGES SUCCESSFULLY
INTO %BAT.
@@ENTRY
EXPECTS U/ UNIT DB AND F/ DDB.
PRINTS NO ERROR MESSAGES IF NOERH <> 0.
@@ACCUM
DESTROYS
@@EXIT
SKIP RETURNS IF AT LEAST ONE OF THE PAGES READ SUCCESSFULLY.
@@ #

GETBAT:	PUSHJ	P,SETBAT	;
	PJRST	RDBOTH		;




COMMENT #
@@SUBROUTINE SETBAT
@@PURPOSE
LITTLE SUBR TO SET UP SOME PARAMETERS FOR HANDLING BAT PAGES.
@@ #

SETBAT:	MOVSI	P2,(SIXBIT .BAT.)
	MOVE	P3,[EXP CODBAT]
	MOVE	P4,[XWD LPNBAT,LP2BAT]
	MOVEI	PG,%BAT.P	;
	POPJ	P,

COMMENT #
@@SUBROUTINE RDBOTH
@@PURPOSE
SUBROUTINE TO READ SPECIAL REDUNDANT PAGES ON THE DISK (HOME
AND BAT) INTO CORE.
@@ENTRY
EXPECTS U/ UNIT DB, P2/ SIXBIT BAT, HOM, OR SAT, P3/ AP-
PROPRIATE CODE WORD FOR PAGES, P4/ PAGE NO. ON THE
DISK OF 1ST PAGE,, 2ND PAGE, AND PG/ PCB ADDRESS.
PRINTS NO ERROR MESSAGES IF NOERH <>0.
@@ACCUM
DESTROYS
@@CALLS
RDCHEK.
@@EXIT
NON-SKIP RETURNS ONLY IF BOTH PAGES ARE BAD.
T3/ 0 IF NO ERRORS, O'E LH(T3)<>0 IF ERROR ON 1ST PAGE AND
RH(T3)<>0 IF ERROR ON 2ND PAGE.
S=0 IF NO ERRORS, ELSE S HAS THE STANDARD RH ERROR BITS SET.
NOERH = 0 ON EXIT.
@@ #

RDBOTH:	MOVE	F,DDSTAR	;F/ DDB.
	SETZM	REDERR		;CLEAR ERR FLAG FOR BOTH PAGES.
FIROK:	SETOM	WHICH		;INDICATE READING 1ST PAGE.
	HLRZ	T4,P4		;T4/ DISK PAGE NO.
	PUSHJ	P,RDCHEK	;READ PAGE & CHECK FOR ERRORS.
	JRST	REDSEC		;ERR DETECTED - GO TRY 2ND PAGE.
	JUMPG	T3,RDBSKP	;NO ERR. JUMP TO SUCCESS IF WE
				;ARE HERE FROM A BAD 2ND PAGE.

REDSEC:	SETZM	WHICH		;INDICATE READING 2ND PAGE.
	HRRZ	T4,P4		;T4/ DISK PAGE NUMBER.
	PUSHJ	P,RDCHEK	;READ PAGE & CHECK FOR ERRORS.
	JUMPL	T3,RDBNON	;ERROR(S) DETECTED.  IF ON 1ST
				;PAGE AS WELL, GIVES ERR RETURN.
	JUMPG	T3,FIROK	;IF 2ND BAD 1ST OK GO RETRY 1ST.
RDBSKP:	AOS (P)			;SET FOR SKIP RETURN.
RDBNON:	SETZM NOERH		;CLR NO ERR MSG FLAG.
	POPJ P,

COMMENT #
@@SUBROUTINE RDCHEK
@@PURPOSE
SUBR CALLED BY RDBOTH AND OTHERS TO READ A SPECIAL PAGE
INTO CORE AND CHECK FOR ERRORS.
@@ENTRY
EXPECTS  T4/ PAGE NO. ON UNIT, F/ FILE DB, PG/ PCB ADDRESS,
U/ UNIT DB, P2/ SIXBIT BAT, HOM, OR
SAT, AND P3/ CODE WORD FOR PAGES.
WHICH <>0 FOR FIRST PAGE, =0 FOR 2ND.
PRINTS NO ERROR MESSAGES IF NOERH <> 0.
@@CALLS
OPAGIN AND RDWMSG.
@@ACCUM
DESTROYS
@@EXIT
FOR 1ST PAGE, LH(T3)=0 UNLESS ERROR, IN WHICH CASE LH(T3)<>0.
FOR 2ND PAGE, RH(T3)=0 UNLESS ERROR, IN WHICH CASE RH(T3)<>0.
NON-SKIP RETURN IF ERROR, ELSE SKIP-RETURN.
IF NO ERROR, S=0 ELSE S HAS RH ERROR BITS SET.
@@ #

RDCHEK:	SETZM	CHKFLG		;CLR FLG FOR USE OF RDCHEK ONLY
				;(NEEDED SINCE S ACCUMULATES.).
	PUSHJ	P,OPAGIN	;READ THE PAGE.
	SKIPA	T3,UNINAM(U)	;ERROR	- GET SIXBIT UNIT NAME.
	JRST	CONCHK		;GO MAKE CONSISTANCY CHECKS.
IFCPU (KI),<DATAO	PI,UNIERR(U)>	;FLASH OPER WITH KONT. STATUS.
	MOVEI	T1,[ASCIZ . PAGE HARDWARE READ ERROR.]
	PUSHJ	P,RDWMSG	;PRINT ERROR MSG. FOR PAGE TYPE.
	SETOM	CHKFLG		;SAW ERROR ON THIS PAGE.
CONCHK:	PUSHJ	P,GETPEV	;GET VIRTUAL ADDR FOR PCB IN PG IN T2
	CAMN	P2,[SIXBIT /SAT/] ;READING SAT.SYS RIB PAGE?
	CAME	P2,RIBNAM(T2)	;YES. NAME IN RIB = 'SAT'?
	CAMN	P2,PAGNAM(T2)	;NO - CHECK BLOCK NAME(THIS ALWAYS FAILS WITH RIB)
	CAME	P3,PAGCOD(T2)	;OK - CHECK CODE WORD
	SKIPA	T3,UNINAM(U)	;NO CHECK - GET SIXBIT UNIT NAME
	JRST	TSTCHK		;EXIT CHECKING ERRORS ON THE WAY
	MOVEI	T1,[ASCIZ . PAGE CONSISTENCY ERROR.]
	PUSHJ	P,RDWMSG	;PRINT ERROR MSG. FOR PAGE TYPE
	SETOM	CHKFLG		;SAW ERROR ON THIS PAGE.
TSTCHK:	MOVE	T3,REDERR	;ERR WRD FOR CHECKING BY CALLER.
	SKIPN	CHKFLG		;SKIP RETURN IF
	AOS	(P)		;NO ERRORS.
	POPJ	P,

CHKFLG: Z	;FLAG FOR USE BY RDCHEK ONLY.

COMMENT #
@@SUBROUTINE WTBOTH
@@PURPOSE
SUBR TO WRITE SPECIAL REDUNDANT PAGES TO THE DISK (HOM
AND BAT) FROM CORE.
@@ENTRY
EXPECTS F/ FILE DB, U/ UNIT DB, P4/ PAGE NO. ON
DISK OF 1ST PAGE,, 2ND PAGE, AND PG/ PCB ADDRESS.
PRINTS NO ERROR MESSAGES IF NOERH <> 0.
@@ACCUM
DESTROYS
@@CALLS
OPAGOT AND RDWMSG.
@@EXIT
RETURNS WITH S = 0 IF NO ERRORS. OTHERWISE S HAS STANDARD
RH ERROR BITS SET.
T3/ 0 IF NO ERRORS, OTHERWISE RH(T3)<>0 IF ERROR ON 2ND PAGE 
AND LH(T3)<>0 IF ON 1ST PAGE.
@@ #

WTBOTH:	SETZM	REDERR		;CLR ERR SWITCH FOR BOTH PAGES.
	SETOM	WHICH		;INDICATE WRITING 1ST PAGE.
	PUSHJ	P,GETPEV	;GET VIRTUAL ADDRESS OF DATA FROM C(PG)
	MOVE	P1,T2		;GET IN MORE PERMANENT PLACE THAN T2

WRTRN1:	LDB T1,UNYLUN	;ALSO WORKS FOR ONES NOT IN STR
	MOVSI	T2,RBREAL	;
	DPB	T1,RBYUNI	;
	HLRZ	T4,P4		;
	DPB	T4,RBYPNO	;
	MOVEM	T2,PAGSLF(P1)	;
	HRLZS	P4		;SETUP P4 FOR PAGE #2.
	PUSHJ	P,WTCHEK	;GO WRITE OUT PAGE.
	SETZM	WHICH		;INDICATE WRITING 2ND PAGE.
	JUMPN	P4,WRTRN1	;HAVE WE WRITTEN BOTH PAGES?
	SKIPN	T3,REDERR	;ERR WRD FOR CHECKING BY CALLER.
	AOS	(P)		;SKIP RETURN IF NO ERRORS.
	POPJ	P,		;

WTCHEK:	PUSHJ	P,OPAGOT	;TRY TO WRITE THE PAGE.
	JRST	.+2		;ERRORS.
	POPJ	P,		;WON.
IFCPU (KI),<DATAO	PI,UNIERR(U)>	;FLASH OP. WITH ERROR STATUS
	MOVEI	T1,[ASCIZ .HARDWARE WRITE ERROR.]
	MOVE	T3,UNINAM(U)	;PICK UP UNIT NAME AND PRINT
	PUSHJ	P,RDWMSG	;ERROR MSG. FOR PAGE TYPE.
	POPJ	P,

COMMENT #
@@SUBROUTINE RDWMSG
@@PURPOSE
SUBR TO PRINT ERROR MSG. FOR RDCHEK AND WTCHEK, AND TO SET
REDERR APPROPRIATELY.
(REDERR IS AN INTERNAL FLAG FOR RDBOTH AND WTBOTH.).
@@ENTRY
EXPECTS T1/ MSG. ADR. AND T3/ SIXBIT UNIT NAME.
IF NOERH <>0, DOES NOTHING AND RETURNS IMMEDIATELY.
@@ACCUM
DESTROYS
@@CALLS
SVOTAC, CLRSND, PRNAME, CONMES, AND CRLFOP.
@@EXIT
RETURNS LH. OR RH. OF REDERR = -1, DEPENDING ON WHETHER 1ST
OR 2ND PAGE, RESPECTIVELY, HAS ERROR.
@@ #

RDWMSG:	SKIPE	NOERH
	POPJ	P,		;DO NOT PRINT ERR MSG.
	JSP	T2,SVOTAC	;SAVE T3,F,U & J
	PUSH	P,PG		;SAVE PG.
	PUSH	P,T1		;SAVE ADDR OF MESSAGE
	PUSHJ	P,CLRSND
	MOVE	T2,T3		;SIXBIT UNIT NAME
	PUSHJ	P,PRNAME	;PUT NAME IN BUFFER
	MOVEI	T1,[ASCIZ . FIRST .] ;PRESUME ERROR ON 1ST PAGE.
	SKIPE	WHICH		;2ND. PAGE WAS READ?
	JRST	FSTERR		;NO - 1ST. PAGE.
	HLLOS	REDERR		;INDICATE ERROR ON 2ND. PAGE.
	SKIPA	T1,[[ASCIZ . SECOND .]]
FSTERR:	HRROS	REDERR		;INDICATE ERROR ON 1ST. PAGE.
	PUSHJ	P,CONMES	;PUT MSG. IN BUFFER
	MOVE	T2,P2		;GET SIXBIT PAGE TYPE(HOME OR "BAT")
	CAMN	P2,[SIXBIT .SAT.] ;IF THIS WAS A RIB PAGE
	MOVSI	T2,(SIXBIT .RIB.) ; TYPE RIB INSTEAD OF "SAT"
	PUSHJ	P,PRNAME	;PUT IT IN BUFFER
	POP	P,T1		;ADDR OF MESSAGE
	PUSHJ	P,CONMES	;PUT MSG. IN BUFFER
	PUSHJ	P,CRLFOP	;CRLF AND TYPE MESSAGE
	POP	P,PG		;RESTORE PG.
	POPJ	P,

REDERR:	0			;ERR WORD FOR RDBOTH AND WTBOTH.
				; RH=-1 IF ERROR ON 2ND. PAGE,
				; LH "  "    "   "  1ST.   "
WHICH:	0			;FLAG TO INDICATE WHETHER 2ND
				;OR 1ST PAGE BEING READ.

NOERH:	0			;FLAG TO NOT PRINT ERROR FROM UPDHOM.

COMMENT #
@@SUBROUTINE OPAGIN/OPAGOT
@@PURPOSE
ONCE-TIME SUBR TO READ OR WRITE A PAGE.
@@ENTRY
ENTRY POINT OPAGOT IS TO WRITE A PAGE, ENTRY POINT OPAGIN IS TO
READ A PAGE.
EXPECTS U/ UNIT DB, T4/ PAGE NUMBER ON THE UNIT,
PG/ ONCE-TIME PCB ADDRESS, AND F/ DDB.
@@ACCUM
DESTROYS T1-T4 AND S.
@@EXIT
SKIP RETURNS IF NO ERRORS, ELSE NON-SKIP RETURNS AND T3 HAS
THE PGYERR BITS.
@@ #

    ;HERE TO READ A PAGE.
OPAGIN:	MOVEI	T3,PAGIN	;FILIO SUBR TO CALL.
	MOVEI	T1,STDREA
	JRST	OPAGIO

    ;HERE TO WRITE A PAGE.
OPAGOT:	MOVEI	T3,PAGOUT	;FILIO SUBR TO CALL.
	MOVEI	T1,STDWRT

OPAGIO:	PUSH	P,PG		;SAVE PG.
	MOVE	T2,PG		;SET UP T2/ PCB ADDR AND
	DPB	T1,PCISTS	;SET FLAG FOR INTRPT LEVEL.
	HLRZ	PG,PCBPAG(T2)	;PG/ IN-CORE PAGE NUMBER.
	SETZ	T1,		;CLEAR ANY
	DPB	T1,PGYERR	;ERROR BITS.
	PUSHJ	P,OHTINI	;CLEAR OUT ALL OUTPUT ERRORS (SHOULD BE 1 AT THE MOST.)
	DPB	T4,PGYPNO	;SET THE "UNIT NUMBER" AND
	LDB	T1,UNYLUN	;PAGE NUMBER IN PGYADR.
	CAME	U,UNTTBL(T1)	;STRANGE CROCK TO
	MOVEM	U,UNTTBL(T1)	;HELP SWPENQ AND FINPCB, WHICH
	DPB	T1,PGYUNI	;EXPECT UNTTBL TO BE SET UP.
	PUSH	P,T2		;SAVE PCB ADDR.
	PUSHJ	P,(T3)		;CALL PAGIN OR PAGOUT.
	POP	P,T2		;RESTORE PCB ADDRESS.
	LDB	T3,PCISTS	;WAIT FOR
	TRNE	T3,STDWRT!STDREA ;THE INTRPT ON COMPLETION TO
	JRST	.-2		;HAPPEN.
	LDB	T3,PGYERR	;GET ERRORS.
	POP	P,PG		;RESTORE PG/ PCB ADDR.
	SKIPN	OHTNUM		;SKIP IF GOT AN OUTPUT ERROR.
	JUMPE	T3,CPOPJ1	;SKIP RETURN IF NO ERRORS
	POPJ	P,		;
;CHECK ON DISK CAPACITY
DEFINE DSKOFF<WRPI DSKPIF##>
DEFINE DSKON<WRPI DSKPIN##>


DSKCPY:	HRRZ J,UNIKON(U)
	SKIPE UNISTS(U)	;MUST BE IDLE
	POPJ P,		;OR JUST RETURN
	SKIPGE KONLTM(J)	;DOES NOT USE CHANNEL
	JRST CPYNOW	;THEN CAN DO IT NOW
	MOVEI T1,CWCOD	;SET TO CPY WAIT
	MOVEM T1,UNISTS(U)
	PUSHJ P,IOSEL	;START IT GOING
	PJRST CPYWAT	;AND WAIT FOR IT TO FINISH

CPYNOW:	MOVEI T1,CCOD
	MOVEM T1,UNISTS(U)
	DSKOFF
	HRRZ T1,KONCPY(J)
	PUSHJ P,(T1)
	DSKON
CPYWAT:	SKIPE UNISTS(U)	;DONE?
	JRST .-1		;NO.
	POPJ P,

;SUBROUTINE TO EXECUTE AN INSTRUCTION FOR ALL UNITS WITHIN A STR.
; USUALLY STORES A BYTE
;T1=INSTRUCTION TO BE EXECUTED, P1=ARG., P2=STR DATA BLOCK ADR.

STOUNI:	HLRZ	U,STRUNI(P2)
	PUSH	P,T1
STOUN1:	XCT	(P)		;EXECUTE INSTRUCTION SUPPLIED IN AC T1
	HLRZ	U,UNISTR(U)
	JUMPN	U,STOUN1
	JRST	TPOPJ






DECLOP:	JSP	T2,SVOTAC
	PUSHJ	P,TYPDEC
	PJRST	CRLFOP

TYPMSN:	JSP	T2,SVOTAC	;SAVE P4,F,U & J
	PUSHJ P,CLRSND
	PUSHJ	P,TYPDEC	;PUT MSG. IN THE BUFFER FOLLOWED BY DECIMAL #
	PJRST	OPOUT		;O/P THE BUFFER

TYPDEC:	PUSHJ	P,CONMES
	MOVE	T1,P1
	PJRST	RADX10




SPSNAM:	SKIPA	T2,STRNAM(P2)
SPUNAM:	MOVE	T2,UNINAM(U)
	PJRST PRNAME

SVMOT2:	SETOM ERRHM2
SVMOTE:	SETOM	ERRHOM
	PUSHJ P,CLRSND
SVMOUT:	JSP	T2,SVOTAC
CONOUT:	PUSHJ	P,CONMES
CRLFOP:	PUSHJ	P,CRLF
	PJRST	OPOUT

ASKQUE:	JSP	T2,SVOTAC	;SAVE P4,F,U & J
	PJRST	YESNO		;GET USER'S RESPONSE - SKIP RETURN IF 1ST.
				;T3="Y" NON SKIP RETURN IF ANYTHING ELSE TYPED



;T2 & T3 ARE RESPECTED

SETCHG:	MOVSI	T1,UNPCHG	;PREPARE TO FLAG HOME PAGES NEED REWRITING
	MOVSI	T4,UNPOFL!UNPHWP
	TDNN	T4,UNIDES(U)	;IS UNIT WRITE PROTECTED OR OFF-U?
	IORM	T1,UNIDES(U)	;SET UNPCHG FLAG
	POPJ	P,		;RETURN



;SUBR TO MARK A UNIT AS A PRIVATE/PUBLIC PACK.
SETPUB:	MOVSI	T3,UNPPRV	;
	ANDCAM	T3,UNIDES(U)	;
	POPJ	P,		;

SETPRV:	MOVSI	T3,UNPPRV	;
	IORM	T3,UNIDES(U)	;
	POPJ	P,		;
	

GETUNI:	PUSHJ	P,GETLIN	;GET USER'S RESPONSE
	  POPJ	P,		;JUST CR TYPED - NON SKIP RETURN
	PUSHJ	P,CTEXT		;GET SIXBIT UNIT NAME
	SETZM	U		;ASSUME "ALL" WAS TYPED
	HLRZ	T1,T2		;MAKE AC LOOK GOOD FOR COMPARE
	PUSHJ	P,FNDUNI	;SEE IF UNIT EXISTS & RETURN WITH UNIT DATA BLOCK
	  SKIPA	T1,[[ASCIZ .NOT A PHYSICAL UNIT-TRY AGAIN.]]
	JRST	CPOPJ1		;UNIT EXISTS - SKIP RETURN
	PUSHJ	P,SVMOUT	;ADD CRLF & O/P MSG.
	JRST	GETUNI		;TRY AGAIN

FNDUNI:	HLRZ	U,SYSUNI	;GET ADR. OF 1ST. UNIT DATA BLOCK IN SYSTEM
FNDUN1:	CAMN	T2,UNINAM(U)	;MATCH?
	JRST	CPOPJ1		;YES - SKIP RETURN
	HLRZ	U,UNISYS(U)	;GET NEXT UNIT DATA BLOCK ADR. IN SYSTEM
	JUMPN	U,FNDUN1	;REPEAT IF THERE IS ONE
	POPJ	P,		;NONE FOUND - NON SKIP RETURN

;SUBROUTINE TO PRESERVE AC'S P4,F,U & J

REFSAV:	HRROS	STRREF(P2)	;INDICATE STR NEEDS REFRESHING
SVOTAC:	PUSH	P,P4
	PUSH	P,T3
	PUSH	P,F
	PUSH	P,U
	PUSH	P,J
	PUSHJ	P,(T2)
	  CAIA
	AOS	-5(P)
	POP	P,J
	POP	P,U
	POP	P,F
	POP	P,T3
	POP	P,P4
	POPJ	P,

COMMENT #
@@SUBROUTINE REDBAT
@@PURPOSE
SUBR TO READ AND VERIFY THE BAT PAGES ON ALL UNITS IN THE SYSTEM
AND INITIALIZE THE IN-CORE SWAPPING SATS AND MARK THE BAD PAGES
IN THEM.
@@ENTRY
EXPECTS
@@CALLS
CHKBAT, SETSST, AND SCNBAT.
@@ACCUM
DESTROYS
@@ #

REDBAT:	HLRZ	U,SYSUNI	;GET ADR. OF 1ST UNIT DB IN THE SYSTEM.
	MOVSI	P4,UNPOFL
RDBAT1:	TDNE	P4,UNIDES(U)	;UNIT OFF-LINE?
	JRST	RDBAT6		;YES, GO READ NEXT BAT PAGE
	PUSHJ	P,CHKBAT	;NO - GO CHECK "BAT" PAGES FOR THIS UNIT
	  JFCL			;IGNORE ERRORS
	SKIPN	BATMAN		;SKIP IF IN MANDATORY PART.
	JRST	RDBAT6		;NO POINT IN DOING THIS
	MOVE	T2,UNIPTR(U)	;T2=AOBJN PTR TO SWAPPING SAT FOR THIS UNIT
	MOVE	T1,T2		;
	LDB	T3,UNYP4S	;T3=PAGES FOR SWAPPING ON UNIT.
	JUMPE	T3,RDBAT4	;
	IDIVI	T3,^D36		;T3=FULL WORDS
	ADDI	T2,(T3)		;T2=ADDR OF "LAST WORD".
	JUMPN	T4,RDBAT2	;JUMP IF WASTED BITS.
	SETZM	(T1)		;CLEAR FIRST WORD.
	AOBJP	T1,RDBAT4	;JUMP IF ONLY ONE WORD.
	JRST	RDBAT3		;ELSE CLEAR OTHERS.
RDBAT2:	MOVNI	T3,-1(T4)	;T3=-BITS TO SET TO 0 +1
	MOVSI	T4,400000	;SET SIGN BIT
	ASH	T4,(T3)		;SET BITS AND
	SETCAM	T4,(T2)		;STORE THEM.
	AOBJP	T1,RDBAT4	;JUMP IF 0 OR 1 WORD IN SWAPPING SAT
	SETZM	-1(T1)		;SET 1ST WORD AVAILABLE.
RDBAT3:	HRLI	T1,-1(T1)	;LH=ADDR OF FIRST WORD
	MOVEI	T3,(T1)		;1ST ADDR + 1 = LAST ADDR? ONLY IF EXACTLY 2 WORDS
	CAIGE	T3,(T2)		;SKIP IF YES, NO MOVE LOCATIONS TO CLEAR
	BLT	T1,-1(T2)	;SET REST OF SAT TO AVAILABLE.
RDBAT4:	AOSN	BATBAD		;SEE IF BOTH BAD
	JRST	RDBAT6		;JUST ASSUME ALL PAGES OK
	MOVE	T2,[PUSHJ P,SETSST];T2=INSTRUCTION TO EX FOR BAD PAGES
	PUSHJ	P,SCNBAT	;SCAN BAT PAGE, CALL SETSST FOR BAD PAGES.
	JFCL
RDBAT6:	HLRZ	U,UNISYS(U)	;GET ADR. OF NEXT UNIT DATA PAGE IN SYSTEM
	JUMPN	U,RDBAT1	;REPEAT IF THERE IS ONE
	POPJ	P,		;NONE LEFT - EXIT

COMMENT #
@@SUBROUTINE CHKBAT/BATREF
@@PURPOSE
SUBR TO READ THE BAT PAGES AND ALLOW THE USER TO REINITIALIZE
THEM IF THEY ARE BAD.
@@ENTRY
THE ENTRY POINT CHKBAT READS THE BAT PAGES AND IF ERRORS ARE
FOUND, ASKS THE USER IF HE/SHE WISHES TO REINITIALIZE THE BAT
PAGES.  IF YES, IT FALLS INTO BATREF, WHICH DOES.
EXPECTS U/ UNIT DB AND F/ DDB.
@@ACCUM
DESTROYS
@@CALLS
SVOTAC, GETBAT, ASKQUE, CORZER, SETBAT, AND WTBOTH.
@@EXIT

@@ #

CHKBAT:	JSP	T2,SVOTAC	;SAVE P4,F,U & J.
	SETZM	BATBAD		;CLEAR BAT PAGE BAD FLAG.
	PUSHJ	P,GETBAT	;READ BOTH BAT PAGES & VERIFY THEM.
	  JFCL			;ERROR(S)
	SKIPN	T1,REDERR	;ANY ERRORS FOUND AT ALL IN EITHER BAT PAGE?
	POPJ	P,		;NO.
	MOVEM	T1,BATBAD	;YES. BAD BAT PAGE.
	SKIPE BATMAN		;DO NOT GET TO REFRESH IF FORCED(
	POPJ P,			;I.E. FROM FILMAN).
	MOVEI	T1,[ASCIZ .
Do you want to initialize the BAT pages on this UNIT?
.]
	MOVSI	T2,UNPHWP
	TDNN	T2,UNIDES(U)	;DON'T INITIALIZE IF UNIT HARDWARE WRITE-PROTECT
	PUSHJ	P,ASKQUE	;TYPE QUESTION & GET USER'S RESPONSE
	  POPJ	P,		;HE DOESN'T WANT TO
	MOVEI	T1,[ASCIZ .
THIS is not normally done, are you SURE?
.]
	PUSHJ	P,ASKQUE	;ASK AGAIN
	  POPJ	P,		;HE SAVED HIMSELF SOME BOTHER
	MOVE T3,P1		;GET CORE PNTR IN CORRECT AC.

BATREF:	MOVEI	T1,%BAT
	PUSHJ	P,CORZER	;
	PUSHJ	P,SETBAT	;
	MOVEM	P2,%BAT+PAGNAM	;PUT SIXBIT 'BAT' IN THE PAGE.
	MOVSI	T1,-BRMAX	;SETUP AOBJN PTR. TO BE STORED IN PAGE
	HRRI	T1,BATREG
	MOVEM	T1,%BAT+BATFIR ;SAVE IT IN THE PAGE
	MOVEM	P3,%BAT+PAGCOD ;SAVE THE CODE FOR BAT PAGES IN THE PAGE
	PJRST	WTBOTH		;

BATBAD:	0			;0 INDICATES VIRGIN BAT PAGES(INITIALIZED)
				; LH = -1 INDICATES ERROR(S) DETECTED WHILE READING
				; RH = # BAD REGIONS ON UNIT
BATMAN:	0			;0=OPTIONAL, -1=MANDATORY

COMMENT #
@@SUBROUTINE SETSST
@@PURPOSE
SUBR TO CLEAR BITS IN SWAPPING SAT TABLE FOR BAD PAGES IN
SWAPPING SPACE.
@@ENTRY
EXPECTS U/ UNIT DB AND T1/ NO. OF BAD PAGE WRS UNIT.
@@ACCUM
DESTROYS T1, T2, AND T4.
@@ #


SETSST:	JSP	T4,SAVE4	;SAVE P1-P4
	SUB	T1,UNISLB(U)	;T1=RELATIVE PAGE IN SWAPPING SPACE
	JUMPL	T1,CPOPJ	;EXIT IF PAGE BELOW SWAPPING SPACE
	LDB	P3,UNYP4S	;P3=P FOR SWAPPING ON THIS UNIT
	JUMPE	P3,CPOPJ	;EXIT IF NO SWAPPING SPACE ON UNIT
	CAML	T1,P3		;SKIP IF PAGE IN SWAPPING SPACE
	POPJ	P,		;NO, PAST END
	IDIVI	T1,^D36		;
	MOVNS	T2		;
	MOVSI	T4,400000	;
	LSH	T4,(T2)		;
	MOVE	P4,UNIPTR(U)	;PTR TO SWAPPING SAT
	ADDI	T1,(P4)		;
	IORM	T4,(T1)		;
	POPJ	P,

SUBTTL VARIOUS TYPEOUT ROUTINES

;SUBROUTINE TO TYPE ALL UNITS IN THE ACTIVE SWAPPING LIST
; RETURN WITH P1,P3,P4,F,U & J DESTROYED

TYPASL:	MOVSI	P3,-SWPMAX	;-VE LENGTH OF ASL
	HRRZ	U,SWPTAB(P3)	;GET ADR. OF 1ST. UNIT DATA BLOCK IN ASL
	JUMPE U,NOASL		;NOTHING IN ACTIVE SWAP LIST
	SETOM	P4		;INDICATE CLASS FOR SWAPPING TO BE TYPED IN TYPUNI
	MOVEI	P1,[ASCIZ .
UNITS IN ACTIVE SWAPPING LIST:
.]
	PUSHJ	P,TYPUN1	;TYPE MSG., UNIT NAME & (CLASS FOR SWAPPING)
	JRST	TYPAS2

TYPAS1:	HRRZ	U,SWPTAB(P3)	;GET ADR. OF NEXT UNIT DATA BLOCK IN ASL
	SKIPE	U		;END OF LIST WHEN ZERO ENTRY FOUND
	PUSHJ	P,TYPUNI	;TYPE "," UNIT NAME & (CLASS FOR SWAPPING)
TYPAS2:	AOBJN	P3,TYPAS1	;REPEAT IF LIST NOT COMPLETELY SCANNED
	JRST	TYPAS3		;NOW UNITS WITH SWAP NOT IN ASL

NOASL:	MOVEI T1,[ASCIZ /
NO UNITS IN ACTIVE SWAPPING LIST
/]
	PUSHJ P,CONMES
TYPAS3:	PUSHJ P,OPOUT	;FORCE OUT MESSAGE
	MOVEI P4,1	;PRINT ONLY SWAP SPACE
	HLRZ U,SYSUNI
	MOVEI P1,[ASCIZ /
UNITS WITH SWAPPING SPACE BUT NOT IN SWAP LIST
/]
TYPAS4:	LDB	T1,UNYP4S
	JUMPE T1,TYPAS5	;NOTHING ON THIS ONE
	SKIPL UNISUN(U)
	JRST TYPAS5	;IS IN SWAP LIST
	PUSHJ P,TYPUN1	;TYPE UNIT NAME
	MOVEI P1,[ASCIZ /,/]
TYPAS5:	HLRZ U,UNISYS(U)
	JUMPN U,TYPAS4
	PJRST TYPSR1	;FINISH WITH CRLF

;SUBROUTINE TO TYPE SIXBIT UNIT NAME FOLLOWED BY (ID/SWAPPING CLASS)
; ENTER WITH U = UNIT DATA BLOCK ADR.
; P4 = 0 TO TYPE UNIT ID. P4 = -VE TO TYPE SWAPPING CLASS

TYPUNI:	MOVEI	P1,[ASCIZ .,.]
TYPUN1:	MOVE	T1,P1		;GET MSG. ADR. INTO KOSHER AC
	PUSHJ	P,CONMES	;PUT "," OR MSG. IN BUFFER
	JUMPE	U,OPOUT	;JUST O/P MSG. IF NO UNITS IN ASL
	PUSHJ	P,SPUNAM	;PUT SIXBIT UNIT NAME IN BUFFER
	MOVEI	T1,[ASCIZ .(.]
	PUSHJ	P,CONMES	;PUT "(" IN BUFFER
	JUMPN	P4,TYPUN2	;JUMP IF CLASS FOR SWAPPING TO BE TYPED
	SKIPE	T2,UNIHID(U)	;GET SIXBIT UNIT ID - IF ANY
	PUSHJ	P,PRNAME	;PUT IT IN THE BUFFER
	JRST	TYPUN3

TYPUN2:	LDB	T1,UNYCFS	;GET CLASS FOR SWAPPING
	JUMPG P4,TYPUN4		;SKIP SWAP CLASS
	PUSHJ	P,RADX10	;PUT DECIMALLY IN THE BUFFER
	MOVEI T1,[ASCIZ /:/]
	PUSHJ P,CONMES
TYPUN4:	LDB	T1,UNYP4S
	PUSHJ P,RADX10	;ALSO PRINT SWAPPING SPACE
TYPUN3:	MOVEI	T1,[ASCIZ .).]
	PUSHJ	P,CONMES	;PUT ")" IN THE BUFFER
	PJRST	OPOUT		;O/P BUFFER

;SUBROUTINE TO TYPE STR NAME IN "SYS" SEARCH LIST.

TYPSYS:	MOVEI	T1,[ASCIZ .
STR IN "SYS" SEARCH LIST:.]
	PUSHJ	P,CONOUT
	PUSHJ	P,SPSNAM	;PUT SIXBIT STR NAME IN BUFFER
	PJRST	OPOUT		;O/P BUFFER & EXIT
TYPSR1:	PJRST	CRLFOP		;O/P CRLF

;SUBROUTINE TO TYPE ALL UNITS IN SYSTEM THAT ARE NOT IN ANY STR
; RETURN WITH P1,P4,F,U & J DESTROYED

TYPUNS:	MOVEI	P1,[ASCIZ .
UNITS NOT IN A FILE STRUCTURE:
.]
	HLRZ	U,SYSUNI	;GET ADR. OF 1ST. UNIT DATA BLOCK IN SYSTEM
	TDZA	P4,P4		;INDICATE UNIT ID TO BE TYPED IN TYPUNI
TYPNS1:	HLRZ	U,UNISYS(U)	;GET ADR. OF NEXT UNIT DATA BLOCK IN SYSTEM
	JUMPE	U,CPOPJ		;EXIT IF NONE LEFT
	SKIPE	UNILOG(U)	;IS THIS UNIT IN A STR?
	JRST	TYPNS1		;YES - CHECK NEXT UNIT
	PUSHJ	P,TYPUN1	;NO - TYPE MSG., UNIT NAME & (ID)

TYPNS2:	HLRZ	U,UNISYS(U)	;GET ADR. OF NEXT UNIT DATA BLOCK IN SYSTEM
	JUMPE	U,TYPSR1	;O/P CRLF & EXIT IF NONE LEFT
	SKIPN	UNILOG(U)	;IS THIS UNIT IN A STR?
	PUSHJ	P,TYPUNI	;YES - TYPE "," UNIT NAME & (ID)
	JRST	TYPNS2		;REPEAT

;SUBROUTINE TO TYPE THE STR & ITS UNITS.
; RETURN WITH P1,P4,F,U & J DESTROYED

TYPSTR:	SETZM	P4		;INDICATE UNIT ID TO BE PRINTED IN TYPUNI
	MOVEI	P2,STRDDB	;ADR. OF STR DATA BLOCK.
	SKIPN	STRNAM(P2)	;ANY STR?
	POPJ	P,		;NO.
    ;TYPE STR NAME & ALL ITS UNITS.

	HLLZ	T2,STRREF(P2)
	JUMPE	T2,NOREF	;DOES STR NEED REFRESHING?
	MOVEI	T1,[ASCIZ .NEEDS REFRESHING .]		;YES
	PUSHJ	P,CONMES	;PUT MSG IN BUFFER
NOREF:	PUSHJ	P,SPSNAM	;PUT SIXBIT STR NAME IN BUFFER
	HLRZ	U,STRUNI(P2)	;GET ADR. OF 1ST. UNIT IN STR
	JUMPE	U,CRLFOP	;IF NO UNITS IN STR - O/P BUFFER WITH CRLF & EXIT
	PUSHJ	P,OPOUT	;O/P BUFFER
	MOVEI	P1,[ASCIZ .:.]
	PUSHJ	P,TYPUN1	;TYPE ":" UNIT NAME & (ID) [IST. TIME THRU]
TYPST1:	HLRZ	U,UNISTR(U)	;GET NEXT UNIT DATA BLOCK IN STR
	JUMPE	U,TYPSR1	;IF NO MORE UNITS - ADD CRLF & EXIT
	PUSHJ	P,TYPUNI	;TYPE "," UNIT NAME & (ID)
	JRST	TYPST1		;REPEAT UNTIL NO MORE UNITS IN STR

TYPALL:	PUSHJ P,TYPSTR
	PUSHJ P,TYPUNS
	PUSHJ P,TYPASL
	PUSHJ P,TYPSYS
	JRST FILCMD

;ROUTINE TO TYPE VALUE AND MESSAGE OR ASK FOR NEW
;VALUE USING MIN AND MAX
;ONLY TYPE IF TYPONL NON-0
;DBLSTD MAY HAVE 2 VALUES TO TRY WITHOUT ASKING
;VALUE IN P1, MSG IN T1, RESULT IN T2
;NON-SKIP RETURN IF UNCHANGED OR ONLY TYPING

ASKQMM:	SKIPGE TYPONL
	JRST DECLOP	;JUST TYPE IT
	MOVEM T1,MSGSAV	;SAVE MESSAGE
	MOVEM P1,VALSAV	;AND VALUE
	MOVE T2,MIN
	CAMN T2,MAX
	JRST RETFIX	;ONLY ONE POSSIBLE VALUE
ASKRPT:	SKIPL DBLSTD
	JRST QSTSTD	;TRY A STANDARD ANSWER
	PUSHJ P,FTYUNI	;FORCED TYPE OF UNIT?
	 JRST KNNUNI	;NO
	MOVE T1,MSGSAV
	MOVE P1,VALSAV	;MAKE SURE RESTORED
KNNUNI:	PUSHJ P,DECLOP	;TYPE VALUE AND MESSAGE
	MOVEI T1,[ASCIZ /MIN = /]
	MOVE P1,MIN
	PUSHJ P,TYPDEC
	MOVEI T1,[ASCIZ / MAX = /]
	MOVE P1,MAX
	PUSHJ P,DECLOP
	PUSHJ P,GETLIN
	 JRST KEPSAM	;DOES NOT WANT IT CHANGED
	PUSHJ P,DECIN
	 JFCL
	 JRST ASKRP1	;ASK FOR IT AGAIN, WAS BAD
	CAIN	T3,"-"	;IS HYPHEN TERMINATOR?
	JRST	ASKRP1	;YES, NEGATIVE RESPONSE ILLEGAL
CHKANS:	CAMG T2,MAX
	CAMGE T2,MIN
	JRST ASKRPQ	;NOT IN RANGE
RETFIX:	CAME T2,VALSAV
	AOS (P)
	SETOM DBLSTD	;SO NOTHING THERE NEXT TIME
	POPJ P,

QSTSTD:	HLRZ T2,DBLSTD	;GET FIRST TRY
	CAIN T2,377777
	MOVE T2,MAX	;FLAG FOR MAX
	JRST CHKANS

KEPSAM:	MOVE T2,VALSAV
	JRST CHKANS

ASKRPQ:	MOVEI T1,[ASCIZ /
VALUE NOT IN PERMITTED RANGE/]
	SKIPGE DBLSTD	;NO ERROR IF STANDARD SETTING
	PUSHJ P,CONOUT	;PUT OUT THE MESSAGE
	HRLOS DBLSTD	;TRY SECOND STANDARD IF PRESENT
ASKRP1:	MOVE T1,MSGSAV
	MOVE P1,VALSAV
	JRST ASKRPT	;TRY AGAIN

MSGSAV:	0
DBLSTD:	0
VALSAV:	0
TYPONL:	0
MAX:	0
MIN:	0
KNOUNI:	0

COMMENT #
@@SUBROUTINE MAYREF
@@PURPOSE
SUBR TO TYPE WARNING THAT A CHANGE WILL CAUSE REFRESH.
@@ #

MAYREF:	SKIPL TYPONL
	SKIPL DBLSTD
	POPJ P,		;ONLY TYPING, OR DOING STANDARD
	JUMPE P2,CPOPJ	;NO STR
	HLLZ T1,STRREF(P2)
	JUMPN T1,CPOPJ	;ALREADY SET FOR REFRESH
	MOVEI T1,[ASCIZ /
CHANGE WILL CAUSE STR TO NEED REFRESHING/]
	PJRST CONOUT




COMMENT #
@@SUBROUTINE FTYUNI
@@PURPOSE
LITTLE SUBR TO POSSIBLY TYPE A UNIT NAME.
@@ #

FTYUNI:	SKIPE KNOUNI	;KNOW WHAT UNIT?
	POPJ P,		;YES
	PUSHJ P,SPUNAM
	AOS (P)
	SETOM KNOUNI
	PJRST CRLFOP

SUBTTL

COMMENT #
@@SUBROUTINE UNITSW
@@PURPOSE
SUBR TO ALLOW THE USER TO REDEFINE THE SWAPPING SPACE ON A
UNIT.
IF THE USER ALLOCS ALL THE SPACE WE HERE SAY IS AVAILABLE FOR
SWAPPING AND SWAP.SYS NEEDS EXTENDED RIBS, WE MAY STOPCD DUE TO
LACK OF ROOM.  BUT HE/SHE SHOULDN'T BE ALLOCING THIS MUCH 
SWAPPING SPACE ANYWAY.
@@ENTRY
EXPECTS U/ UNIT DB AND P2/ STR DB.
@@ACCUM
DESTROYS
@@CALLS
MAYREF, SETCHG, ASKQMM, AND CPOPJ.
@@EXIT

@@ #

    ;SORT OF FIND THE MAXIMUM NO. OF PAGES OF SWAPPING SPACE WE CAN
    ;ALLOW ON THIS UNIT.  (DOES NOT TAKE INTO ACCOUNT THE
    ;EXTENDED RIBS OF SWAP.SYS, SINCE THEY MAY NOT BE ON
    ;THIS UNIT).
UNITSW:	SETZM	MIN		;MINIMUM OF ZERO IS OKAY.
	MOVEI	T3,HBBPGS+1	;NO. PAGES FOR HOME/BAT/BOOTS+PAGE 0.
	SKIPN	UNILOG(U)	;IS THIS UNIT IN A STR?
	JRST	UNITS4		;NO, SKIP OVER STR STUFF.

      ;HERE WHEN THE UNIT IS IN A STR.
	LDB	T1,UNYSPU	;ADD IN THE NO. OF
	ADDI	T3,(T1)		;SATS ON THE UNIT.
	LDB	T1,UNYLUN	;IS THIS
	JUMPN	T1,UNITS4	;THE FIRST UNIT IN THE STR?
	ADDI	T3,RB1UN+NMUFDS	;YES, ADD IN THE NO. OF RIBS AND
	ADD	T3,STRP4C(P2)	;UFDS REFSTR CREATES+CRASH.SAV.
	MOVE	T1,STRP4C(P2)	;ALSO
	CAIGE	T1,RBLVPR	;TAKE
	JRST	UNITS4		;INTO
	CAIL	T1,RBLVPR*RBLVSP ;ACCOUNT ANY
	STOPCD
	ADDI	T1,1		;EXTENDED
	IDIVI	T1,RBLVSP	;RIBS NEEDED
	ADDI	T3,(T1)		;FOR CRASH.SAV.
	MOVEI	T4,RBLVPR	;BUT ONLY
	SUBI	T4,(T1)		;WORRY
	CAIGE	T4,(T2)		;ABOUT TWO 
	ADDI	T3,1		;LEVELS.

UNITS4:	PUSH	P,T3		;SAVE MIN. NO. OF NON-SWAP PAGES NEEDED.
	MOVE	T1,UNIPPU(U)	;CALC T1/ NO. OF PAGES
	SUB	T1,T3		;AVAILABLE FOR SWAPPING.
	MOVEI	T2,1		;ONLY ALLOW
	LSH	T2,LIMP4S	;THE MAX THAT
	SUBI	T2,1		;FITS
	CAMLE	T1,T2		;THE
	MOVE	T1,T2		;FIELD.
	MOVEM	T1,MAX		;STORE MAX K FOR SWAPPING.

    ;TYPE MSG AND VALUE AND GET RESPONSE.
	PUSHJ	P,MAYREF	;WARN THAT THIS WILL CAUSE REFRESHING.
	MOVEI	T1,[ASCIZ .PAGES FOR SWAPPING ON UNIT = .]
	LDB	P1,UNYP4S	;P1/ OLD VALUE.
	PUSHJ	P,ASKQMM	;
	JRST	[POP P,T3	;ONLY TYPING OR NO CHANGE.
		POPJ P,]

	MOVE	P1,T2		;GET ANSWER IN P1(SAFE FROM SETCHG.).
	DPB	P1,UNYP4S	;
	SKIPE	P2		;STR PRESENT?
	HRROS	STRREF(P2)	;YES, MARK FOR REFRESH AND 
	PUSHJ	P,SETCHG	;MARK HOME PAGES NEED REWRITE.
	POP	P,T4		;RESTORE NO. OF NON-SWAP PAGES NEEDED.
	JUMPN	P1,UNITS5	;IF EITHER IN A STR OR
	JUMPN	P2,UNITS5	;HAS <> 0 SWAPPING SPPACE,
	PJRST	SETPRV		;THEN PRIVATE.  ELSE
UNITS5:	PUSHJ	P,SETPUB	;PUBLIC.
	JUMPE	P1,CPOPJ	;IF NO SWAPPING SPACE ALLOCATED SKIP QUESTIONS
	MOVE	T1,UNIPPU(U)	;START
	LDB	T3,UNYPPY	;THE
	IDIV	T1,T3		;SWAPPING
	PUSH	P,P2		;
	IDIV	P1,T3		;SPACE
	SUBM	T1,P1		;IN
	LSH	P1,-1		;THE CENTER OF THE UNIT
	IMUL	P1,T3		;ON A CYLINDER
	JUMPN	P1,UNITS6	;BOUNDARY, IF WE CAN.
	MOVE	P1,T4		;IF DRUM OR SOMETHING, LEAVE ROOM FOR REQUIERED STUFF.
UNITS6:	MOVEM	P1,UNISLB(U)	;SAVE LOG. NO. OF 1ST PAGE FOR SWAPPING.
	POP	P,P2		;
	POPJ P,

COMMENT #
@@SUBROUTINE SPUCLC
@@PURPOSE
SUBR TO CALC THE NUMBER OF SATS FOR A UNIT, GIVEN THE NO. OF
PAGES ON THE UNIT.
@@ENTRY
EXPECTS U/ UNIT DB.
@@ACCUM
DESTROYS T2 AND T3.
@@EXIT
SETS UNYSPU.
@@ #

SPUCLC:	MOVE	T2,UNIPPU(U)	;T2/ NO. OF PAGES ON THE UNIT.
	SUBI	T2,1		;
	IDIVI	T2,400*^D36	;DIVIDE BY NO. PAGES PER SAT.
	ADDI	T2,1		;
	DPB	T2,UNYSPU	;SET ANSWER.
	POPJ	P,

COMMENT #
@@SUBROUTINE UNITST
@@PURPOSE
SUBR TO CALC AND STORE THE NO. OF SATS ON A UNIT.  MAY FLAG
HOME PAGES NEED REWRITING.
@@ENTRY
EXPECTS U/ UNIT DB.
JUST RETURNS IF TYPONL IS < 0.
@@CALLS
SPUCLC AND SETCHG.
@@EXIT
STORES RESULT IN UNYSPU.
@@ #

UNITST:	SKIPGE	TYPONL
	POPJ	P,
	LDB	T3,UNYSPU
	PUSHJ	P,SPUCLC
	CAME	T3,T2
	PJRST	SETCHG
	POPJ	P,

COMMENT #
@@SUBROUTINE UNITID
@@PURPOSE
SUBR TO SET THE UNIT ID.
@@ #

UNITID:	PUSHJ	P,FTYUNI
	JFCL
	MOVEI	T1,[ASCIZ /
UNIT ID IS /]
	SKIPN	P1,UNIHID(U)
	MOVEI	T1,[ASCIZ /
ZERO UNIT ID - NEW ID NEEDED/]
	PUSHJ	P,CONMES
	SKIPE	T2,P1		;PRINT IF NON-ZERO.
	PUSHJ	P,PRNAME
	PUSHJ	P,CRLFOP
	SKIPGE	TYPONL
	POPJ	P,		;DONE IF ONLY PRINTING.
	PUSHJ	P,GETLIN
	SKIPA	T2,UNIHID(U)	;NO CHANGE, GET BACK OLD.
	PUSHJ	P,CTEXT	;READ
	JUMPE	T2,UNITID	;STILL 0, TRY AGAIN.
	EXCH	T2,UNIHID(U)
	CAME	T2,UNIHID(U)
	PJRST	SETCHG		;CHANGED.
	POPJ	P,		;NOT CHANGED

COMMENT #
@@SUBROUTINE STRTCH
@@PURPOSE
SUBR TO ALLOW THE REDEFINITION OF THE SIZE OF CRASH.SAV.
@@ #

STRTCH:	SETZM	MIN
	MOVE	T1,[^D8192]	;(2**22)/512.
	MOVEM	T1,MAX
	PUSHJ	P,MAYREF
	MOVE	P1,STRP4C(P2)
	MOVEI	T1,[ASCIZ /PAGES FOR CRASH.SAV = /]
	PUSHJ	P,ASKQMM
	POPJ	P,
	MOVEM	T2,STRP4C(P2)
	HRROS	STRREF(P2)
CHGSTR:	MOVE	T1,[PUSHJ P,SETCHG]
	PJRST	STOUNI



COMMENT #
@@SUBROUTINE
@@PURPOSE
SUBR TO ALLOW THE REDEFINITION OF THE NO. OF PAGES OF
OVERDRAW PER USER.
@@ #

STRTOV:	SETZM	MIN
	MOVE	T1,STRPPU(P2)
	MOVEM	T1,MAX
	MOVEI	T1,[ASCIZ /# OF PAGES ALLOWED FOR OVERDRAW PER USER = /]
	MOVM	P1,STROVR(P2)
	PUSHJ	P,ASKQMM
	POPJ	P,
	MOVNM	T2,STROVR(P2)
	PJRST	CHGSTR

COMMENT #
@@SUBROUTINE STSDEF
@@PURPOSE
SUBR TO DEFINE A STR.
@@ENTRY
EXPECTS
@@ACCUM
DESTROYS
@@CALLS
CONOUT, GETLIN, CTEXT, FNDSTR, GETUNI, CMPLOG, SETCHG,
STRTOV, AND STRTCH.
(AND ITS INTERNAL SUBRS STSINS, UNICHK, AND UNICK1.).
@@ #

STSDEF:	MOVE	T1,[SIXBIT/DSKB/] ;ALL STR NAMES ARE DSKB.
	PUSHJ	P,FNDSTR	;DOES THIS STR ALREADY EXIST?
	SKIPA	T1,[[ASCIZ /STR ALREADY EXISTS/]] ;YES, THIS IS A NO-NO.
	JRST	STSNEW		;NO, OKAY UNLESS ALREADY A STR.
	PJRST	CONOUT

STSNEW:	SKIPN	STRNAM(P2)	;DOES ANY STR EXIST?
	JRST	STSNE1		;NO, THIS IS IT.
	MOVEI	T1,[ASCIZ /
TOO MANY FILE STRS
/]
	PJRST	CONOUT

    ;HERE WITH A GOOD STR NAME.
STSNE1:	PUSHJ	P,CLRSTR
	MOVEM	T1,STRNAM(P2)
	HRROS	STRREF(P2)	;NEED REFRESH.
    ;HERE TO PUT THE UNITS IN THE STR.
STSNE2:	MOVEI	T1,[ASCIZ /TYPE NAMES OF PHYSICAL UNITS IN STR, EXTRA CR WHEN DONE/]
	PUSHJ	P,CONOUT
	MOVEI	P3,STRUNI(P2)
	SETZ	P1,
STSNXT:	PUSHJ	P,GETUNI	;GET A UNIT NAME
	JRST	[CAIE P3,STRUNI(P2)  ;FINISHED GETTING UNIT NAMES.
		JRST STSFIN
		JRST STSNE2]
	PUSHJ	P,STSINS	;INSERT UNIT.
	JRST	STSNXT		;ALREADY IN STR
	JRST	STSNXT		;CONTINUE

    ;SUBR INTERNAL TO STSDEF TO INSERT A UNIT IN THE STR.
STSINS:	HRRZ	T1,UNISTR(U)	;SEE IF THIS UNIT IS ALREADY IN A STR.
	JUMPE	T1,STSUN2	;T1 = 0 IF IT ISN'T
	MOVEI	T1,[ASCIZ .
UNIT ALREADY IN FILE STRUCTURE
.]
	PJRST	CONOUT		;TYPE MSG. & EXIT

STSUN2:	HRLM	U,(P3)		;LINK THIS UNIT DATA BLOCK TO PREVIOUS ONE
	HRRZM	P2,UNISTR(U)	;ATTACH THIS UNIT DATA BLOCK TO THIS STR
	HRRZ	T1,STRUNM(P2)	;GET LOGICAL UNIT # WITHIN STR
	DPB	T1,UNYLUN	;SAVE IT IN UNIT DATA BLOCK
	PUSHJ	P,CMPLOG	;COMPUTE SIXBIT LOGICAL UNIT NUM, STORE IN UNILOG
	PUSHJ	P,SETPUB
	MOVE	T1,UNIPPU(U)
	CAMLE	T1,STRPPU(P2)
	MOVEM	T1,STRPPU(P2)
	CAIE P1,0
	CAMGE	T1,UNIPPU(P1)	;COMPARE WITH SMALLEST SO FAR
	MOVE	P1,U		;SAVE ADDR OF SMALLEST IN P1
	AOS	STRUNM(P2)	;INCREMENT # OF UNITS IN STR
	PUSHJ	P,SETCHG	;FLAG THAT UNIT'S HOME PAGES MUST BE REWRITTEN
	MOVEI	P3,UNISTR(U)	;MAKE CURRENT UNIT PREDECESSOR
	JRST	CPOPJ1		;SKIP RETURN

    ;HERE TO FINISH UP.
STSFIN:	HLRZ	U,STRUNI(P2)
	HLRZ	U,UNISTR(U)	;GET ADR. OF NEXT UNIT DATA BLOCK IN STR
	JUMPN	U,.-1		;REPEAT IF ANY LEFT
	SETZM	TYPONL		;JUST IN CASE.
	MOVE	U,P1		;GET SMALLEST UNIT.
	LDB	P1,UNYKTP
	PUSH	P,P1		;SAVE IT.
	MOVE	T1,OVRDEF(P1)
	HRLOM	T1,DBLSTD
	PUSHJ	P,STRTOV	;SET OVERDRAW.
	MOVE	T1,(P)
	MOVE	T1,P4CDEF(T1)
	HRLOM	T1,DBLSTD
	PUSHJ	P,STRTCH	;SET DEFAULT SIZE OF CRASH.SAV.
	POP	P,P1
	MOVE	T1,[PUSHJ P,UNICK1]
	PUSHJ	P,STOUNI	;CHECK SATS.
	MOVE T1,[PUSHJ P,UNICHK]
	PJRST STOUNI		;NOW DO ALL UNITS.

    ;A LITTLE INTERNAL STSDEF SUBR.
UNICHK:	SETZM KNOUNI		;DO NOT KNOW UNIT.
	PJRST UNCHKA		;GO DO THE STANDARD STUFF.

    ;A LITTLE INTERNAL STSDEF SUBR.
UNICK1:	SETZM KNOUNI
	SETZM TYPONL		;JUST TO MAKE SURE.
	PJRST UNITST		;CHECK SATS.

;DEFAULT DEFS BY UNIT TYPE.


OVRDEF:	1	;DR
	^D50	;FH
	^D125	;DP
	^D125	;MF
	^D125	;3330
	200-3	;RM03

P4CDEF:	0	;DR
	0	;FH
	^D512	;DP
	^D512	;MF
	^D512	;3330
	1000	;RM03

COMMENT #  OBSOLETE ROUTINE SINCE P033 PAGING MONITORS
@@SUBROUTINE SWPDEF
@@PURPOSE
SUBR/DISPATCH TABLE TO SET THE DEFAULT SWAPPING SPACE
ON A UNIT.
@@ENTRY
EXPECTS U/ UNIT DB.
@@CALLS
ITS INTERNAL SUBR STDSWP.
@@EXIT
RETURNS T2/ DOUBLE DEFAULT FOR DBLSTD, IN PAGES.

SWPDEF:	HRLOI	T2,377777	;DR
	MOVE	T2,[^D668,,377777] ;FH
	PUSHJ	P,STDSWP	;DP
	HRLOI	T2,0		;MF
	PUSHJ	P,STDSWP	;3330
	PUSHJ	P,STDSWP	;RM03
	HRLOI	T2,1		;F3 DISKS

STDSWP:	PUSH	P,U		;SAVE U.
    ;CALC ABOUT HOW MUCH SWAP SPACE WE NEED ON THE SYSTEM AS A WHOLE.
	SETZB	T2,T3		;T2/ NO. OF DP, T3/ SWAPPING SPACE ON
	HLRZ	U,SYSUNI	;ALL OTHER UNITS ON THE SYSTEM.
STDSW1:	LDB	T1,UNYKTP
	CAIN	T1,2
	AOJA	T2,STDSW3	;268,	COUNT 1 DP.
	CAIE	T1,4
	JRST	STDSW2		;NOT 268 OR 230, COUNT 0 DPS.
	ADDI	T2,4		;230 COUNT 4 DPS.
STDSW3:	LDB	T1,UNYP4S
	CAME	U,(P)		;T3/ SUM OF SWAPPING
	ADD	T3,T1		;SPACE ON OTHER UNITS.
STDSW2:	HLRZ	U,UNISYS(U)	;CONTINUE IF THERE IS
	JUMPN	U,STDSW1	;ANOTHER UNIT ON THE SYSTEM.

	MOVEI	T1,2(T2)	;FIND AMOUNT WE SHOULD HAVE.
	IDIVI	T1,3		;ALLOW ABOUT 400 PAGES PER
	IMULI	T1,^D400	;THREE 268S, ETC.
	HRLOI	T2,0		;SET DEFAULT TO 0.
	POP	P,U
	CAMG	T1,T3		;ENOUGH SWAP SPACE ON THE SYSTEM ALREADY?
	POPJ	P,		;YES, RETURN WITH 0 DEFAULT.
	HRLOI	T2,^D400	;NO.  TRY 700
	LDB	T1,UNYKTP	;FOR 230S AND
	CAIN	T1,4		;400 FOR
	HRLOI	T2,^D700	;OTHERS.
	POPJ	P,
@@ #

COMMENT ! ROUTINE/DISPATCH TABLE SWPDEF FOR PAGING SYSTEM
	WHICH REQUIRES NO SWAP.SYS FILE SPACE.  JUST ALLOCATE
	1 PAGE PER UNIT DEFAULT TO KEEP CODE HAPPY WHICH
	EXPECTS AN ACTIVE SWAPPING LIST AND SWAP STORAGE. /AA
EXPECTS:  U/ UNIT DB
RETURNS:  T2/ PAGES SWAP SPACE TO ASSIGN THIS UNIT

!

	;THIS TABLE IS EXECUTED INDEXED BY UNYKTP

SWPDEF:	HRLOI	T2,1	;DR
	HRLOI	T2,1	;FH
	HRLOI	T2,1	;DP
	HRLOI	T2,0	;MF
	HRLOI	T2,1	;230 (3330-TYPE PACKS..BP#'S)
	HRLOI	T2,1	;RM03
	HRLOI	T2,1	;F3 DISKS

STDSWP:	STOPCD		;SHOULD NOT BE REFERENCED

COMMENT #
@@SUBROUTINE STSDSL
@@PURPOSE
SUBR TO DISSOLVE A STR.
CLEARS UNILOG, UNISTR, AND STRNAM AND FLAGS THAT ALL THE
STR'S UNITS' HOME PAGES NEED REWRITING.
@@ENTRY
EXPECTS
@@ACCUM
DESTROYS
@@CALLS
SETCHG.
@@ #

STSDSL:	PUSH	P,T2		;SAVE T2 AND
	PUSH	P,T1		;T1.
	MOVEI	P2,STRDDB
	HLRZ	U,STRUNI(P2)	;GET ADR. OF 1ST. UNIT DATA BLOCK IN STR.
	JUMPE	U,DISST2	;JUST UNLINK STR IF IT HAS NO UNITS.
	MOVSI	T1,UNPPRV	;UNIT MAY BE GOING PRIVATE.
DISST1:	SETZB	T3,UNILOG(U)	;CLEAR OUT NAME OF LOGICAL UNIT WITHIN STR.
	EXCH	T3,UNISTR(U)	;CLEAR OUT LINKS TO STR & NEXT UNIT DATA BLOCKS.
	LDB	T2,UNYP4S	;UNIT IS NOW A
	JUMPN	T2,.+2		;PRIVATE PACK IF
	IORM	T1,UNIDES	;IT HAS NO SWAPPING SPACE.
	PUSHJ	P,SETCHG	;FLAG THAT THIS UNIT'S HOME PAGE MUST BE REWRITTEN.
	HLRZ	U,T3		;GET NEXT UNIT DATA BLOCK ADR.
	JUMPN	U,DISST1	;REPEAT IF THERE IS ONE.
DISST2:	PUSHJ	P,CLRSTR	;INDICATE STR NO LONGER EXISTS.
	POP	P,T1		;RESTORE T1 AND
	POP	P,T2		;T2.
	POPJ	P,		;RETURN - DON'T WORRY ABOUT RETURING CORE
				; AS RDHOME MUST BE CALLED AGAIN.



COMMENT #
@@SUBROUTINE CLRSTR
@@PURPOSE
LITTLE SUBR TO CLEAR OUT THE STR DB (SETTING STRNAM TO
ZERO INDICATES THAT THERE IS NO STR.).
@@ACCUM
DESTROYS NO ACS.
@@ #

CLRSTR:	PUSH	P,T1
	SETZM	STRDDB	
	MOVE	T1,[XWD STRDDB,STRDDB+1]
	BLT	T1,STRDDB+STRLEN-1
	POP	P,T1
	POPJ	P,

COMMENT #
@@SUBROUTINE CHGASL
@@PURPOSE
SUBR WHICH ALLOWS THE USER TO CHANGE THE ACTIVE SWAPPING LIST.
@@ACCUM
DESTROYS
@@CALLS

@@EXIT

@@ #

    ;FIRST CLEAR THE ASL.
      ;UNLINK THE UNITS.
CHGASL:	MOVEI	U,SWPUNI-UNISWP	;U/ADR OF PTR TO 1ST UDB IN ASL.
	JRST	CHGAS4
CHGAS2:	PUSHJ	P,SETCHG	;FLG HOME PAGE MUST BE REWRITTEN
	SETOM	UNISUN(U)	;AS UNIT IS NOW NOT IN ASL.
CHGAS4:	HLRZ	T2,UNISWP(U)	;GET LINK TO NEXT UNIT IN ASL.
	HRRZS	UNISWP(U)	;UNLINK CURRENT UNIT FROM ASL.
	MOVE	U,T2
	JUMPN	U,CHGAS2	;REPEAT IF THERE IS ONE LEFT.

      ;CLEAR SWPTAB.
	MOVE	T1,[XWD SWPTAB,SWPTAB+1] ;GET BLT PTR TO CLEAR SWPTAB.
	SETZM	SWPTAB		;CLEAR OUT 1ST WORD.
	BLT	T1,SWPTBE	;CLEAR THE REST OUT.

    ;NOW ASK FOR THE NEW ASL.
	MOVEI	P3,SWPUNI-UNISWP
	SETZM	P1		;SET CLASS INITIALLY TO ZERO
	MOVSI	P4,-SWPMAX	;SETUP AOBJN PTR. FOR SWAPPING TABLE LENGTH
	MOVEI T1,[ASCIZ /
STANDARD ACTIVE SWAPPING LIST?
/]
	PUSHJ	P,ASKQUE
	SKIPA			;NO.
	JRST	STDASL



    ;HERE FOR THE USER TO SPECIFY THE ASL.
	MOVEI	T1,[ASCIZ .FOR EACH CLASS TYPE PHYSICAL UNIT NAMES(EXTRA CR WHEN DONE).]
	PUSHJ	P,SVMOUT	;O/P BUFFER & ADD CRLF
	SETOM	TYPONL		;SET TYPE ONLY FLAG
CHGAS6:	MOVEI	T1,[ASCIZ .CLASS .]
	PUSHJ	P,TYPDEC
	PUSHJ	P,CRLFOP
	PUSHJ	P,ASKCHW
	JRST	CHGAS8
	CAIG	P1,SWCLSN
	AOJA	P1,CHGAS6
CHGAS8:	SETZM	TYPONL
	POPJ	P,



ASKCHW:	HRRZS	(P)
ASKCW1:	PUSHJ	P,GETUNI
	JRST	[SKIPGE	(P)
		AOS	(P)
		POPJ	P,]
	LDB	T1,UNYP4S	;GET # PAGES FOR SWAPPING ON THIS UNIT.
	JUMPN	T1,ASKCH1	;PRINT MSG. IF NONE
	MOVEI	T1,[ASCIZ .UNIT HAS NO SPACE ALLOCATED FOR SWAPPING
.]
	PUSHJ	P,SVMOUT	;TYPE MSG. & CRLF
	JRST	ASKCW1		;AND WAIT FOR ANOTHER UNIT NAME TO TYPED

ASKCH1:	HLRZ	T1,SWPUNI
	JUMPE	T1,ASKCH3
ASKCH2:	CAMN	T1,U
	JRST	SAMUNI
	HLRZ	T1,UNISWP(T1)
	JUMPN	T1,ASKCH2
ASKCH3:	HRROS	(P)
	HRLM	U,UNISWP(P3)
	HRRZS	UNISWP(U)
	DPB	P1,UNYCFS
	HRRZM	P4,UNISUN(U)
	HRRM	U,SWPTAB(P4)
	PUSHJ	P,SETCHG	;FLAG HOME PAGES MUST BE REWRITTEN
	MOVE	P3,U
	AOBJN	P4,ASKCW1	;REPEAT IF ANY ROOM LEFT IN TABLE
	MOVEI	T1,[ASCIZ .
ACTIVE SWAPPING LIST FULL.]
	PJRST	SVMOUT


SAMUNI:	MOVEI	T1,[ASCIZ .UNIT ALREADY IN ACTIVE SWAPPING LIST.]
	PUSHJ	P,SVMOUT
	JRST	ASKCW1



    ;HERE TO SET UP THE STANDARD ASL.
STDASL:	SETZB P1,P2	;P1 IS CLASS, P2 KONTROLER TYPE
STDAS0:	HLRZ U,SYSUNI	;LOOK AT ALL UNITS
STDAS1:	LDB T1,UNYP4S
	JUMPE T1,STDAS2	;NO SPACE
	LDB T1,UNYKTP
	CAME T1,STDALS(P2)	;SAME?
	JRST STDAS2	;NO
	HRLM U,UNISWP(P3)
	HRRZS UNISWP(U)	;LINK IN
	MOVE P3,U	;SAVE LINK
	HRRM U,SWPTAB(P4)
	DPB P1,UNYCFS	;SET CLASS AND FILL TABLE
	HRRZM P4,UNISUN(U)	;SET POSITION
	PUSHJ P,SETCHG	;SET CHANGE FLAG
	HRROS P1	;INDICATE FOUND 1 IN CLASS
	AOBJN P4,STDAS2
	POPJ P,		;SWAP TABLE FULL
STDAS2:	HLRZ U,UNISYS(U)
	JUMPN U,STDAS1	;NEXT UNIT
	ADDI P2,1	;NEXT TYPE
	CAIL P2,STDALL
	POPJ P,		;THATS ENOUGH
	TLZE P1,-1	;DID WE FIND ONE?
	ADDI P1,1	;YES, NEXT CLASS
	JRST STDAS0	;TRY THIS TYPE

STDALS:	OCT 0,1,4,2,3,5	;ORDER TO SEARCH DR,FH,BP,DP,MD,RM
STDALL==.-STDALS	;NUMBER OF KONTROLER TYPES

COMMENT #
@@SUBROUTINE ADDUNI
@@PURPOSE
SUBR TO ADD A UNIT TO THE SYSTEM STR.
@@ENTRY
EXPECTS
@@CALLS

@@ACCUM
DESTROYS
@@EXIT

@@ #

ADDUNI:	MOVEI	P2,STRDDB	;P2/ ADDR OF STR DB.
	SKIPN	STRNAM(P2)	;HAS THE STR BEEN DEFINED?
	JRST	ADDNOT		;NO, ILLEGAL TO ADD TO IT.
	MOVEI	T1,[ASCIZ .Enter unit name to add.]
	PUSHJ	P,CONOUT	;BY NOW P2=STR DDB.
	PUSHJ	P,GETUNI	;GET A UNIT NAME.
	JRST	CANTAD		;NOT A UNIT, CAN NOT ADD.
	JUMPE	U,CANTAD	;CAN NOT ADD ALL EITHER.
	HRRZ	T1,UNISTR(U)	;IS THE UNIT IN A STR ALREADY?
	JUMPE	T1,ADDUN2	;NO.
	MOVEI	T1,[ASCIZ .THAT unit is already in a structure.]
	JRST	CONOUT

    ;HERE WHEN WE HAVE A UNIT TO ADD, AND THE UNIT IS NOT
    ;ALREADY IN A STR.
ADDUN2:	MOVE	T1,UNIPPU(U)
	CAMLE	T1,STRPPU(P2)	;MUST NOT WANT TO CHANGE STRPPU
	JRST	CANTAD
	PUSH	P,STRREF(P2)	;DO NOT SET REFRESH FLAG
	HRROS	STRREF(P2)	;SO WE CAN HAVE SWAP SPACE
	SETZM	TYPONL
	PUSHJ	P,UNCHKA	;SET UNIT ID, MAYBE SWAPPING SPACE, AND NO. OF SATS PER UNIT.
	POP	P,STRREF(P2)
	HRRZ T1,STRUNM(P2)
	LDB T2,UNYLUN
	DPB T1,UNYLUN	;CHANGE THIS UNIT NUMBER
	SETZM UNTTBL(T2)	;ZERO OLD CELL
	MOVE T1,T2
	SKIPE UNTTBL-1(T1)
	SOJA T1,.-1	;LOOK FOR ZERO
	CAMN T1,T2
	JRST ADUNT
	EXCH U,UNTTBL(T1)	;GET THAT ONE
	DPB T2,UNYLUN	;CHANGE ITS NUMBER
	EXCH U,UNTTBL(T2)	;AND STOR IN NEW PLACE (SETS U=0)
	EXCH U,UNTTBL(T1)	;GET OLD U BACK
ADUNT:	LDB T1,UNYLUN		;AND OLD UNIT NUMBER
	MOVEM U,UNTTBL(T1)	;STORE IN NEW PLACE
	HLLZ	T1,STRREF(P2)	;IS IT MARKED FOR REFRESH
	JUMPN	T1,ADDUN4	;YES, DO NOT NEED TO REFRESH PACK
	PUSH	P,P2		;SAVE THE STR POINTER.
	PUSHJ	P,UPDHOM	;WRITE HOME PAGES.
	POP	P,P2		;RESTORE STR PTR.
	MOVSI	P4,UNPCHG
	ANDCAM	P4,UNIDES(U)	;PAKREF WILL READ HOME PAGES.
	PUSHJ	P,PAKREF	;REFRESH PACK.
	JRST	CANTAD		;COULD NOT DO IT.
ADDUN4:	AOS	T1,STRUNM(P2)	;ONE MORE IN STR
	SUBI	T1,1		;
	HRRZM	P2,UNISTR(U)	;LINK TO STR DDB
	PUSHJ	P,CMPLOG	;MAKE A LOGICAL UNIT NAME
	HLRZ	T1,STRUNI(P2)
ADDUN5:	HLRZ	T2,UNISTR(T1)
	JUMPE	T2,ADDUN7	;FIND END OF CURRENT LIST
	MOVE	T1,T2
	JRST	ADDUN5
ADDUN7:	PUSH	P,T1		;SAVE LAST UNIT.
	HRLM	U,UNISTR(T1)
	PUSHJ	P,SETCHG	;MARK HOME PAGE CHANGED.
	PUSHJ	P,SETPUB
	POP	P,U		;WANT TO SET CHANGED HOME ON THIS ONE TOO.
	PUSHJ	P,SETCHG
	POPJ	P,

ADDNOT:	MOVEI T1,[ASCIZ .The SYSTEM structure has not been DEFINED yet.]
	JRST CONOUT

CANTAD:	HLLZS	UNISTR(U)	;
	MOVEI	T1,[ASCIZ .CAN NOT ADD UNIT TO STRUCTURE.]
	JRST	CONOUT

;SUBR TO REFRESH A STR.

STSREF:	PUSHJ	P,GETRAN	;Generate a random # for PACK ID
	MOVEI	T1,UFDHSI	;
	HRRM	T1,STRHSH+STRDDB
	PUSHJ	P,RWRHOM	;WRITE HOME PAGES.
	SETZM BATMAN
	PUSHJ P,RDHOME
	 JFCL
	 JFCL
	MOVE F,DDSTAR
	PUSHJ	P,REFSTR	;REFRESH THE STR.
	JRST	CNTADS		;LOST.
	PUSHJ	P,RDHOME
	 JFCL			;JUST TO MAKE SURE.
	 JFCL
	POPJ P,

CNTADS:	HRROS	STRREF(P2)	;MARK WE STILL NEED REFRESHING.
	MOVEI	T1,[ASCIZ /The structure WAS NOT successfully refreshed./]
	PJRST	CONOUT

COMMENT #
@@SUBROUTINE GETRAN
@@PURPOSE
SUBR TO GENERATE A SEMI-RANDOM NUMBER FOR THE PACK SET ID.
@@ #

GETRAN:				; Move LABEL outside of conditional /CARL
IFCPU (<KI,F3>),<
	PUSH	P,CH7+1		;
	MOVE	T1,[JRST CLKLVL]	;
	MOVEM	T1,CH7+1	;
	SETZM	CLKCNT		;
	WRPI	1B25!1B35	;TURN ON CHANNEL SEVEN.
IFCPU (KI),<	WRAPR	1B25!1B26!7B35>
IFCPU (F3),<WRAPR LP.ESF+LP.CSF+LP.CLK+7B35>
IFCPU (KI),<WRAPR 1B24!7B35>	;DISABLE CLOCK NOW
IFCPU (F3),<WRAPR LP.CSF+LP.DSF+LP.CLK+7B35>
	WRPI	1B26!1B35
	POP	P,CH7+1		;
	HRRZ	T2,CLKCNT	;
	JUMPN	T2,.+2		;
	MOVEI	T2,(SIXBIT /CAT/)
	MOVEM	T2,RANNO	;
	POPJ	P,		; Return.

CLKLVL:	AOS	CLKCNT		;
IFCPU (KI),<	WRAPR	1B25!1B26!7B35>	;
IFCPU (F3),<WRAPR LP.ESF+LP.CSF+LP.CLK+7B35>
	JEN	@CH7

CLKCNT: Z
>;END IFCPU (<KI,F3>)

IFCPU (<KL,KS>),<
IFCPU (<KL>),<
	EXTERN EPT
	SETZM	EPT+EPTLTB
	CONO	MTR,MO.TON
>; END IFCPU (KL)

IFCPU (KS),<
	SETZB	T1,T2		;CLEAR THE
	WRTIME	T1		;TIME BASE.
>;END IFCPU (KS)

	RDTIME	T1
	LSH	T2,-^D12	;GET RID OF GUARANTEED ZERO BITS
	HRRZM	T2,RANNO
	POPJ	P,		; Return.
>;END IFCPU(<KL,KS>)

;SUBR TO ALLOW OPER TO QUERY/SELECT DSKCLN TYPE
;
SPCDKN:	MOVEI	T1,[ASCIZ /
DSKCLN mode is: /]
	PUSHJ	P,OCONM		;MOVE MSG TO OUTPUT BUF
	PUSHJ	P,SPCDKP	;GET CURRENT DC MODE AND PRIORITY
	MOVSI	T1,DCN.ON	;INDIC OPER HAS SEEN AND/OR
	IORM	T1,DCN		; SELECTED DSKCLN MODE
	MOVE	T2,SCNDSK(T2)	;GET SIXBIT NAME OF CURRENT MODE
	CAIN	T3,^L<(DCN.DF)>	;IS MODE DEFAULT?
	MOVE	T2,[SIXBIT /NULL/]	;YES, TELL THIS TO OPER
	PUSHJ	P,PRNAME	;BUFFER MODE NAME
	PUSHJ	P,CRLFOP	;APPEND CRLF, DO CTY OUTPUT
SPCDK1:	MOVEI	T1,[ASCIZ /DSKCLN mode desired? /]
	PUSHJ	P,OCONM		;MOVE MSG TO OUTPUT BUF
	PUSHJ	P,OPOUT		;DO CTY OUTPUT
	PUSHJ	P,GETLIN	;GET OPER'S RESPONSE
	 POPJ	P,		;NULL, NO CHANGE IN MODE
	MOVEI	P1,SCNDSK	; Get address of Scan Table
	SETZM	CMDSCF		; Specify NO STR/UNIT stuff
	PUSHJ	P,CMDSCN	; Call Scanning routine
	  JRST	SPDKHP		; No good!
	DPB	P3,DCNYON	;SAVE IN DCN
NULDSK:	POPJ	P,		;RETURN

SPDKHP:	MOVEI	T1,[ASCIZ \
Bad entry: Type 'FULL', 'FAST', 'NONE'
 or just <Return> for default (NO CHANGE)\]
	PUSHJ	P,CONOUT	;TYPE ERROR MSG ON CTY
	JRST	SPCDK1		;LET OPER TRY AGAIN

;MODE-MNEMONIC CORRESPONDENCE TABLE
;
	DEFINE	MKDSK <
	X NONE,0,Ab.Nak,
	X FAST,0,Ab.Nak,
	X ,0,Ab.Nak,
	X ,0,Ab.Nak,
	X ,0,Ab.Nak,
	X ,0,Ab.Nak,
	X ,0,Ab.Nak,
	X FULL,0,Ab.Nak,
>

	SCNTB	(SPDKHP,SPDKHP,DSK)

;ROUTINE TO GET/SET DSKCLN MODE AND DETERMINE WHO LAST SET IT
;
SPCDKP:	MOVE	T2,DCN		;GET DSKCLN MODE WORD
	JFFO	T2,.+1		;DETERMINE HIGHEST PRIORITY MODE
	LDB	T2,DCNTAB(T3)	;FETCH IT
	DPB	T2,DCNYON	;OPER HAS SEEN OR SELECTED THIS MODE
	POPJ	P,		;RETURN

FILGO:	Movei T1,[Asciz\
Leaving (ONCDSK) FILES dialogue...\]
	Pushj P,LNGMES		; Let everyone know we're leaving!
RWRHOM:	MOVSI P4,UNPCHG
	HLRZ U,SYSUNI		;FIRST UNIT
CHGHOM:	TDNE P4,UNIDES(U)
	PUSHJ P,UPDHOM		;REWRITE IF NEEDED.
	ANDCAM P4,UNIDES(U)
	HLRZ U,UNISYS(U)
	JUMPN U,CHGHOM
	POPJ P,


COMMENT #
@@SUBROUTINE UPDHOM
@@PURPOSE
SUBROUTINE TO READ A HOME PAGE, UPDATE IT FROM THE STR AND
UNIT DB, AND THEN WRITE IT OUT.
@@ENTRY
EXPECTS U/ UNIT DB AND F/ DDB.
@@ACCUM
DESTROYS
@@CALLS
SVOTAC, GETHOM, AND WTBOTH.
@@ #

UPDHOM:	JSP	T2,SVOTAC	;SAVE P4,F,U & J
	SETOM	NOERH		;NO ERRORS PRINTED FOR HOME READ.
	PUSHJ	P,GETHOM	;GET HOME PAGE INTO CORE.
	JRST	[MOVEI T1,%HOM
		PUSHJ P,CORZER
		JRST .+1]
	MOVEM	P2,%HOM+PAGNAM	;SAVE SIXBIT HOME PAGE IDENTIFIER
	HRRZ	P2,UNISTR(U)	;GET STR DATA BLOCK ADR.
	MOVE	T1,UNIHID(U)	;GET SIXBIT UNIT ID
	MOVEM	T1,%HOM+HOMHID	;SAVE IN HOME PAGE
	HLRZ	T1,UNISTR(U)	;GET NEXT UNIT DATA BLOCK ADR. IN STR
	SKIPE	T1		;SAVE 0 IF LAST UNIT IN STR OR NOT IN A STR
	MOVE	T1,UNIHID(T1)	;GET ITS ID
	MOVEM	T1,%HOM+HOMNXT	;SAVE IN HOME PAGE
	SKIPE	T1,P2		;SAVE 0 STR NAME IF UNIT NOT IN A STR
	MOVE	T1,STRNAM(P2)	;GET SIXBIT STR NAME
	MOVEM	T1,%HOM+HOMSNM	;SAVE IN HOME PAGE
	JUMPE	P2,UPDHM3	;BYPASS ALL REFERENCES TO VALUES IN STR DATA BLOCK
	HLRZ	T2,STRUNI(P2)	;GET ADR. OF 1ST UNIT DATA BLOCK IN STR
UPDHM1:	MOVE	T1,T2		;CURRENT UNIT_NEXT UNIT
	JUMPE	T1,UPDHM2	;IF NONE LEFT SAVE 0 IN HOMPRV
	HLRZ	T2,UNISTR(T1)	;GET ADR. OF NEXT UNIT DATA BLOCK IN STR
	MOVE	T1,UNIHID(T1)	;GET CURRENT UNIT'S SIXBIT ID
	CAME	T2,U		;IS ADR. OF NEXT UNIT DATA BLOCK SAME AS THIS ONE?
	JRST	UPDHM1		;YES - PUT SIXBIT ID INTO THIS UNIT'S HOME PAGE
UPDHM2:	MOVEM	T1,%HOM+HOMPRV	;SAVE IN HOME PAGE
				; 0 OR SIXBIT UNIT ID OF PREVIOUS UNIT IN STR
	HLLZ	T1,STRREF(P2)	;GET 'REFRESH' FLAG
	HLLM	T1,%HOM+HOMREF	;SAVE IN HOME PAGE
	HRRZ	T1,STRDDB+STRHSH ;
	HRLZM	T1,%HOM+HOMHSH	;
	HRRZ	T1,RANNO	;
	HRRM	T1,%HOM+HOMRAN	;
	MOVE	T1,STROVR(P2)	;GET -VE # PAGES USER IS ALLOWED TO OVERDRAW
	MOVEM	T1,%HOM+HOMOVR	;SAVE IN HOME PAGE
	MOVE	T1,STRP4C(P2)	;GET # PAGES FOR CRASH.SAV
	MOVEM	T1,%HOM+HOMP4C	;SAVE IN HOME PAGE

UPDHM3:	MOVE	T1,UNILOG(U)	;GET SIXBIT LOGICAL UNIT WITHIN STR
	MOVEM	T1,%HOM+HOMLOG	;SAVE IN HOME PAGE
	LDB	T1,UNYLUN	;GET LOGICAL UNIT # WITHIN STR
	MOVEM	T1,%HOM+HOMLUN	;SAVE IN HOME PAGE
	LDB	T1,UNYP4S	;GET # PAGES FOR SWAPPING ON THIS UNIT.
	MOVEM	T1,%HOM+HOMP4S	;SAVE IN HOME PAGE.
	MOVE	T1,UNISUN(U)	;GET LOG. UNIT # IN ASL
	MOVEM	T1,%HOM+HOMSUN	;SAVE IN HOME PAGE
	CAIE	T1,SWPMAX-1	;IF THE MAX NUMBER, NO FOLLOWING ENTRY
	SKIPN	T1,SWPTAB+1(T1)	;GET UNIT DATA BLOCK ADR. OF NEXT UNIT IN ASL
	TDZA	T1,T1		;MAKE SURE T1 IS 0 (MAX UNIT OR NO SUCCESSOR)
	MOVE	T1,UNIHID(T1)	;GET ITS SIXBIT ID
	MOVEM	T1,%HOM+HOMSID	;SAVE IN HOME PAGE
	MOVE	T1,UNISLB(U)	;GET 1ST. LOG. BLOCK # FOR SWAPPING
	MOVEM	T1,%HOM+HOMSLB	;SAVE IN HOME PAGE
	LDB	T1,UNYCFS	;GET CLASS FOR SWAPPING
	MOVEM	T1,%HOM+HOMCFS	;SAVE IN HOME PAGE
	LDB	T1,UNYSPU	;GET # SAT BLOCKS PER UNIT
	MOVEM	T1,%HOM+HOMSPU	;SAVE IN HOME PAGE
	MOVEI	T1,%HOM+HOMEND+1 ;FIRST WORD TO CLEAR.
	CAILE	T1,%HOM+HOMDAT-1 ;SKIP IF AT LEAST ONE WORD.
	JRST	UPDHM4
	SETZM	(T1)		;CLEAR THE FIRST WORD
	CAIN	T1,%HOM+HOMDAT-1	;SKIP IF MORE
	JRST	UPDHM4
	MOVE	T1,[XWD %HOM+HOMEND+1,%HOM+HOMEND+2]
	BLT	T1,%HOM+HOMDAT-1	;CLEAR UNUSED WORDS
    ;HERE TO WRITE OUT.
UPDHM4:	MOVEM	P3,%HOM+PAGCOD	;SAVE CODE WORD IN HOME PAGE.
	MOVSI	P2,(SIXBIT .HOM.) ;RESTORE ARG.
	PUSHJ	P,WTBOTH	;WRITE OUT BOTH HOME PAGES
	STOPCD
	POPJ	P,		;RETURN

TYPSPC:	MOVE P1,NMSTPC
	MOVEI T1,[ASCIZ /NUMBER OF SAT PCBS = /]
	PJRST DECLOP

CHGSPC:	MOVEI T1,5
	MOVEM T1,MIN
	MOVEI T1,^D20
	MOVEM T1,MAX
	MOVEI T1,[ASCIZ /NUMBER OF SAT PCBS = /]
	MOVE P1,NMSTPC
	PUSHJ P,ASKQMM
	 POPJ P,
	MOVEM T2,NMSTPC
	POPJ P,


TYPRPC:	MOVE	P1,NMRBPC
	MOVEI	T1,[ASCIZ /NUMBER OF RIB PCBS = /]
	PJRST	DECLOP

CHGRPC:	MOVEI	T1,5
	MOVEM	T1,MIN
	MOVEI	T1,^D20
	MOVEM	T1,MAX
	MOVEI	T1,[ASCIZ /NUMBER OF RIB PCBS = /]
	MOVE	P1,NMRBPC
	PUSHJ	P,ASKQMM
	POPJ	P,
	MOVEM	T2,NMRBPC
	POPJ	P,

CHGBAT:	MOVEI	T1,[ASCIZ /TYPE UNIT NAME TO REFRESH BAT PAGES/]
	PUSHJ	P,CONOUT
	PUSHJ	P,GETUNI
	POPJ	P,
	PUSHJ	P,BATREF
	POPJ	P,
	POPJ	P,

TYPBAT:	MOVEI	T1,[ASCIZ /TYPE UNIT NAME/]
	PUSHJ	P,CONOUT
	PUSHJ	P,GETUNI
	POPJ	P,
	SETZM	BATMAN
	PUSHJ	P,CHKBAT
	JFCL			;IGNORE ERRORS.
	MOVE	T2,%BAT+BATFIR
	ADDI	T2,%BAT
	SETZB	P3,P1		;P1 IS PAGE COUNT, P3 REGION COUNT.
TYPBT1:	SKIPN	1(T2)
	JRST	TYPBT2		;DONE.
	ADDI	P3,1		;1 REGION.
	LDB	T1,BAYNBB
	ADDI	P1,1(T1)	;THIS MANY PAGES.
	AOBJP	T2,TYPBT2
	AOBJN	T2,TYPBT1
TYPBT2:	MOVEI	T1,[ASCIZ /# BAD PAGES = /]
	PUSHJ	P,DECLOP
	MOVE	P1,P3
	MOVEI	T1,[ASCIZ /# BAD REGIONS = /]
	PJRST	DECLOP

	LIT
	VAR


ONDLNR=.-%OND+1
ONDLNP=<ONDLNR!777>+1

ONSZCK(ONCDSK,OND)	;CHECK TO SEE IF ENOUGH PAGES ALLOCATED

DEPHASE

	END
 @
<\