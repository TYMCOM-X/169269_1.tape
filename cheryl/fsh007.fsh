42XFORMAT01:Peak V2(301)     Command Module     06-Jun     3 1984       




                                                      
                                                      
                                                      
                                          
                                          
                                          
                                    
                                    
                                    
                              
                              
                              
                              
                              
                              
                              
                              
                              
                                                      
                                                      
                                                      



                                          
                                          
                                          
                              
                              
                              
                                    
                                    
                                    
                  
                  
                  
                  
                  
                  
                        
                        
                        
                              
                              
                              




                            
                 
                 
                  
              
                
                          

     Cre: 29-Mar-84  14:35  (PEAKX)COMM5.REQ                            Page 1-1
     Prt: 06-Jun-84  13:54                     COMM5 - Commands related to modes

     
     ! *************************************************************************
     *                                                                         *
     *                                  COMM5                                  *
     *                        Commands related to modes                        *
     *                                                                         *
     ***************************************************************************
     
     
                This file is required as a source!file in COMAND.SAI.
     
     
     **************************************************************************;
     Cre: 29-Mar-84  14:35  (PEAKX)COMM5.REQ                            Page 2-1
     Prt: 06-Jun-84  13:54                                            Rtn C!Lock

     
     ! "Lock" and "Unlock" the file (make it read only). ;
     
     simple procedure C!Lock;
       begin |1       C!ArgV := 0;
         if ( B!Lock >= 0 ) then
           B!Lock := 1;
         W!NewS;
       end; |1|
     
     Cre: 29-Mar-84  14:35  (PEAKX)COMM5.REQ                            Page 3-1
     Prt: 06-Jun-84  13:54                                          Rtn C!UnLock

     
     simple procedure C!UnLock;
       begin |1|
         C!ArgV := 0;
         if ( B!Lock >= 0 ) then
           B!Lock := 0
         else
           W!Msg( "Buffer is locked!" );
         W!NewS;
       end; |1|
     Cre: 29-Mar-84  14:35  (PEAKX)COMM5.REQ                            Page 4-1
     Prt: 06-Jun-84  13:54                                      Rtn C!NormalMode

     
     ! "Normal" (programming) mode.
     ;
     
     simple procedure C!NormalMode;
     begin "C!NormalMode" |1|
       clear(G!TextMode);
     
       if (B!Mode[inf for 1] = "+") then
         B!Mode _ "Normal+"
       else
         B!Mode _ "Normal";
     
       W!NewS;
       C!ArgV _ 0;
     end "C!NormalMode"; |1|
     Cre: 29-Mar-84  14:35  (PEAKX)COMM5.REQ                            Page 5-1
     Prt: 06-Jun-84  13:54                                        Rtn C!TextMode

     
     ! "Text" mode.  For banging in prose and such.
     ;
     
     simple procedure C!TextMode;
     begin "C!TextMode" |1|
       set(G!TextMode);
     
       if (B!Mode[inf for 1] = "+") then
         B!Mode _ "Text+"
       else
         B!Mode _ "Text";
     
       W!NewS;
       C!ArgV _ 0;
     end "C!TextMode"; |1|
     
     
     ! *************************  End of COMM5.REQ  ***************************;





                                                      
                                                      
                                                      
                                          
                                          
                                          
                                    
                                    
                                    
                              
                              
                              
                              
                              
                              
                              
                              
                              
                                                      
                                                      
                                                      



                              
                              
                              
                              
                              
                              
                        
                        
                        
                                    
                                    
                                    
                        
                        
                        
                        
                        
                        
                              
                              
                              




                          
                 
               
                     
               
                
                          

     Cre: 09-Apr-83  15:31  (PEAKX)COMM6.REQ                            Page 1-1
     Prt: 06-Jun-84  13:54             COMM6 - Commands to manipulate the window

     
     ! *************************************************************************
     *                                                                         *
     *                                  COMM6                                  *
     *                    Commands to manipulate the window                    *
     *                                                                         *
     ***************************************************************************
     
     
                This file is required as a source!file in COMAND.SAI.
     
     
     **************************************************************************;
     Cre: 09-Apr-83  15:31  (PEAKX)COMM6.REQ                            Page 2-1
     Prt: 06-Jun-84  13:54                                      Rtn C!ToggleWrap

     
     simple procedure C!ToggleWrap;
       begin |1|
         C!ArgV := 0;
         if ( G!WrapP ) then
           G!WrapP := 0
         else
           G!WrapP := 1;
         W!NewS;
       end; |1|
     Cre: 09-Apr-83  15:31  (PEAKX)COMM6.REQ                            Page 3-1
     Prt: 06-Jun-84  13:54                                              Rtn C!W1

     
     ! Back to one window.
     ;
     
     simple procedure C!W1;
       begin "1" |1|
         external procedure W!1;
     
         C!ArgV := 0;
         W!1;
         W!FixS;
     
       end "1"; |1|
     Cre: 09-Apr-83  15:31  (PEAKX)COMM6.REQ                            Page 4-1
     Prt: 06-Jun-84  13:54                                              Rtn C!W2

     
     ! split the screen
     ;
     
     simple procedure C!W2;
       begin "2" |1|
         external procedure W!2;
     
         C!ArgV := 0;
         W!2;
     
       end "2"; |1|
     Cre: 09-Apr-83  15:31  (PEAKX)COMM6.REQ                            Page 5-1
     Prt: 06-Jun-84  13:54                                         Rtn C!WSwitch

     
     ! move to the other window
     ;
     
     simple procedure C!WSwitch;
       begin "switch" |1|
         external procedure W!Switch;
     
         W!Disp( true );     ! make sure our image of this window is correct ;
         W!Switch;
         W!FixS;
         C!ArgV := 0;
     
       end "switch"; |1|
     Cre: 09-Apr-83  15:31  (PEAKX)COMM6.REQ                            Page 6-1
     Prt: 06-Jun-84  13:54                                           Rtn C!WGrow

     
     ! Grow this window by a line
     ;
     
     simple procedure C!WGrow;
       begin "grow" |1|
         external procedure W!Grow;
     
         W!Grow;
         C!ArgV := 0;
     
       end "grow"; |1|
     Cre: 09-Apr-83  15:31  (PEAKX)COMM6.REQ                            Page 7-1
     Prt: 06-Jun-84  13:54                                            Rtn C!WBar

     
     ! Routine to let the user build his own window bar ;
     
     
     simple procedure C!WBar;
       begin "bar" |1|
         external string W!Bar;
     
         C!ArgV := 0;
         if ( not C!ReadString( "New Bar: ", ESC, ESC )) then
           W!Msg( "Aborted" )
         else
           W!Bar := C!String;
     
       end "bar"; |1|
     
     
     ! ************************** End of COMM6.REQ ****************************;





                                                      
                                                      
                                                      
                                          
                                          
                                          
                                    
                                    
                                    
                              
                              
                              
                              
                              
                              
                              
                              
                              
                                                      
                                                      
                                                      



                                          
                                          
                                          
                              
                              
                              
                        
                        
                        
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  




                            
                 
               
                  
              
               
                        

     Cre: 14-Mar-84  14:42  (PEAKX)COMM7.REQ                            Page 1-1
     Prt: 06-Jun-84  13:54                       COMM7 - The Runtime Help System

     
     ! *************************************************************************
     *                                                                         *
     *                                  COMM7                                  *
     *                         The Runtime Help System                         *
     *                                                                         *
     ***************************************************************************
     
     
                This file is required as a source!file in COMAND.SAI.
     
     
     **************************************************************************;
     Cre: 14-Mar-84  14:42  (PEAKX)COMM7.REQ                            Page 2-1
     Prt: 06-Jun-84  13:54                                     Rtn ShowFileInBox

     
     ! The routine to run a file through the box.
     ;
     
     ! <<  This approach to showing help should be abandoned in favor of a
     !     "special Help Buffer" approach in 2.0 and better.
     ;
     
     procedure ShowFileInBox (string F);
     begin "show file in box" |1|
       ifcr TymcomX thenc
         string L;
         integer C, SaveILP;
         external integer T!ILP;     ! scroll flag in terminal module ;
     
         if ( not F!Lookup( F ) ) then
           begin |2|
             W!Msg( "% Can't lookup "&F&" for box display" );
             return;
           end; |2|
     
         SaveILP := T!ILP;           ! turn off scrolling for smooth ;
         T!ILP := false;             ! box display ;
     
         while ( true ) do
           begin "each page" |2|
     
             while ( true ) do
               begin "this page" |3|
                 L := NULL;
                 while (( C := F!GetC ) >= " " ) do L := L & C;
                 W!BAdd( L );
                 if (( C = FF ) or ( C <= '0 )) then done "this page";
                 if ( C = CR ) then C := F!GetC;
               end "this page"; |3|
     
             if ( C > 0 ) then
               begin |3|
                 W!Msg( "-More-" );  C := C!GetC;
                 if ( C!Tab[ C ] land (IsAbort+IsNo)) then done "each page";
                 W!BClr;
               end |3|
             else
               begin |3|
                 W!Msg( "-No More-" );  C := C!GetC;
                 done "each page"
               end; |3|
             
           end "each page"; |2|
     
         T!ILP := SaveILP;
     
         F!Release;
       endc
     
       ifcr Tops20 thenc
     Cre: 14-Mar-84  14:42  (PEAKX)COMM7.REQ                            Page 2-2
     Prt: 06-Jun-84  13:54                                     Rtn ShowFileInBox

         string
           L;
         integer
           C,
           F!Chan,
           SaveILP;
         external integer
           T!ILP;                            ! Scroll flag in terminal module.  
                                             ;
     
         F!Chan _ openfile(F, "NOE");
     
         if (!skip!) then
         begin |2|
           W!Msg("% Can't lookup " & F & " for box display");
           return;
         end; |2|
     
         SaveILP _ T!ILP;            ! turn off scrolling for smooth ;
         clear(T!ILP);               ! box display ;
     
         while (true) do
         begin "each page" |2|
           while (true) do
           begin "this page" |3|
             L _ null;
     
             while ((C _ charin(F!Chan)) >= " ") do
               appnd(L, C);
     
             W!BAdd(L);
     
             if ((C = FF) or (C = '0)) then
               done "this page";
     
             if (C = CR) then
               C _ charin(F!Chan);
           end "this page"; |3|
     
           if (C neq 0) then
           begin |3|
             W!Msg("-More-");  C _ C!GetC;
     
             if (C!Tab[C] land (IsAbort+IsNo)) then
               done "each page";
     
             W!BClr;
           end |3|
           else
           begin |3|
             W!Msg("-No More-");
             C _ C!GetC;
             done "each page"
           end; |3|
         end "each page"; |2|
     
     Cre: 14-Mar-84  14:42  (PEAKX)COMM7.REQ                            Page 2-3
     Prt: 06-Jun-84  13:54                                     Rtn ShowFileInBox

         T!ILP _ SaveILP;
     
         cfile(F!Chan);
       endc
     end "show file in box"; |1|
     Cre: 14-Mar-84  14:42  (PEAKX)COMM7.REQ                            Page 3-1
     Prt: 06-Jun-84  13:54                                            Rtn C!Help

     
     ! The main routine for help.
     ;
     
     simple procedure C!Help;
     begin "help" |1|
       integer
         C,
         RunAUN;
       string
         AUNStr;
     
       ifcr TymcomX thenc
         C!ArgV _ 0;
         W!BSet(true);
         W!MsgF _ true;
     
         if (not C!Debug) then
         begin |2|
           W!BClr;
           W!BAdd("                    PEAK Online Help");
           W!BAdd(null);
           W!BAdd("                  Type N or ^G to quit");
           W!BAdd("          Type any other character to continue");
           W!BAdd(null);
           W!BAdd("                     Open Buffers:");
           W!BAdd(null);
           B!BufStat;
     
           W!Msg("-More-");
           C _ C!GetC;
     
           if (not(C!Tab[C] land (IsAbort+IsNo))) then
           begin |3|
             W!BClr;
             RunAUN _ call(xwd(-1, -'25), "gettab");         ! "file" aun ;
             AUNStr _ "[" & cvos(RunAUN lsh -18) &
                       "," & cvos(RunAUN land '777777) & "]";
             ShowFileInBox("PEAK.HLP" & AUNStr);
           end; |3|
         end |2|
         else
         begin |2|
           W!Msg("-Type any character to clear-");
           C!GetC;
         end; |2|
     
         W!Msg(null);
         W!MsgF _ false;
         W!BSet(false);
       endc
     
       ifcr Tops20 thenc
         T!Bell;
         W!Msg("Help is not availible at this time");
       endc
     Cre: 14-Mar-84  14:42  (PEAKX)COMM7.REQ                            Page 3-2
     Prt: 06-Jun-84  13:54                                            Rtn C!Help

     end "help"; |1|
     
     
     ! ************************** End of COMM7.REQ ****************************;





                                                      
                                                      
                                                      
                                          
                                          
                                          
                                    
                                    
                                    
                              
                              
                              
                              
                              
                              
                              
                              
                              
                                                      
                                                      
                                                      



                              
                              
                              
                                    
                                    
                                    
                              
                              
                              
                              
                              
                              
                        
                        
                        
                        
                        
                        
                              
                              
                              




                          
                  
                
                    
               
                
                          

     Cre: 19-Apr-84  16:20  (PEAKX)COMM8.REQ                            Page 1-1
     Prt: 06-Jun-84  13:54                          COMM8 - Network I/O Commands

     
     ! *************************************************************************
     *                                                                         *
     *                                  COMM8                                  *
     *                           Network I/O Commands                          *
     *                                                                         *
     ***************************************************************************
     
     
                This file is required as a source!file in COMAND.SAI.
     
     
     **************************************************************************;
     
     
     external integer procedure
       A!CreAux (reference string LoginStr);
     
         ! A!CreAux creates an aux circuit and returns the port number it is
         ! established on. The argument is updated as omitted portions are
         ! filled in with defaults.
         ;
     
     external procedure
       A!AuxWin (reference integer AuxPort);
     
         ! A!AuxWin actually causes the interaction to be inserted into the
         ! buffer.  It calls B!Insert and W!Msg.
         ;
     
     
     ! ------------------------------------------------------------------------;
     Cre: 19-Apr-84  16:20  (PEAKX)COMM8.REQ                            Page 2-1
     Prt: 06-Jun-84  13:54                                       Rtn C!SetCreEsc

     
     ! Set the CreAux Escape character.
     ;
     
     simple procedure C!SetCreEsc;
     begin "C!SetCreEsc" |1|
       string
         Prompt;
     
       Prompt _ "New CreAux escape character: ";
     
       W!Msg(Prompt);
       C!CreEscChr _ C!GetC;
       W!Msg(Prompt & CvCmdChr(C!CreEscChr));
     
       C!ArgV _ 0;
     end "C!SetCreEsc"; |1|
     Cre: 19-Apr-84  16:20  (PEAKX)COMM8.REQ                            Page 3-1
     Prt: 06-Jun-84  13:54                                          Rtn C!CreAux

     
     ! Create an Aux Circuit session in the current window.
     ;
     
     procedure C!CreAux;
     begin |1|
       string
         Prompt;
     
       Prompt _ "Login: ";
     
       if (B!Lock) then
       begin |2|
         W!Msg(Prompt & "[failed]");
         W!Msg2("[buffer locked]");
         return;
       end; |2|
     
       if (C!AuxPort < 0) then
       begin |2|
         if (not C!ReadString(Prompt, CR, ESC)) then
         begin |3|
           W!Msg(Prompt & "[Aborted]");
           return;
         end; |3|
     
         C!AuxStr _ C!String;
         C!AuxPort _ A!CreAux(C!AuxStr);
     
           ! The message line is updated as necessary by A!CreAux.
           ;
       end |2|
       else
         W!Msg(Prompt & C!AuxStr & " [continued]");
     
       clear(W!MsgF);
       A!AuxWin(C!AuxPort);
       W!FixS;
     
       if (C!AuxPort >= 0) then
         W!Msg(Prompt & C!AuxStr & " [circuit remains]")
       else
         W!Msg(Prompt & C!AuxStr & " [circuit zapped]");
     end; |1|
     
                                
     ! *************************  End of Comm8.Req  ***************************;





                                                      
                                                      
                                                      
                                          
                                          
                                          
                                    
                                    
                                    
                              
                              
                              
                              
                              
                              
                              
                              
                              
                                                      
                                                      
                                                      



                                                            
                                                            
                                                            
                              
                              
                              
                              
                              
                              
                                                      
                                                      
                                                      
                              
                              
                              
                              
                              
                              
                                                                              
                                                                              
                                                                              




                               
                 
                
                        
                
                 
                                  

     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                           Page 1-1
     Prt: 06-Jun-84  13:54                          COMSUB - Command Subroutines

     
     ! *************************************************************************
     *                                                                         *
     *                                 COMSUB                                  *
     *                           Command Subroutines                           *
     *                                                                         *
     ***************************************************************************
     
     
                This file is required as a source!file in COMAND.SAI.
     
     
     **************************************************************************;
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                           Page 2-1
     Prt: 06-Jun-84  13:54                                        Rtn C!IsAlphaP

     
     ! Predicate functions to help us scan for thingies ;
     
     ! Predicate to tell if the point character is alphabetic ;
     
     simple boolean procedure C!IsAlphaP;
       return( C!Tab[ B!GetC ] land IsAlpha );
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                           Page 3-1
     Prt: 06-Jun-84  13:54                                        Rtn C!IsDelimP

     
     ! Predicate to tell if the point character may be a delimiter ;
     
     simple boolean procedure C!IsDelimP;
       return( C!Tab[ B!GetC ] land IsDelim );
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                           Page 4-1
     Prt: 06-Jun-84  13:54                                        Rtn C!IsWhiteP

     
     ! Predicate to tell if the point character is whitespace ;
     
     simple boolean procedure C!IsWhiteP;
       return( C!Tab[ B!GetC ] land IsWhite );
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                           Page 5-1
     Prt: 06-Jun-84  13:54                                         Rtn C!IsGrayP

     
     ! Predicate to tell if the current character is grayspace ;
     
     simple boolean procedure C!IsGrayP;
       return( C!Tab[ B!GetC ] land ( IsWhite+IsEOL ) );
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                           Page 6-1
     Prt: 06-Jun-84  13:54                                          Rtn C!IsEOLP

     
     ! Predicate to tell if the current character is an end of line ;
     
     simple boolean procedure C!IsEOLP;
       return( C!Tab[ B!GetC ] land IsEOL );
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                           Page 7-1
     Prt: 06-Jun-84  13:54                                       Rtn C!IsSpecial

     
     ! Predicate to tell if the the current character is 'special' ;
     
     simple boolean procedure C!IsSpecial;
       return( C!Tab[ B!GetC ] land IsSpecial );
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                           Page 8-1
     Prt: 06-Jun-84  13:54                                             Rtn AtEOL

     
     ! Routines to help deal with different flavors of end-of-line ;
     
     simple boolean procedure AtEOL;
       begin |1|
         if ( B!EndP or ( B!GetC = FF )) then return( true );
         if ( B!GetC neq CR ) then return( false );
         B!Move( FORWARDS );
         if ( B!EndP or ( B!GetC = LF )) then
           begin |2|
             B!Move( BACKWARDS );
             return( true );
           end |2|
         else
           begin |2|
             B!Move( BACKWARDS );
             return( false );
           end; |2|
       end; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                           Page 9-1
     Prt: 06-Jun-84  13:54                                          Rtn AfterEOL

     
     simple boolean procedure AfterEOL;
       begin |1|
         if ( B!BegP ) then return( true );
         B!Move( BACKWARDS );
         if ( B!GetC = FF ) then
           begin |2|
             B!Move( FORWARDS );
             return( true );
           end |2|
         else if ( B!GetC = LF ) then
           begin |2|
             B!Move( BACKWARDS );
             if ( B!BegP or ( B!GetC = CR )) then
               begin |3|
                 B!Move( FORWARDS ); B!Move( FORWARDS );
                 return( true );
               end |3|
             else
               begin |3|
                 B!Move( FORWARDS );  B!Move( FORWARDS );
                 return( false );
               end; |3|
           end |2|
         else
           begin |2|
             B!Move( FORWARDS );
             return( false );
           end; |2|
       end; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 10-1
     Prt: 06-Jun-84  13:54                                      Rtn MoveForwards

     
     ! Procedures to help us move about ;
     
     simple procedure MoveForwards;
       begin "move forwards" |1|
         own integer C;
     
         C := B!GetC;
         B!Move( FORWARDS );
         if (( C = CR ) and ( B!GetC = LF )) then B!Move( FORWARDS );
     
       end "move forwards"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 11-1
     Prt: 06-Jun-84  13:54                                     Rtn MoveBackwards

     
     simple procedure MoveBackwards;
       begin "move backwards" |1|
     
         if ( B!BegP ) then return;
         B!Move( BACKWARDS );
         if (( B!GetC = LF ) and ( not B!BegP )) then
           begin |2|
             B!Move( BACKWARDS );
             if ( B!GetC neq CR ) then
               B!Move( FORWARDS );
           end; |2|
     
       end "move backwards"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 12-1
     Prt: 06-Jun-84  13:54                                         Rtn MoveToBOL

     
     ! Move to the beginning of the line ;
     
     procedure MoveToBOL;
       begin |1|
         while ( not AfterEOL ) do
           MoveBackwards;
       end; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 13-1
     Prt: 06-Jun-84  13:54                                         Rtn MoveToEOL

     
     ! Move to the end of the current line ;
     
     procedure MoveToEOL;
       begin |1|
         while ( not AtEOL ) do
           MoveForwards;
       end; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 14-1
     Prt: 06-Jun-84  13:54                                      Rtn C!ReadString

     
     ! Routine to read a string until a specified terminator is seen. ;
     
     boolean procedure C!ReadString( string Prompt; integer Delim1, Delim2 );
       begin |1|
         integer C;
         C!String := NULL;
         W!MsgF := true;
         forever do
           begin |2|
             W!Msg( Prompt & C!String );
             C := C!GetC;
             if ( C = '7 ) then
               begin |3|
                 C!String := NULL;
                 W!MsgF := false;
                 return( false );
               end |3|
             else if ( C = Delim1 or C = Delim2 ) then done
             else if ( C = BS or C = DEL ) then
               begin |3|
                 if (( C!String[ INF for 1 ] = LF ) and
                     ( C!String[ INF-1 for 1 ] = CR )) then
                   C!String := C!String[ 1 for INF-2 ]
                 else
                   C!String := C!String[ 1 for INF-1 ];
               end |3|
             else if ( C = '21 ) then                ! ^Q - quote next ;
               C!String := C!String & C!GetC
             else if ( C = CR ) then
               C!String := C!String & ('15&'12)
             else
               C!String := C!String & C;
           end; |2|
         W!Msg( Prompt & C!String & "$" );
         W!MsgF := false;
         return ( true );
       end; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 15-1
     Prt: 06-Jun-84  13:54                                   Rtn C!ReadLitString

     
     ! Routine to read a string until a specified terminator is seen. ;
     ! Note - this is just like C!ReadString, but it doesn't expand <cr>
     !  to <cr><lf> ;
     
     boolean procedure C!ReadLitString( string Prompt; integer Delim1, Delim2 );
       begin |1|
         integer C;
         C!String := NULL;
         W!MsgF := true;
         forever do
           begin |2|
             W!Msg( Prompt & C!String );
             C := C!GetC;
             if ( C = '7 ) then
               begin |3|
                 C!String := NULL;
                 W!MsgF := false;
                 return( false );
               end |3|
             else if ( C = Delim1 or C = Delim2 ) then done
             else if ( C = BS or C = DEL ) then
               begin |3|
                 if (( C!String[ INF for 1 ] = LF ) and
                     ( C!String[ INF-1 for 1 ] = CR )) then
                   C!String := C!String[ 1 for INF-2 ]
                 else
                   C!String := C!String[ 1 for INF-1 ];
               end |3|
             else if ( C = '21 ) then                ! ^Q - quote next ;
               C!String := C!String & C!GetC
             else
               C!String := C!String & C;
           end; |2|
         W!Msg( Prompt & C!String & "$" );
         W!MsgF := false;
         return ( true );
       end; |1|
     
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 16-1
     Prt: 06-Jun-84  13:54                                   Rtn C!ReadESCString

     
     ! Read a string, but allow imbedded ESCapes
     ;
     
     boolean procedure C!ReadESCString( string Prompt );
       begin "read string" |1|
         integer C;
     
         C!String := NULL;
         W!MsgF := true;
     
         forever do
           begin |2|
             W!Msg( Prompt & C!String );
             C := C!GetC;
             if ( C = '7 ) then
               begin |3|
                 C!String := NULL;
                 W!MsgF := false;
                 return( false );
               end |3|
             else if ( C = ESC and ( length( C!String ) = 0 )) then done
             else if ( C = ESC and ( C!String[ Inf for 1 ] = ESC )) then done
             else if ( C = BS or C = DEL ) then
               begin |3|
                 if (( C!String[ INF for 1 ] = LF ) and
                     ( C!String[ INF-1 for 1 ] = CR )) then
                   C!String := C!String[ 1 for INF-2 ]
                 else
                   C!String := C!String[ 1 for INF-1 ];
               end |3|
             else if ( C = '21 ) then                ! ^Q - quote next ;
               C!String := C!String & C!GetC
             else
               C!String := C!String & C;
           end; |2|
         W!Msg( Prompt & C!String & "$" );
         W!MsgF := false;
     
         return ( true );
     
       end "read string"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 17-1
     Prt: 06-Jun-84  13:54                                             Rtn C!Ask

     
     ! Routine to ask a yes/no question ;
     
     internal boolean procedure C!Ask( string Question );
       begin |1|
         while ( true ) do
           begin |2|
             if ( not C!ReadString( Question, ESC, CR )) then
               continue
             else if (( C!String = "Y" ) or ( C!String = "y" )) then
               return( true )
             else if (( C!String = "N" ) or ( C!String = "n" )) then
               return( false );
             T!Bell;
           end; |2|
       end; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 18-1
     Prt: 06-Jun-84  13:54                                          Rtn CVCmdChr

     
     ! Routine to convert a command character into a string
     ;
     
     string procedure CVCmdChr( integer C );
       begin "cv" |1|
         string S;
     
         if ( C >= '400 ) then S := "XMeta "
         else if ( C >= '200 ) then S := "Meta "
         else S := NULL;
     
         C := C land '177;
     
         if ( C = 0 ) then S := S & "Null"
         else if ( C = '33 ) then S := S & "Esc"
         else if ( C = '40 ) then S := S & "Space"
         else if ( C = '177 ) then S := S & "Del"
         else if ( C < '40 ) then S := S & "^" & ( C + '100 )
         else S := S & C;
     
         return( S );
     
       end "cv"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 19-1
     Prt: 06-Jun-84  13:54                                          Rtn CVCmdStr

     
     ! Routine to convert a string of commands into a string
     ;
     
     string procedure CVCmdStr( string Str );
       begin "cv-str" |1|
         string S;
         integer C;
     
       string procedure CV( integer C );
         begin "cv-char" |2|
           string S;
     
           if ( C geq '400 ) then S_ "<XMeta>"
           else if ( C geq '200 ) then S_ "<Meta>"
           else S_ NULL;
           C := C land '177;
           if ( C = 0 ) then S := S & "<Null>"
           else if ( C = '33 ) then S := S & "<Esc>"
           else if ( C = '177 ) then S := S & "<Del>"
           else if ( C < '40 ) then S := S & "^" & ( C + '100 )
           else S := S & C;
           return( S );
         end "cv-char"; |2|
     
         S_ Null;
         while ( length( Str ) ) do
           S_ S & CV( C_ Lop( Str ) );
     
         return( S );
     
       end "cv-str"; |1|
     
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 20-1
     Prt: 06-Jun-84  13:54                                            Rtn MoveTo

     
     ! Some utility routines to find things. ;
     
     ! Move to a thingy.  Calls 'ThingP' at each step, returning when
     !  the predicate returns true.  If by some chance we run into either
     !  the beginning or end of the buffer before finding a thingy, then
     !  return false. ;
     
     boolean procedure MoveTo( boolean procedure ThingP; integer Dir );
       begin "move to" |1|
         forever do
           begin |2|
             if ( Dir = BACKWARDS ) then
               begin |3|
                 if ( B!BegP ) then return( false );
                 B!Move( BACKWARDS );
                 if ( ThingP ) then return( true );
               end |3|
             else if ( Dir = FORWARDS ) then
               begin |3|
                 if ( ThingP ) then return( true );
                 B!Move( FORWARDS );
                 if ( B!EndP ) then return( false );
               end |3|
             else
               usererr( 0,0,"[MoveTo]" );
           end; |2|
       end "move to"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 21-1
     Prt: 06-Jun-84  13:54                                          Rtn MovePast

     
     ! Move past a thingy.  Calls 'ThingP' until we pass the thingy.
     !  Return true unless we run into the beginning or end of the buffer. ;
     
     boolean procedure MovePast( boolean procedure ThingP; integer Dir );
       begin "move past" |1|
         forever do
           begin |2|
             if ( Dir = FORWARDS ) then
               begin |3|
                 B!Move( FORWARDS );
                 if ( B!EndP or not ThingP ) then return( true );
               end |3|
             else if ( Dir = BACKWARDS ) then
               begin |3|
                 B!Move( BACKWARDS );
                 if ( B!BegP or not ThingP ) then return( true );
               end |3|
             else
               usererr( 0,0,"[MovePast]" );
           end; |2|
       end "move past"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 22-1
     Prt: 06-Jun-84  13:54                                         Rtn CharWidth

     
     ! Routine to tell us how "wide" a character is in a given column ;
     
     integer procedure CharWidth( integer C, Col );
       begin |1|
         integer Temp;
     
         if (( C >= " " ) and ( C < '177 )) then
           return( 1 )
         else if ( C = CR ) then
           return( 0 )               ! "should" never hit this case ;
         else if ( C = ESC ) then
           begin |2|
             if ( G!ESCF ) then return( 1 ) else return( 2 );
           end |2|
         else if ( C = TAB ) then
           begin |2|
             Temp := 1;
             while ( Col mod C!TABWidth ) do         ! ** hack ** ;
               begin |3|
                 Temp := Temp + 1;
                 Col := Col + 1;
               end; |3|
             return( Temp );
           end |2|
         else
           return( 2 )
       end; |1|
     
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 23-1
     Prt: 06-Jun-84  13:54                                         Rtn GetColumn

     
     ! Routine to tell us what column we're on ;
     
     simple integer procedure GetColumn;
     begin |1|
       integer
         SavePoint,
         Col,
         C;
     
       SavePoint _ B!GetP;
       MoveToBOL;
       Col _ 1;
     
       while (SavePoint neq B!GetP) do
       begin |2|
         incr(Col, CharWidth(B!GetC, Col));
         B!Move(FORWARDS);
       end; |2|
     
       return(Col);
     end; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 24-1
     Prt: 06-Jun-84  13:54                                         Rtn GetIndent

     
     ! Tell us how much the current line is indented.
     ;
     
     simple integer procedure GetIndent;
     begin |1|
       integer
         SavePoint,
         Indent,
         C;
     
       SavePoint _ B!GetP;
       MoveToBOL;
       Indent _ 1;
     
       while (C!IsWhiteP) do
       begin |2|
         incr(Indent, CharWidth(B!GetC, Indent));
         B!Move(FORWARDS);
       end; |2|
     
       B!SetP(SavePoint);
       return(Indent - 1);
     end; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 25-1
     Prt: 06-Jun-84  13:54                                         Rtn TryColumn

     
     ! Try to get to a specified column on the current line.
     ;
     
     simple procedure TryColumn (integer DesiredColumn);
     begin |1|
       integer
         ThisCol,
         C;
     
       ThisCol _ GetColumn;
     
       if (ThisCol > DesiredColumn) then
       begin |2|
         MoveToBOL;
         ThisCol _ 1;
       end; |2|
     
       while (ThisCol < DesiredColumn) do
       begin |2|
         C _ B!GetC;
     
         if (C = CR or C = FF) then
           done;
     
         B!Move(FORWARDS);
         incr(ThisCol, CharWidth(C, ThisCol));
       end; |2|
     end; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 26-1
     Prt: 06-Jun-84  13:54                                       Rtn ForceIndent

     
     ! Force the indentation of the current line to be a specified width,
     ! using Tabs iff C!UseTabs is true.
     ;
     
     simple procedure ForceIndent (integer HowMuch);
     begin |1|
       integer
         NewColumn,
         SpsToAdd,
         TabsToAdd;
     
       if (HowMuch < 0) then
         HowMuch _ 0;
     
       NewColumn _ (GetColumn + (HowMuch - GetIndent)) max 1;
     
       TabsToAdd _ 0;
       SpsToAdd  _ HowMuch;
     
       if (C!UseTabs) then
       begin |2|
         TabsToAdd _ HowMuch div C!TabWidth;
         SpsToAdd  _ HowMuch mod C!TabWidth; 
       end; |2|
     
       MoveToBOL;
     
       while (C!IsWhiteP) do
         B!Delete(FORWARDS);
     
       while (TabsToAdd) do
       begin |2|
         B!Insert(Tab);
         decr(TabsToAdd);
       end; |2|
     
       while (SpsToAdd) do
       begin |2|
         B!Insert(" ");
         decr(SpsToAdd);
       end; |2|
     
       TryColumn(NewColumn);
     end; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 27-1
     Prt: 06-Jun-84  13:54                                     Rtn ForwardSearch

     
     ! Routine to search through the buffer for a string. ;
     !  This code rewritten 4/14/82 for case matching. ;
     !  Revamped 4/22/82 to reduce use of string-space. ;
     
     procedure ForwardSearch( string TargetString );
       begin "forward search" |1|
         integer SavePoint, TempSavePoint, C;
         integer CS!Idx, CS!MaxIdx;
         integer array CS!Str[ 1 : MAXSEARCHSTRING ];
     
         CS!MaxIdx := 0;
         while ( length( TargetString )) do
           begin |2|
             CS!MaxIdx := CS!MaxIdx + 1;
             CS!Str[ CS!MaxIdx ] := lop( TargetString );
           end; |2|
     
         SavePoint := B!GetP;
     
         CS!Idx := 1;
         while ( CS!Idx <= CS!MaxIdx ) do
           begin "search" |2|
             if ( B!EndP ) then done "search" ;
             TempSavePoint := B!GetP;
             while ( CS!Idx <= CS!MaxIdx ) do
               begin "subsearch" |3|
                 C := B!GetC;
                 B!Move( FORWARDS );
                 if (( G!CaseMatch ) and ( CS!Str[ CS!Idx ] = C )) then
                   CS!Idx := CS!Idx + 1
                 else if (( not G!CaseMatch ) and
                          ( RH( C!Tab[CS!Str[CS!Idx]] ) = RH( C!Tab[ C ] ))) th|
                                                                          ->|en|
                   CS!Idx := CS!Idx + 1
                 else
                   begin |4|
                     B!SetP( TempSavePoint );
                     B!Move( FORWARDS );
                     CS!Idx := 1;
                     done "subsearch" ;
                   end; |4|
               end "subsearch" ; |3|
           end "search" ; |2|
     
         if ( CS!Idx <= CS!MaxIdx ) then     ! search failed ;
           B!SetP( SavePoint );
     
       end "forward search"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 28-1
     Prt: 06-Jun-84  13:54                                    Rtn BackwardSearch

     
     ! Search backwards throught the buffer for a string. ;
     !  Reworked 5/22/82 to reduce use of stringspace. ;
     
     procedure BackwardSearch( string TargetString );
       begin "backward search" |1|
         integer SavePoint, TempSavePoint, C;
         integer CS!Idx, CS!MaxIdx;
         integer array CS!Str[ 1 : MAXSEARCHSTRING ];
     
         CS!MaxIdx := 0;
         while ( length( TargetString )) do
           begin |2|
             CS!MaxIdx := CS!MaxIdx + 1;
             CS!Str[ CS!MaxIdx ] := lop( TargetString );
           end; |2|
     
         SavePoint := B!GetP;
         CS!Idx := CS!MaxIdx;
     
         while ( CS!Idx > 0 ) do
           begin "search" |2|
             TempSavePoint := B!GetP;
             while ( CS!Idx > 0 ) do
               begin "subsearch" |3|
                 if ( B!BegP ) then done "search";
                 B!Move( BACKWARDS );
                 C := B!GetC;
                 if (( G!CaseMatch ) and ( CS!Str[ CS!Idx ] = C )) then
                   CS!Idx := CS!Idx - 1
                 else if (( not G!CaseMatch ) and
                          ( RH( C!Tab[CS!Str[CS!Idx]] ) = RH( C!Tab[ C ] ))) th|
                                                                          ->|en|
                   CS!Idx := CS!Idx - 1
                 else
                   begin |4|
                     B!SetP( TempSavePoint );
                     B!Move( BACKWARDS );
                     CS!Idx := CS!MaxIdx;
                     done "subsearch";
                   end; |4|
               end "subsearch"; |3|
           end "search"; |2|
     
         if ( CS!Idx > 0 ) then
           B!SetP( SavePoint );
     
       end "backward search"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 29-1
     Prt: 06-Jun-84  13:54                                    Rtn MultipleSearch

     
     ! Return the index of the string which is matched, or zero if none
     ! matches. ;
     
     integer procedure MultipleSearch( string TargetString );
     begin "multiple search" |1|
       integer ResetPoint, TempPoint, C, I, SuperMatchIdx;
       integer CS!Num, CS!Idx, CS!MaxIdx, CS!Delim;
       integer array CS!Len[ 1 : MAXMSEARCH ];
       boolean array  Match[ 1 : MAXMSEARCH ];
       integer array CS!Str[ 1 : MAXMSEARCH, 1 : MAXSEARCHSTRING ];
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 30-1
     Prt: 06-Jun-84  13:54                                           Rtn IsMatch

     
     ! True if there is a match in some target thus far. ;
     
       boolean procedure IsMatch;
       begin |2|
         for I := 1 step 1 until CS!Num do
           if (Match[I]) then
             return(true);
     
         return(false);
       end; |2|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 31-1
     Prt: 06-Jun-84  13:54                                          Rtn IsLength

     
     ! True if there is still some target length left. ;
     
       simple boolean procedure IsLength;
       begin |2|
         return(CS!Idx <= CS!MaxIdx);
       end; |2|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 32-1
     Prt: 06-Jun-84  13:54                                   Body MultipleSearch

     
     ! Mainline Code ;
     
       CS!Num := 0;  CS!MaxIdx := 0;
       arrclr( CS!Len );
       CS!Delim := TargetString[ inf for 1 ];
     
       while ( length( TargetString )) do
       begin "each string" |2|
         CS!Num := CS!Num + 1;
     
         if ( CS!Num > MAXMSEARCH ) then
         begin |3|
           W!Msg( "Too many search strings specified." );
           return( 0 );
         end; |3|
     
         while ( TargetString neq CS!Delim ) do
         begin |3|
           CS!Len[ CS!Num ] := CS!Len[ CS!Num ] + 1;
           CS!Str[ CS!Num, CS!Len[ CS!Num ] ] := lop( TargetString );
         end; |3|
         lop( TargetString );
         CS!MaxIdx := CS!MaxIdx max CS!Len[ CS!Num ];
       end "each string"; |2|
     
     !                  Search for a match with some target.
     ;
     
       ResetPoint := TempPoint := B!GetP;
       CS!Idx := 1;
       SuperMatchIdx := 0;
     
       while ( not B!EndP ) do
       begin "overall" |2|
         arrclr( Match, true );
     
         do
         begin |3|
           C := B!GetC;
     
           for I := 1 step 1 until CS!Num do
           begin "every target" |4|
             if  (
                   Match[I] and
                   (
                     (G!CaseMatch and CS!Str[I, CS!Idx] = C) or
                     (
                       not G!CaseMatch and
                       RH(C!Tab[CS!Str[I, CS!Idx]]) = RH(C!Tab[C])
                     )
                   )
                 ) then
             begin |5|
               Match[I] _ true;
     
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 32-2
     Prt: 06-Jun-84  13:54                                   Body MultipleSearch

               if ( CS!Idx = CS!Len[I] ) then
               begin |6|
                 SuperMatchIdx := I;
                 done "overall";
               end; |6|
             end |5|
             else
               Match[I] _ false;
           end "every target"; |4|
     
           B!Move( FORWARDS );
           CS!Idx := CS!Idx + 1;
         end |3|
         until ( not IsMatch or not IsLength );
     
         TempPoint := TempPoint + 1;
         B!SetP( TempPoint );
         CS!Idx := 1;
       end "overall"; |2|
     
       if ( SuperMatchIdx ) then
       begin |2|
         B!Move( FORWARDS );
         return( SuperMatchIdx );
       end |2|
       else
       begin |2|
         B!SetP( ResetPoint );
         return( 0 );
       end; |2|
     end "multiple search"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 33-1
     Prt: 06-Jun-84  13:54                                a quiet data structure

     
     ! String routines used by various peoples ;
     
     preload!with
      "Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec";
     own safe string array MonthName[ 1:12 ];
     
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 34-1
     Prt: 06-Jun-84  13:54                                           Rtn DateStr

     
     string procedure DateStr;
       begin |1|
         integer UDT, DD, MM, YY;
     
     IFCR TYMCOMX THENC
         UDT := calli('0,'14);
         DD := ( UDT mod 31 ) + 1;
         UDT := UDT div 31;
         MM := ( UDT mod 12 ) + 1;
         YY := ( UDT div 12 ) + 64;
     ENDC
     IFCR TOPS20 THENC
         start!code |2|
           seto 2,;
           setz 4,;
           odcnv;
           hrrzm 2,MM;               ! store month-1 ;
           aos MM;                   ! adjust ;
           hlrz 1,2;
           idivi 1,100;
           movem 2,YY;               ! store year ;
           hlrzm 3,DD;               ! store day-1 ;
           aos DD;                   ! adjust ;
         end; |2|
     ENDC
         return( cvs(DD) & "-" & MonthName[MM] & "-" & cvs(YY) );
       end; |1|
     
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 35-1
     Prt: 06-Jun-84  13:54                                           Rtn TimeStr

     
     string procedure TimeStr;
       begin |1|
         integer T,HH,MM,SS;
     
     IFCR TYMCOMX THENC
         T := calli('0,'22) div 60;
     ENDC
     IFCR TOPS20 THENC
         start!code |2|
           seto 2,;
           setz 4,;
           odcnv;
           hrrzm 4,T;                ! store seconds ;
         end; |2|
     ENDC
         SS := T mod 60;
         T := T div 60;
         HH := T div 60;
         MM := T mod 60;
         return( cvs( HH ) & ":" &
                 cvs( 100 + MM )[2 for 2] & ":" &
                 cvs( 100 + SS )[2 for 2] );
       end; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 36-1
     Prt: 06-Jun-84  13:54                                           Rtn FindEOS

     
     ! Find and return the location of the end of the current screen.  (We
     ! duplicate a fair amount of code here in order to make execution as
     ! efficient as possible.)
     ;
     
     simple integer procedure FindEOS;
     begin "FindEOS" |1|
       integer
         C,
         Col,
         Line,
         RetPoint,
         SavePoint;
     
       SavePoint _ B!GetP;
       B!SetP(W!GetS);
     
       if (G!WrapP) then
       begin |2|
         Col  _ 1;
         Line _ 0;
     
         while (true) do
         begin |3|
           if (B!EndP) then
             done;
     
           C _ B!GetC;
     
           if (C = FF and G!FFBreak) then
             done;
     
           incr(Col, CharWidth(C, Col));
     
           if (C = CR or C = FF or Col - 1 >= T!Width) then
           begin |4|
             if ((incr(Line)) = W!Size) then
               done
             else
               Col _ CharWidth(C, 1) + 1;
           end; |4|
     
           MoveForwards;
         end; |3|
       end |2|
       else
       begin |2|
         Line _ 0;
     
         while (true) do
         begin |3|
           if (B!EndP) then
             done;
     
           C _ B!GetC;
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 36-2
     Prt: 06-Jun-84  13:54                                           Rtn FindEOS

     
           if (C = FF and G!FFBreak) then
             done;
     
           if (C = CR or C = FF) then
           begin |4|
             if ((incr(Line)) = W!Size) then
               done;
           end; |4|
     
           MoveForwards;
         end; |3|
     
         TryColumn(T!Width);
       end; |2|
     
       RetPoint _ B!GetP;
       B!SetP(SavePoint);
       return(RetPoint);
     end "FindEOS"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 37-1
     Prt: 06-Jun-84  13:54                                          Rtn DownLine

     
     ! Move down to the beginning of the next line.
     ;
     
     simple procedure DownLine;
     begin "DownLine" |1|
       MoveToEOL;
       MoveForwards;
     end "DownLine"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 38-1
     Prt: 06-Jun-84  13:54                                            Rtn UpLine

     
     ! Move up to the end of the previous line.
     ;
     
     simple procedure UpLine;
     begin "UpLine" |1|
       MoveToBOL;
       MoveBackwards;
     end "UpLine"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 39-1
     Prt: 06-Jun-84  13:54                                           Rtn SkipNWS

     
     ! Skip over the next chunk of non-White Space on the current line.
     ;
     
     simple procedure SkipNWS (integer Direction);
     begin "SkipNWS" |1|
       if (Direction = FORWARDS) then
       begin |2|
         while (not AtEol and not C!IsWhiteP) do
           MoveForwards;
       end |2|
       else if (Direction = BACKWARDS) then
       begin |2|
         MoveBackwards;
     
         while (not AfterEOL and not C!IsWhiteP) do
           MoveBackwards;
     
         if (C!IsWhiteP) then
           MoveForwards;
       end; |2|
     end "SkipNWS"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 40-1
     Prt: 06-Jun-84  13:54                                            Rtn SkipWS

     
     ! Skip over the next chunk of White Space.
     ;
     
     simple procedure SkipWS (integer Direction);
     begin "SkipWS" |1|
       if (Direction = FORWARDS) then
       begin |2|
         while (not AtEOL and C!IsWhiteP) do
           MoveForwards;
       end |2|
       else if (Direction = BACKWARDS) then
       begin |2|
         MoveBackwards;
     
         while (not AfterEOL and C!IsWhiteP) do
           MoveBackwards;
     
         if (not C!IsWhiteP) then
           MoveForwards;
       end; |2|
     end "SkipWS"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 41-1
     Prt: 06-Jun-84  13:54                                         Rtn LineEmpty

     
     ! Determine whether the current line is empty.
     ;
     
     simple boolean procedure LineEmpty;
     begin "LineEmpty" |1|
       boolean
         EmptyP;
       integer
         OrigPt;
     
       OrigPt _ B!GetP;
       MoveToBOL;
     
       while (not B!EndP and C!IsWhiteP) do
         MoveForwards;
     
       set(EmptyP, B!EndP or AtEOL);
       B!SetP(OrigPt);
       return(EmptyP);
     end "LineEmpty"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 42-1
     Prt: 06-Jun-84  13:54                                        Rtn GenerateWS

     
     ! Generate the required amount of whitespace.
     ;
     
     simple procedure GenerateWS (integer N);
     begin "GenerateWS" |1|
       while (N) do
       begin |2|
         B!Insert(" ");
         decr(N);
       end; |2|
     end "GenerateWS"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 43-1
     Prt: 06-Jun-84  13:54                                      Rtn GenerateCRLF

     
     ! Generate a number of CRLFs followed by the appropriate indentation.
     ;
     
     simple procedure GenerateCRLF (integer Count(1), Indent(0));
     begin "GenerateCRLF" |1|
       while (Count) do
       begin |2|
         B!Insert(CR);
         B!Insert(LF);
     
         if (Indent) then
           ForceIndent(Indent);
     
         decr(Count);
       end; |2|
     end "GenerateCRLF"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 44-1
     Prt: 06-Jun-84  13:54                                        Rtn CompressGS

     
     !  Compress the grayspace following the point to a mere nothing.
     ;
     
     simple procedure CompressGS (integer Direction, EndMk(-1));
     begin "CompressGS" |1|
       if (EndMk > -1) then
       begin |2|
         if (Direction = FORWARDS) then
         begin |3|
           while (B!GetP < B!GetM(EndMk) and C!IsGrayP) do
             B!Delete(FORWARDS);
         end |3|
         else if (Direction = BACKWARDS) then
         begin |3|
           if (B!GetP > B!GetM(EndMk)) then
           begin |4|
             while (B!GetP > B!GetM(EndMk)) do
             begin |5|
               MoveBackwards;
     
               if (C!IsGrayP) then
                 B!Delete(FORWARDS);
             end; |5|
     
             if (not C!IsGrayP) then
               MoveForwards;
           end; |4|
         end; |3|
       end |2|
       else
       begin |2|
         if (Direction = FORWARDS) then
         begin |3|
           while (B!GetP < B!EndP and C!IsGrayP) do
             B!Delete(FORWARDS);
         end |3|
         else if (Direction = BACKWARDS) then
         begin |3|
           if (not B!BegP) then
           begin |4|
             while (not B!BegP) do
             begin |5|
               MoveBackwards;
     
               if (C!IsGrayP) then
                 B!Delete(FORWARDS)
               else
                 done;
             end; |5|
     
             if (not C!IsGrayP) then
               MoveForwards;
           end; |4|
         end; |3|
       end; |2|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 44-2
     Prt: 06-Jun-84  13:54                                        Rtn CompressGS

     end "CompressGS"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 45-1
     Prt: 06-Jun-84  13:54                                        Rtn CompressWS

     
     ! Compress the whitespace following the point to a mere nothing.
     ;
     
     simple procedure CompressWS (integer Direction, EndMk(-1));
     begin "CompressWS" |1|
       if (EndMk > -1) then
       begin |2|
         if (Direction = FORWARDS) then
         begin |3|
           while (B!GetP < B!GetM(EndMk) and C!IsWhiteP) do
             B!Delete(FORWARDS);
         end |3|
         else if (Direction = BACKWARDS) then
         begin |3|
           if (B!GetP > B!GetM(EndMk)) then
           begin |4|
             while (B!GetP > B!GetM(EndMk)) do
             begin |5|
               MoveBackwards;
     
               if (C!IsWhiteP) then
                 B!Delete(FORWARDS);
             end; |5|
     
             if (not C!IsWhiteP) then
               MoveForwards;
           end; |4|
         end; |3|
       end |2|
       else
       begin |2|
         if (Direction = FORWARDS) then
         begin |3|
           while (B!GetP < B!EndP and C!IsWhiteP) do
             B!Delete(FORWARDS);
         end |3|
         else if (Direction = BACKWARDS) then
         begin |3|
           if (not B!BegP) then
           begin |4|
             while (not B!BegP) do
             begin |5|
               MoveBackwards;
     
               if (C!IsWhiteP) then
                 B!Delete(FORWARDS)
               else
                 done;
             end; |5|
     
             if (not C!IsWhiteP) then
               MoveForwards;
           end; |4|
         end; |3|
       end; |2|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 45-2
     Prt: 06-Jun-84  13:54                                        Rtn CompressWS

     end "CompressWS"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 46-1
     Prt: 06-Jun-84  13:54                                     Rtn SkipGraySpace

     
     ! Skip any grayspace (space, tab, or crlf) following (or preceding) the
     ! cursor and wind up at the beginning (or end) of the next (or previous)
     ! token.
     ;
     
     simple procedure SkipGraySpace (integer Dir(FORWARDS));
     begin "SkipGraySpace" |1|
       if (Dir = FORWARDS) then
       begin |2|
         ! Move Forwards.
         ;
     
         while (not B!EndP) do
         begin |3|
           if (not C!IsGrayP) then
             done;
     
           MoveForwards;
         end; |3|
       end |2|
       else if (Dir = BACKWARDS) then
       begin |2|
         ! Move Backwards.
         ;
     
         MoveBackwards;
     
         while (not B!BegP and C!IsGrayP) do
           MoveBackwards;
     
         if (not C!IsGrayP) then
           MoveForwards;
       end; |2|
     end "SkipGraySpace"; |1|
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 47-1
     Prt: 06-Jun-84  13:54                                            Rtn DoFill

     
     ! Perform paragraph fill between the point and the mark EndMk (presumed
     ! to be the end of the paragraph).
     ;
     
     simple procedure DoFill (reference integer Col; integer EndMk, LM, RM);
     begin "DoFill" |1|
       boolean
         WSFlg;
       integer
         Char,
         Point,
         SaveMk,
         WSI,
         WSP;
       define
         IsDotty (X)     = {(X = "." or X = ":" or X = "!" or X = "?")},
         IsInvisible (X) = {(X = ">" or X = ")" or X = "]" or X = """" or
                             X = "'")}; 
     
     
       WSI _ 1;
       WSP _ -1;
       clear(WSFlg);
     
       SaveMk _ B!AllocateMark;
     
       while ((Point _ B!GetP) < B!GetM(EndMk)) do
       begin |2|
         if (C!IsGrayP) then
         begin |3|
           CompressGS(FORWARDS, EndMk);
     
           if (Col > RM) then
           begin |4|
             GenerateCRLF(1, LM-1);
             Col _ LM;
             clear(WSFlg);
           end |4|
           else
           begin |4|
             WSP _ Point;
             GenerateWS(WSI);
             incr(Col, WSI);
             set(WSFlg);
           end; |4|
         end |3|
         else
         begin |3|
           Char _ B!GetC;
           WSI  _
               if (IsDotty(Char)) then
                 2
               else if (IsInvisible(Char)) then
                 WSI
               else
     Cre: 26-Mar-84  13:07  (PEAKX)COMSUB.REQ                          Page 47-2
     Prt: 06-Jun-84  13:54                                            Rtn DoFill

                 1;
     
           MoveForwards;
     
           if (Col > RM and WSFlg) then
           begin |4|
             integer
               Ofst;
     
             B!SetM(SaveMk, B!GetP);
             B!SetP(WSP);
     
             CompressGS(FORWARDS, EndMk);
             Ofst _ B!GetM(SaveMk) - WSP;
             GenerateCRLF(1, LM-1);
             B!SetP(B!GetM(SaveMk));
             Col _ LM + Ofst;
           end |4|
           else
             if (Char = BS) then
               decr(Col)
             else
               incr(Col);
         end; |3|
       end; |2|
     
       B!DeallocateMark(SaveMk);
     end "DoFill"; |1|
     
     
     ! ************************** End of COMSUB.SAI ***************************;





                                                      
                                                      
                                                      
                                          
                                          
                                          
                                    
                                    
                                    
                              
                              
                              
                              
                              
                              
                              
                              
                              
                                                      
                                                      
                                                      



                                                      
                                                      
                                                      
                                    
                                    
                                    
                                          
                                          
                                          
                                          
                                          
                                          
                                                            
                                                            
                                                            
                                    
                                    
                                    
                                                
                                                
                                                




                            
                 
                 
                  
                      
                 
                            

     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 1-1
     Prt: 06-Jun-84  13:55                                   PEAK Command Module

     Entry;
     begin "DED - Command module" |1|
       require "DED.DEF" source!file;
     
     
     ! *************************************************************************
     *                                                                         *
     *      Herein contained are all of the command key bindings, and the      *
     *      main command loop where the commands are dispatched.  Certain      *
     *       simple commands, such as the Meta prefix handlers, argument       *
     *             collectors, and error handlers also live here.              *
     *                                                                         *
     **************************************************************************;
     
     
     !                      From the SAIL runtime system
     ;
     
       external integer
         !skip!;                             ! Indicates an error occurred in
                                             ! some quadrant of the Runtimes.
                                             ;
     
     
     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
     
     !                         From the Utility Module
     ;
     
       external simple integer procedure
         DecrBP (integer BP);                ! Return a decremented byte
                                             ! pointer. 
                                             ;
     
     
     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
     !
     !                         From the Buffer Module
     ;
     
       ifcr TymcomX thenc
         external simple procedure
           B!Kill;                           ! Kill the current Buffer
                                             ;
         external simple procedure
           B!CheckPoint;                     ! Force a Checkpoint to take
                                             ! place. 
                                             ;
         external simple procedure
           B!Make (string Filename, Alias);
     
         external simple boolean procedure
           B!CKFile (integer W1, W2);
       endc
     
       ifcr Tops20 thenc
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 1-2
     Prt: 06-Jun-84  13:55                                   PEAK Command Module

         external simple procedure
           B!DelCurrentBuffer;               ! Delete the current Buffer.
                                             ;
         external simple procedure
           B!CheckPoint (boolean Close);     ! Force a Checkpoint to take
                                             ! place. 
                                             ;
     
         external simple boolean procedure
           B!CreateChkPntFile
               (string TName, TAlias(null); 
               integer TPage(0), TLine(0),
               TChar(0));                    ! Create a new checkpoint file
                                             ! and fill it with the named
                                             ! Text file.
                                             ;
         external simple boolean procedure
           B!FileInsert (string FName);      ! Insert a Text file after the
                                             ! Point in the Buffer.
                                             ;
         external simple procedure
           B!RestoreFromEDT;                 ! Restore everything from the EDT
                                             ! area to accessible data
                                             ! structures. 
                                             ;
         external simple procedure
           B!CKFile (string Name);
       endc
     
       external simple boolean procedure
         B!AnyM;
     
       external simple integer procedure
         B!ModCnt;
     
       external simple boolean procedure
         B!Fini (boolean WriteFiles);
     
       external simple boolean procedure
         B!FreeP;
     
       external simple procedure
         B!BufStat;
     
       external simple procedure
         B!Restore;
     
       external simple procedure
         B!Step (integer Direction);
     
       external simple procedure
         B!Insert (integer Char);
     
       external simple integer procedure
         B!GetC;
     
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 1-3
     Prt: 06-Jun-84  13:55                                   PEAK Command Module

       external simple procedure
         B!Delete (integer Number);
     
       external simple procedure
         B!Move (integer Distance);
     
       external simple integer procedure
         B!GetP;
     
       external simple procedure
         B!SetP (integer Position);
     
       external simple integer procedure
         B!AllocateMark;
     
       external simple procedure
         B!DeAllocateMark (integer M);
     
       external simple integer procedure
         B!GetM (integer MarkNum);
     
       external simple procedure
         B!SetM (integer MarkNum, Position);
     
       external simple integer procedure
         B!Cnt;
     
     
       external boolean
         B!BegP,
         B!EndP,
         B!ModP;
     
       external integer
         B!Lock,
         B!CkPtSer,
         B!Prot;
     
       external string
         B!Mode,
         B!File;
     
     
     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
     
     !                        From the Redisplay Module
     ;
     
       external integer
         T!Width;                            ! How wide is the terminal?
                                             ;
       external procedure
         R!Init;
     
       ifcr Tops20 thenc
         external simple procedure
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 1-4
     Prt: 06-Jun-84  13:55                                   PEAK Command Module

           T!FlshIBuf;                       ! Flush the last input character
                                             ! from the terminal input buffer.
                                             ;
       endc
     
       external integer procedure
         T!GetC;                             ! Get an image character.
                                             ;
     
       external simple procedure
         T!GetTermType (boolean X);          ! Establish the terminal type for
                                             ! the Redisplay.
                                             ;
       external procedure
         T!OutC (integer C);                 ! Print an image character.
                                             ;
     
       external procedure
         T!Bell;
     
       external boolean procedure
         T!ChrP;                             ! True iff character available.
                                             ;
     
       external procedure
         T!Fini;                             ! Reset the terminal.
                                             ;
     
       external procedure
         T!RSet;                             ! Re-init the terminal.
                                             ;
     
     
     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
     
     !                         From the Window Module
     ;
     
       external integer
         W!Buf0,                             ! Identity of Buffer for window 0.
                                             ;
         W!Buf1;                             ! Identity of Buffer for window 1.
                                             ;
     
       external procedure
         W!Disp (boolean PuntFlag);
     
       external integer procedure
         W!Size;
     
       external integer procedure
         W!GetS;
     
       external procedure
         W!SetS (integer Position);
     
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 1-5
     Prt: 06-Jun-84  13:55                                   PEAK Command Module

       external procedure
         W!Frame;
     
       external procedure
         W!Msg (string S);                   ! Put S in the message line.
                                             ;
     
       external procedure
         W!Msg2 (string S);
     
       external procedure
         W!NewS;
     
       external procedure
         W!FixS;
     
     
       external boolean
         W!MsgF;                             ! Show cursor on msg line.
                                             ;
     
       external procedure
         W!BClr;
     
       external procedure
         W!BMsg (integer Line; string Text);
     
       external procedure
         W!BAdd (string Text);
     
       external procedure
         W!BSet (boolean OnFlag);
     
       external integer
         W!BoxP;
     
       external integer
         W!White;                            ! On to "highlite" whitespace.
                                             ;
     
     
     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
     
     !                          From the File Module
     ;
     
       external boolean
         F!RPGFlag;
     
     
       ifcr TymcomX thenc
         external boolean procedure
           F!Decompose
             (string InStr;
             reference string UserName, File, Ext, PPN, Alias, Switches); 
     
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 1-6
     Prt: 06-Jun-84  13:55                                   PEAK Command Module

         external boolean procedure
           F!Read (string FName);
     
         external boolean procedure
           F!Load (string FName; integer P, L, C);
     
         external boolean procedure
           F!Lookup (string FName);
     
         external integer procedure
           F!GetC;
     
         external procedure
           F!Release;
       endc
     
       ifcr Tops20 thenc
         external boolean procedure
           F!Decompose
             (string InStr;
             reference string Device, UserName, File, Ext, Gen, Alias,
             Switches); 
       endc
     
       external string procedure
         F!Parse (string FName);
     
       external integer procedure
         F!Scan (string FName);
     
       external boolean procedure
         F!Writ (string FName);
     
       external procedure
         F!Exit;
     
     
     ! ------------------------------------------------------------------------;
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 2-1
     Prt: 06-Jun-84  13:55                                      Internal Storage

     
     ! ----------  Internal data structures and state information  ----------- ;
     
     
       internal integer
         C!Debug,                            ! This guy is on if we're
                                             ! debugging.
                                             ;
     
         C!CheckPointInterval;               ! Number of seconds of inactivity
                                             ! before a checkpoint is done.
                                             ;
     
       own safe internal integer array
         C!Dispatch [0:'577];
     
         ! The dispatch table has an entry for each of the 200(8) ASCII
         ! characters, plus entries for "Meta" characters, which are formed by
         ! adding 200(8) or 400(8), depending on the prefix character, to the
         ! command character. 
         ;
     
     
       integer
         C!MetaPrefix,                       ! The current Meta prefix.
                                             ;
         C!XMetaPrefix;                      ! The Current XMeta prefix.
                                             ;
     
     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
     
     !                     For keeping track of commands.
     ;
     
       internal integer
         C!Cmd,                              ! The current command.
                                             ;
         C!Addr;                             ! The address of the routine
                                             ! dispatched to by the current
                                             ! command.
                                             ;
     
         ! Note: These two items are declared internal so that they'll appear
         ! in the link map.
         ;
     
       own integer
         C!LastCmd,                          ! The previous comand.
                                             ;
         C!LastAddr;                         ! The address of the routine
                                             ! dispatched to by the previous
                                             ! command.
                                             ;
     
     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
     
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 2-2
     Prt: 06-Jun-84  13:55                                      Internal Storage

     !                 Storage relating to command processing
     ;
     
       own integer
         C!DispatchCount;                    ! Count of commands dispatched.
                                             ;
     
       internal boolean
         C!Quit;                             ! Set this to end command loop.
                                             ;
     
       own integer
         CF!Chan;                            ! The Channel through which a
                                             ! command file is input.  (Note
                                             ! that with one channel, we are
                                             ! not capable of recursion.)
                                             ;
       own boolean
         C!JournalFile;                      ! True iff we are showing command
                                             ! file comands.
                                             ;
       own boolean
         C!CmdFileP;                         ! True iff comands from file.
                                             ;
       own string
         C!String;                           ! String being read by command.
                                             ;
     
       internal integer
         C!ArgV;                             ! The value of the argument.
                                             ;
       own integer
         C!ArgMultiplier;                    ! The value of a defaulted
                                             ! argument.
                                             ;
       own boolean
         C!JournalCommand;                   ! True iff we are showing all
                                             ! commands.
                                             ;
     
     
     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
     
     !                            The Macro System
     ;
     
     ! Several different flavors of macros are used here.  A macro may be
     ! defined 'by example' by keeping track of things being typed, or defined
     ! explicitely by special functions.  Once a macro is defined, it may be
     ! executed by the 'invoke last macro defined' command, or bound to a key.
     ;
     
     
       define
         MAXMACROLENGTH = 200;               ! Maximum size in characters.
                                             ;
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 2-3
     Prt: 06-Jun-84  13:55                                      Internal Storage

       define
         MAXMACRODEPTH = 12;                 ! Maximum calling depth.
                                             ;
       define
         C!MacroPointer = 1;                 ! Left-half Flag for Macro Addr.
                                             ;
       record!class
         Macro ( integer Id;                 ! Macro Identifier ;
                 integer Key;                ! Previous Key Binding ;
                 string  Body;               ! Macro Body  ;
                 string  Name;               ! Macro Name  ;
                 record!pointer (Macro) Last;! Obvious link pointers ;
                 record!pointer (Macro) Next );
     
       own record!pointer (Macro)
         C!MacroStack,                       ! Head of macro stack. ;
         C!MacroNames;                       ! Head of "named" macros.
                                             ;
       own integer
         C!MacroDepth;                       ! Current macro call depth.
                                             ;
       own boolean
         C!DefiningMacro;                    ! True iff we want to 'remember'
                                             ! keystrokes.
                                             ;
       own boolean
         C!JournalMacro;                     ! True iff we are showing macro
                                             ! commands.
                                             ;
       own string
         C!LastMacro,                        ! The last keyboard macro defined.
                                             ;
         C!Macro;                            ! The current macro string.
                                             ;
       own boolean
         C!MAbort;                           ! Signal for the macro system to
                                             ! abort the current macro.  This
                                             ! gets set by various commands.
                                             ;
     
     
     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
     
     !                             The Kill Buffer
     ;
     
     ! The Kill Buffer saves killed or copied text temporarily.
     ;
     
       define
         KILLBUFSIZE = 1000;                 ! The Kill Buffer size in words.
                                             ;
       define
         KILLBUFMAX = KILLBUFSIZE * CharactersPerWord;
                                             ! The Kill Buffer size in
                                             ! characters.
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 2-4
     Prt: 06-Jun-84  13:55                                      Internal Storage

                                             ;
     
       own integer array
         C!KillBuf [0:KILLBUFSIZE - 1];      ! The Kill Buffer itself.
                                             ;
       own integer
         C!KillBP,                           ! A byte pointer into the Kill
                                             ! Buffer.
                                             ;
         C!KillCnt;                          ! A count of the number of
                                             ! characters in the Kill Buffer.
                                             ;
     
     
     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
     
     !                            The Binding Stack
     ;
     
     ! The Binding Stack is used for the temporary storage of key bindings.
     ;
     
        define
          BINDINGSTACKSIZE = 50;             ! The maximum number of bindings
                                             ! we may save simultaneously.
                                             ;
     
       own integer
         C!BindingStackPnt;                  ! ??? A pointer into the Binding
                                             ! Stack.
                                             ;
       own safe integer array
         C!BindingStack [1:BINDINGSTACKSIZE];
                                             ! The Binding Stack itself.
                                             ;
     
     
     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
     
     !                     Searching and Replacing strings
     ;
     
       own string
         C!Search,                           ! The current Single-Search
                                             ! string.
                                             ;
         C!SearchM,                          ! The current Multiple-Search
                                             ! string. 
                                             ;
         C!QOldStr,                          ! The current Query-Replace
                                             ! Search String.
                                             ;
         C!QNewStr;                          ! The current Query-Replace
                                             ! Replacement String.
                                             ;
     
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 2-5
     Prt: 06-Jun-84  13:55                                      Internal Storage

     
     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
     
     !                              Aux Circuits
     ;
     
       internal integer
         C!CreEscChr,                        ! CreAux command escape character,
                                             ! two of which will allow you to
                                             ! return to editing the buffer.
                                             ;
         C!AuxPort;                          ! The identity of the port on which
                                             ! the aux circuit exists. (Must be
                                             ! initially -1.)
                                             ;
       internal string
         C!AuxStr;                           ! The login string used by CreAux.
                                             ;
     
     
     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
     
     !                           Miscellaneous Stuff
     ;
     
       own integer
         G!AppendKillP,                      ! True to force next kill to append
                                             ! to kill buffer.
                                             ;
         C!RightMargin,                      ! Location of the Right Margin.
                                             ;
         C!LeftMargin,                       ! Location of the Left Margin.
                                             ;
         C!StickyColumn;                     ! The column we're "stuck" to.
                                             ;
       internal integer
         C!TABWidth;                         ! The width of a tab.
                                             ;
       own integer
         C!IndentUnitWidth;                  ! The width of an indent unit.
                                             ;
       internal boolean
         C!SPMRegion;                        ! Swap Point and Mark on
                                             ! Region-oriented commands
                                             ! (including Insert File)
                                             ;
       internal boolean
         G!TextMode;                         ! True iff we are in text mode.
                                             ;
       own boolean
         C!UseTABS,                          ! Use tabs (as opposed to spaces)
                                             ! for indentation.
                                             ;
         C!VFMode;                           ! Vue Fill Mode, which if true
                                             ! indicates that Fill Paragraph
                                             ! and Justify Paragraph use the
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 2-6
     Prt: 06-Jun-84  13:55                                      Internal Storage

                                             ! argument as a right-margin
                                             ! override value, and leave the
                                             ! point at the end of the current
                                             ! paragraph (normally, the
                                             ! argument is a repeat count, and
                                             ! the point is located after the
                                             ! current paragraph).
                                             ;
     
       ifcr Tops20 thenc
         internal integer
           G!ShowGens;                       ! Show File generation counts.
                                             ;
       endc
     
       internal integer
         G!Test,                             ! ??? Used for testing
                                             ;
         G!ESCF,                             ! Print ESC as "$".
                                             ;
         G!OverWriteP,                       ! Overwrite on character insert.
                                             ;
         G!WrapP,                            ! Perform line wrap on display.
                                             ;
         G!CaseMatch,                        ! Exact case match on searches.
                                             ;
         G!FFBreak;                          ! Break display page on FF.
                                             ;
       internal boolean
         G!RNulls,                           ! True if nulls are to be removed
                                             ! automatically when the Text
                                             ! file is read.  Only cleared by
                                             ! a command line switch.
                                             ;
         G!CRCtl;                            ! A lonely CR is displayed as
                                             ! "^m".  (The alternative is "&"
                                             ! in column 80);
                                             ;
       internal integer
         G!MagicMode;                        ! ??? For internal hackery.
                                             ;
       internal string
         C!UserName;                         ! Name we're logged in to.
                                             ;
     
       own boolean
         InsertLiterally;                    ! True iff the character being
                                             ! inserted is to be inserted
                                             ! literally (ie, not interpreted
                                             ! by the insert routine).
                                             ;
     
     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
     
     ! The following macros help write readable commands ;
     
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 2-7
     Prt: 06-Jun-84  13:55                                      Internal Storage

     define
       PuntCommand =
       { |2|
         begin |3|
           C!ArgV _ 0;
           return;
         end |3|
       }; |2|
     
     
     ! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
     
     !                                  C!Tab
     ;
     
     ! The array C!Tab is useful in a variety of ways.  First, it defines most
     !  all of the uses for each character, such as whether it is considered
     !  alphabetic, whitespace, legal in an identifier, etc.  Also, the table
     !  contains the upshifted value of characters for purposes of searching.
     ;
     
     preload!with
       '0,                                   '1,
       '2,                                   '3,
       '4,                                   '5,
       '6,                                   IsAbort + '7,
     
       '10,                                  IsWhite + TAB,
       IsEOL + '12,                          '13,
       IsEOL + FF,                           IsEOL + CR,
       '16,                                  '17,
     
       '20,                                  '21,
       '22,                                  '23,
       '24,                                  '25,
       '26,                                  '27,
     
       '30,                                  '31,
       '32,                                  '33,
       '34,                                  '35,
       '36,                                  '37,
     
       IsWhite + IsYes + " ",                IsDelim + "!",
       IsDelim + '42,                        IsDelim + "#",
       IsDelim + "$",                        IsDelim + "%",
       IsDelim + "&",                        IsDelim + "'",
     
       IsDelim + "(",                        IsDelim + ")",
       IsDelim + "*",                        IsDelim + "+",
       IsDelim + ",",                        IsDelim + "-",
       IsDelim+IsNum+IsYes+IsAbort+".",      IsDelim + "/",
     
       IsNum + IsToken + "0",                IsNum + IsToken + "1",
       IsNum + IsToken + "2",                IsNum + IsToken + "3",
       IsNum + IsToken + "4",                IsNum + IsToken + "5",
       IsNum + IsToken + "6",                IsNum + IsToken + "7",
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 2-8
     Prt: 06-Jun-84  13:55                                      Internal Storage

     
       IsNum + IsToken +  "8",               IsNum + IsToken + "9",
       IsDelim + ":",                        IsDelim + ";",
       IsDelim + "<",                        IsDelim + "=",
       IsDelim + ">",                        IsDelim + "?",
     
       IsDelim + "@",                        IsAlpha + IsToken + "A",
       IsAlpha + IsToken + "B",              IsAlpha + IsToken + "C",
       IsAlpha + IsToken + "D",              IsAlpha + IsToken + "E",
       IsAlpha + IsToken + "F",              IsAlpha + IsToken + "G",
     
       IsAlpha + IsToken + "H",              IsAlpha + IsToken + "I",
       IsAlpha + IsToken + "J",              IsAlpha + IsToken + "K",
       IsAlpha + IsToken + "L",              IsAlpha + IsToken + "M",
       IsAlpha + IsToken + IsNo + "N",       IsAlpha + IsToken + "O",
     
       IsAlpha + IsToken + "P",              IsAlpha + IsToken + "Q",
       IsAlpha + IsToken + "R",              IsAlpha + IsToken + "S",
       IsAlpha + IsToken + "T",              IsAlpha + IsToken + "U",
       IsAlpha + IsToken + "V",              IsAlpha + IsToken + "W",
     
       IsAlpha + IsToken + "X",              IsAlpha + IsToken + IsYes + "Y",
       IsAlpha + IsToken + "Z",              IsDelim + "[",
       IsDelim + "\",                        IsDelim + "]",
       IsDelim + "^",                        IsDelim + "_",
     
       IsDelim + "`",                        IsAlpha + IsToken + "A",
       IsAlpha + IsToken + "B",              IsAlpha + IsToken + "C",
       IsAlpha + IsToken + "D",              IsAlpha + IsToken + "E",
       IsAlpha + IsToken + "F",              IsAlpha + IsToken + "G",
     
       IsAlpha + IsToken + "H",              IsAlpha + IsToken + "I",
       IsAlpha + IsToken + "J",              IsAlpha + IsToken + "K",
       IsAlpha + IsToken + "L",              IsAlpha + IsToken + "M",
       IsAlpha + IsToken + IsNo + "N",       IsAlpha + IsToken + "O",
     
       IsAlpha + IsToken + "P",              IsAlpha + IsToken + "Q",
       IsAlpha + IsToken + "R",              IsAlpha + IsToken + "S",
       IsAlpha + IsToken + "T",              IsAlpha + IsToken + "U",
       IsAlpha + IsToken + "V",              IsAlpha + IsToken + "W",
     
       IsAlpha + IsToken + "X",              IsAlpha + IsToken + IsYes + "Y",
       IsAlpha + IsToken + "Z",              IsDelim + "{",
       IsDelim + "|",                        IsDelim + "}",
       IsDelim + "~",                        DEL;
     
     internal safe integer array
       C!Tab [0:'177];
     
     
     ! ----------------------------------------------------------------------- ;
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 3-1
     Prt: 06-Jun-84  13:55                                Rtn C!PointerToInteger

     
     ! This routine is used to convert a record-pointer to an integer. ;
     !  It is necessary to "fool" SAIL using start-code so that there
     !  is absolutely no type-checking done during the conversion.
     ;
     
     simple integer procedure C!PointerToInteger( record!pointer (Macro) Ptr );
       begin!code |2|
     
         Hrrz  1,Ptr;                ! Copy the pointer for our return ;
     
       end; |2|
     
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 4-1
     Prt: 06-Jun-84  13:55                                Rtn C!IntegerToPointer

     
     ! This routine is used to convert an integer to a record-pointer. ;
     !  It is necessary to "fool" SAIL using start-code so that there
     !  is absolutely no type-checking done during the conversion.
     ;
     
     simple record!pointer (Macro) procedure C!IntegerToPointer( Integer I );
       begin!code |2|
     
         Hrrz  1,I;                  ! Copy the integer for our return ;
     
       end; |2|
     
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 5-1
     Prt: 06-Jun-84  13:55                                          Rtn Dispatch

     
     ! This is the dispatch routine.  It expects that 'Cmd' is a valid command
     !  character.  For an explanation of the format of the dispatch table,
     !  see the comments in C!Init.  Dispatch is defined here because numerous
     !  routines below call it. ;
     
     forward recursive procedure C!MacroDispatch( Integer MacroPointer );
     
     simple procedure Dispatch( integer Cmd );
       begin "dispatch" |2|
     
         C!Cmd := Cmd;
         C!Addr := C!Dispatch[ C!Cmd ];
     
         if ( lh( C!Addr ) = C!MacroPointer ) then
     
           C!MacroDispatch( C!Addr )
     
         else
     
         begin!code |3|
           aos C!DispatchCount;      ! kick the counter ;
           pushj p,@C!Addr;          ! and go ;
         end; |3|
     
         ! Remember the command, unless it wants to be invisible (eg, C!Arg) ;
     
         if ( C!Cmd >= 0 ) then
           begin |3|
             C!LastCmd := C!Cmd;
             C!LastAddr := C!Addr;
           end; |3|
     
       end "dispatch"; |2|
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 6-1
     Prt: 06-Jun-84  13:55                       Rtn C!WaitAndPossiblyCheckpoint

     
     ! Routine called from T!GetC when a redisplay has been done and there
     ! still isn't a character from the keyboard.  If a checkpoint interval
     ! has been given wait that long, then checkpoint the buffer is nothing
     ! has been done at the keyboard. ;
     
     simple procedure C!WaitAndPossiblyCheckpoint;
     begin "timer" |2|
       ifcr TymcomX thenc
         own integer Flag;
     
         if (not C!CheckPointInterval) then
           return;
     
         start!code |3|
           setzm     Flag;           ! assume character hit ;
           hrli      1, '11;         ! wait for char, wait in seconds ;
           hrr       1, C!CheckPointInterval;
           calli     1, '72;         ! hiber 1, ;
            jfcl;
           hrroi     1, '10;         ! .axsic - skip if character ;
           auxcal    1,;
             setom   Flag;           ! no character hit ;
         end; |3|
     
         if (Flag) then
         begin |3|
           W!Msg2("[CheckPoint]");
           B!CheckPoint;
           W!Disp(false);
         end; |3|
       endc
     
       ifcr Tops20 thenc
         return;
       endc
     end "timer" ; |2|
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 7-1
     Prt: 06-Jun-84  13:55                                            Rtn C!ChrP

     
     ! Routine to tell if a command character is available
     ;
     
     internal simple boolean procedure C!ChrP;
       begin |2|
         if ( C!CmdFileP ) then return( true );
         if ( length( C!Macro )) then return( true );
         return( T!ChrP );
       end; |2|
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 8-1
     Prt: 06-Jun-84  13:55                                            Rtn C!GetC

     
     ! Routine to get the next command character.  Returns one from
     ! wherever it is that we're getting characters.
     ;
     
     internal simple integer procedure C!GetC;
       begin "get command character" |2|
         own integer C;
     
         if ( length( C!Macro )) then ! return next char of macro string ;
           begin |3|
             C := lop( C!Macro );
           end |3|
         else if ( C!CmdFileP ) then
           begin |3|
             ifcr TymcomX thenc
               C _ F!GetC;
             endc
     
             ifcr Tops20 thenc
               if (not (C _ charin(CF!Chan))) then
                 C _ - 1;
             endc
           end |3|
         else
           begin |3|
             ! These tests should be seperate, since they are sensitive to
               time elapsing ;
     
             if ( not C!ChrP ) then W!Disp( true );
             if ( not C!ChrP ) then C!WaitAndPossiblyCheckpoint;
             C := T!GetC;
           end; |3|
     
         ! here with next command character ;
     
         if ( C!DefiningMacro ) then
           begin |3|
             C!LastMacro := C!LastMacro & C;
             if ( length( C!LastMacro ) = MAXMACROLENGTH ) then
               begin |4|
                 C!DefiningMacro := false;
                 W!Msg( "Maximum Macro length exceeded -- aborting definition" |
                                                                          ->|);|
                 T!Bell;
               end; |4|
           end; |3|
     
         return( C );
     
       end "get command character"; |2|
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                           Page 9-1
     Prt: 06-Jun-84  13:55                                          Rtn C!GetCMD

     
     ! Routine to get the next full command ;
     
     forward string procedure CvCmdChr( integer C );
     
     simple integer procedure C!GetCMD;
       begin "get command" |2|
         own integer Temp;
     
         Temp := C!GetC;
     
         if ( Temp = C!MetaPrefix ) then
           begin |3|
             W!Msg( "Meta" );
             Temp := C!GetC lor Meta;
           end |3|
         else if ( Temp = C!XMetaPrefix ) then
           begin |3|
             W!Msg( "XMeta" );
             Temp := C!GetC lor Meta2;
           end; |3|
     
         if ( Temp land ( Meta lor Meta2 ) ) then
           begin |3|
             W!Msg( CvCmdChr(Temp) );
             if ( C!CmdFileP and C!JournalFile and length( C!Macro ) = 0 ) then
               W!Disp( True );
           end; |3|
     
         return( Temp );
     
       end "get command"; |2|
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 10-1
     Prt: 06-Jun-84  13:55                                             Rtn C!Err

     
     ! Some Meta-Commands which aren't really considered to be user commands. ;
     
     ! "This command is no good" command.  This also has the effect of
     !  closing a macro definition. ;
     
     internal simple procedure C!Err;
       begin "abort" |2|
     
         T!Bell;
         W!Msg( NULL );
         C!ArgV := 0;
     
         if ( C!DefiningMacro ) then
           begin |3|
             C!DefiningMacro := false;
             C!LastMacro := C!LastMacro[1 for inf-1];
             if ( C!Cmd > '177 ) then
               C!LastMacro := C!LastMacro[1 for inf-1];
             W!Msg( "Keyboard macro defined" );
           end; |3|
     
       end "abort"; |2|
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 11-1
     Prt: 06-Jun-84  13:55                                          Rtn C!Ignore

     
     ! The basic no-op ;
     
     simple procedure C!Ignore;
       begin |2|
         C!ArgV := 0;
       end; |2|
     
     
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 12-1
     Prt: 06-Jun-84  13:55                                            Rtn C!Exit

     
     ! Command to abort the command loop. ;
     
     internal simple procedure C!Exit;
       begin |2|
         C!ArgV := 0;
         C!Quit := true;
       end; |2|
     
     
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 13-1
     Prt: 06-Jun-84  13:55                                         Rtn C!NotExit

     
     ! Command to not abort the command loop ;
     
     simple procedure C!NotExit;
       begin |2|
         C!ArgV := 0;
         W!Msg( "Use ^X^C" );
       end; |2|
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 14-1
     Prt: 06-Jun-84  13:55                                             Rtn C!Arg

     
     ! Pick up a numeric agrument and set C!ArgV.
     ! 
     ! This command is 'invisible' in that it uses some magic to
     ! cause Dispatch() to forget that we were just dispatched to.
     ! This prevents C!LastCmd from pointing to us, and enables
     ! ^K to work correctly.
     ;
     
     simple procedure C!Arg;
       begin "arg" |2|
         own integer C, N, P;
     
         if ( C!ArgV = 0 ) then
           C!ArgV := 1;
     
         W!Msg( "Arg: " & cvs(C!ArgV * C!ArgMultiplier) );
         P := N := 0;
     
         forever do
           begin "get arg" |3|
             C := C!GetC;
             if ( C < "0" or C > "9" ) then done "get arg";
             P := true;
             N := N * 10 + ( C - "0" );
             W!Msg( "Arg: " & cvs( C!ArgV * N ) );
           end "get arg"; |3|
     
         C!Macro := C & C!Macro;
     
         if (C!DefiningMacro) then
           C!LastMacro := C!LastMacro[1 for inf-1];
     
         if ( P ) then C!ArgV := C!ArgV * N
         else C!ArgV := C!ArgV * C!ArgMultiplier;
     
         W!Msg( NULL );
     
         C!Cmd := -1;                ! cause Dispatch() to forget us ;
     
       end "arg"; |2|
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 15-1
     Prt: 06-Jun-84  13:55                                       Rtn C!XOFFSynch

     
     ! "Synch" to the terminal by waiting for an XON (^Q).  This is useful
     !  for those terminals which do XON/XOFF handshaking, and may keep on
     !  XOFFing if you keep sending character at them.  (E.g. H19). ;
     
     simple procedure C!XOFFSynch;
       begin "handshake" |2|
     
         C!ArgV := 0;
         while ( T!GetC neq '21 ) do
         begin |3|
         end; |3|
     
       end "handshake"; |2|
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 16-1
     Prt: 06-Jun-84  13:55                                     Rtn C!PushBinding

     
     ! Routine to "push" a key binding onto the binding stack ;
     
     simple procedure C!PushBinding;
       begin "push binding" |2|
         own integer Key;
     
         C!ArgV := 0;
         if ( C!BindingStackPnt = BINDINGSTACKSIZE ) then
           W!Msg( "Binding Stack is full" )
         else
           begin |3|
             W!Msg( "Key: " );
             Key := C!GetCmd;
             C!BindingStackPnt := C!BindingStackPnt + 1;
             C!BindingStack[ C!BindingStackPnt ] := C!Dispatch[ Key ];
             W!Msg( NULL );
           end; |3|
     
       end "push binding"; |2|
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 17-1
     Prt: 06-Jun-84  13:55                                     Rtn C!Pop!Binding

     
     ! Routine to "pop" a binding off the stack and bind it to a key ;
     
     simple procedure C!PopBinding;
       begin "pop binding" |2|
         own integer Key;
     
         C!ArgV := 0;
         if ( C!BindingStackPnt = 0 ) then
           W!Msg( "Binding Stack is empty" )
         else
           begin |3|
             W!Msg( "Key: " );
             Key := C!GetCmd;
             C!Dispatch[ Key ] := C!BindingStack[ C!BindingStackPnt ];
             C!BindingStackPnt := C!BindingStackPnt - 1;
             W!Msg( NULL );
           end; |3|
     
       end "pop binding"; |2|
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 18-1
     Prt: 06-Jun-84  13:55                               The Commands themselves

     
     ! Other commands get included here ;
     
       ! first some forwards ... ;
     
       forward integer procedure SymCmdAddr( string C );
       forward integer procedure SymVarAddr( string S );
       forward string  procedure SymCmdName( integer V );
       forward string  procedure SymVarName( integer V );
     
       ! now the requires ;
     
       require "COMSUB.REQ" source!file;     ! handy subroutines ;
       require "COMM1.REQ" source!file;      ! simple commands ;
       require "COMM2.REQ" source!file;      ! tricky commands ;
       require "COMM3.REQ" source!file;      ! macro & rebinding commands ;
       require "COMM4.REQ" source!file;      ! file i/o commands ;
       require "COMM5.REQ" source!file;      ! mode stuff ;
       require "COMM6.REQ" source!file;      ! window manipulation commands ;
       require "COMM7.REQ" source!file;      ! help system ;
     
       ifcr TymcomX thenc
         require "COMM8.REQ" source!file;    ! CREAUX stuff - AUXWIN ;
       endc
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 19-1
     Prt: 06-Jun-84  13:55                                            Rtn C!Init

     ! title Rtn C!Init ;
     ! C!Init - Set up the key bindings, and symbolic stuff.
     ;
     
     internal procedure C!Init;
       begin "initialization" |2|
     
     ifcr TymcomX thenc
         C!UserName := cv6str( call( xwd(-1, -'22), "gettab" )) &
                       cv6str( call( xwd(-1, -'21), "gettab" ));
     endc
     
     ifcr Tops20 thenc
         integer J, L, C, T;
         J := gjinf( L,C,T );
         C!UserName := dirst( L );
         clear(G!ShowGens);
     endc
     
         C!MetaPrefix := ESC;        ! standard meta prefix ;
         C!XMetaPrefix := CAN;       ! standard xmeta prefix ;
     
         C!Debug := 0;               ! ... unless asked for ;
     
         C!DispatchCount := 0;       ! no commands dispatched, yet. ;
     
         C!CheckPointInterval := 60; ! 60 second delay before checkpoint ;
     
         G!AppendKillP := false;     ! We are not appending to the kill buffer.
                                     ;
         C!Quit := false;            ! we're not dead, yet ;
         C!SPMRegion _ false;        ! Do not swap point and mark on
                                     ! reqion-oriented commands
                                     ;
         G!TextMode _ false;         ! We come up in Normal Mode.
                                     ;
         C!CmdFileP := false;        ! commands are not coming from file ;
         C!DefiningMacro := false;   ! not defining macro ;
         C!Macro := NULL;            ! no macro, yet ;
         C!LastMacro := NULL;        ! no keyboard macro ;
         C!Search := NULL;           ! no search string, yet ;
         C!SearchM := NULL;          ! no m-search string, either ;
         C!QOldStr := null;          ! no q-replace search string ;
         C!QNewStr := null;          ! no q-replace replace string ;
         C!BindingStackPnt := 0;     ! nothing on the bind stack ;
         C!KillCnt := 0;             !  and has nothing in it ;
         C!ArgMultiplier := 4;       ! default multiplier ;
         C!LeftMargin := 1;          ! where the margins are ;
         C!RightMargin := 72;        !  (for those commands who care) ;
         C!VFMode _ 0;               ! Vue-compatibility paragraph fill mode ;
         C!TABWidth := 8;            ! default <tab> width ;
         C!IndentUnitWidth := 2;     ! default indentation unit ;
         C!UseTABS := 1;             ! try to use <TAB>s when indenting ;
         C!JournalMacro := 0;        ! journal macro commands off ;
         C!JournalFile := 0;         ! journal command file commands off ;
         C!JournalCommand := 0;      ! journal all commands off ;
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 19-2
     Prt: 06-Jun-84  13:55                                            Rtn C!Init

         G!Test := 0;                ! test feature off ;
         G!OverWriteP := 0;          ! don't overwrite ;
         G!ESCF := 1;                ! print <ESC> as "$" ;
         G!WrapP := 1;               ! wrap long lines ;
         G!FFBreak := 1;             ! break page on <FF> ;
         G!CRCtl := true;            ! lonely CR displays as "^m" ;
         G!CaseMatch := 0;           ! default to folding case on search ;
         G!MagicMode := 0;
     
         C!MacroDepth_ -1;           ! macro recursion depth ;
     
         C!MacroStack_ new!record( Macro );
         Macro:Next[ C!MacroStack ]_ new!record( Macro );
         Macro:Last[ Macro:Next[ C!MacroStack ] ]_ C!MacroStack;
     
         C!MacroNames_ new!record( Macro );
         Macro:Next[ C!MacroNames ]_ new!record( Macro );
         Macro:Last[ Macro:Next[ C!MacroNames ] ]_ C!MacroNames;
     
         clear(InsertLiterally);             ! Interpret characters as they are
                                             ! inserted.
                                             ;
         C!CreEscChr _ '30;                  ! The default CreAux escape
                                             ! character is ^X.
                                             ;
         C!AuxStr    _ null;                 ! The default login string is
                                             ! empty.
                                             ;
         C!AuxPort   _ -1;                   ! The default auxiliary port is
                                             ! undefined.
                                             ;
     
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 20-1
     Prt: 06-Jun-84  13:55                                   Bind ASCII Commands

     
         ! Initialize the dispatch table ;
     
         define Loc(Routine) = {location( Routine )};
     
         C!Dispatch[  '0 ] := Loc( C!Ignore );       ! ^@ ;
         C!Dispatch[  '1 ] := Loc( C!MoveBOL );      ! ^A ;
         C!Dispatch[  '2 ] := Loc( C!MoveB );        ! ^B ;
         C!Dispatch[  '3 ] := Loc( C!NotExit );      ! ^C ;
         C!Dispatch[  '4 ] := Loc( C!DelF );         ! ^D ;
         C!Dispatch[  '5 ] := Loc( C!MoveEOL );      ! ^E ;
         C!Dispatch[  '6 ] := Loc( C!MoveF );        ! ^F ;
         C!Dispatch[  '7 ] := Loc( C!Err );          ! ^G ;
         C!Dispatch[ '10 ] := Loc( C!DelB );         ! ^H ;
         C!Dispatch[ '11 ] := Loc( C!Insert );       ! ^I ;
         C!Dispatch[ '12 ] := Loc( C!IndentDown );   ! ^J ;
         C!Dispatch[ '13 ] := Loc( C!DelEOL );       ! ^K ;
         C!Dispatch[ '14 ] := Loc( C!Refresh );      ! ^L ;
         C!Dispatch[ '15 ] := Loc( C!Insert );       ! ^M ;
         C!Dispatch[ '16 ] := Loc( C!MoveDown );     ! ^N ;
         C!Dispatch[ '17 ] := Loc( C!Open );         ! ^O ;
         C!Dispatch[ '20 ] := Loc( C!MoveUp );       ! ^P ;
         C!Dispatch[ '21 ] := Loc( C!Quote );        ! ^Q ;
         C!Dispatch[ '22 ] := Loc( C!RRSearch );     ! ^R ;
         C!Dispatch[ '23 ] := Loc( C!RFSearch );     ! ^S ;
         C!Dispatch[ '24 ] := Loc( C!Twiddle );      ! ^T ;
         C!Dispatch[ '25 ] := Loc( C!Arg );          ! ^U ;
         C!Dispatch[ '26 ] := Loc( C!NextScreen );   ! ^V ;
         C!Dispatch[ '27 ] := Loc( C!Wipe );         ! ^W ;
         C!Dispatch[ '30 ] := Loc( C!Err );          ! ^X - *reserved* ;
         C!Dispatch[ '31 ] := Loc( C!Yank );         ! ^Y ;
         C!Dispatch[ '32 ] := Loc( C!ScrollUp );     ! ^Z ;
         C!Dispatch[ '33 ] := Loc( C!Err );          ! ESC - *reserved* ;
         C!Dispatch[ '34 ] := Loc( C!Err );          ! ^\ - not bound ;
         C!Dispatch[ '35 ] := Loc( C!Err );          ! ^] - not bound ;
         C!Dispatch[ '36 ] := Loc( C!Toggle );       ! ^^ ;
         C!Dispatch[ '37 ] := Loc( C!Err );          ! ^_ - not bound ;
     
         ! All normally printable characters self-insert ;
     
         fill( C!Dispatch, '40, '176, Loc(C!Insert) );
     
         C!Dispatch[ DEL ] := Loc( C!DelB );         ! DEL ;
     
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 21-1
     Prt: 06-Jun-84  13:55                                    Bind Meta Commands

     
         ! Meta commands.  Most of these are still undefined. ;
     
         fill( C!Dispatch, '200, '377, Loc(C!Err) );
     
         C!Dispatch[ Meta + '02 ] := Loc( C!MovTokenB );     ! Meta-^B ;
         C!Dispatch[ Meta + '04 ] := Loc( C!DelTokenF );     ! Meta-^D ;
         C!Dispatch[ Meta + '06 ] := Loc( C!MovTokenF );     ! Meta-^F ;
         C!Dispatch[ Meta + '10 ] := Loc( C!DelTokenB );     ! Meta-^H ;
         C!Dispatch[ Meta + '12 ] := Loc( C!RightJustify );  ! Meta-^J ;
         C!Dispatch[ Meta + '27 ] := Loc( C!Copy );          ! Meta-^W ;
         C!Dispatch[ Meta + '32 ] := Loc( C!ScrollDown );    ! Meta-^Z ;
     
         C!Dispatch[ Meta + " " ] := Loc( C!SetMark );       ! Meta-<space> ;
         C!Dispatch[ Meta + "!" ] := Loc( C!LineTOS );       ! Meta-! ;
         C!Dispatch[ Meta + "(" ] := Loc( C!MatchDelim );    ! Meta-( ;
         C!Dispatch[ Meta + ")" ] := Loc( C!MatchDelim );    ! Meta-) ;
         C!Dispatch[ Meta + "," ] := Loc( C!MovTOS );        ! Meta-, ;
         C!Dispatch[ Meta + "." ] := Loc( C!MovBOS );        ! Meta-. ;
         C!Dispatch[ Meta + ":" ] := Loc( C!MovSpecB );      ! Meta-: ;
         C!Dispatch[ Meta + ";" ] := Loc( C!MovSpecF );      ! Meta-;
         C!Dispatch[ Meta + "<" ] := Loc( C!MovBOB );        ! Meta-< ;
         C!Dispatch[ Meta + "=" ] := Loc( C!ShowSearch );    ! Meta-= ;
         C!Dispatch[ Meta + ">" ] := Loc( C!MovEOB );        ! Meta-> ;
         C!Dispatch[ Meta + "?" ] := Loc( C!Help );          ! Meta-? ;
         C!Dispatch[ Meta + "B" ] :=
         C!Dispatch[ Meta + "b" ] := Loc( C!MovTokenB );     ! Meta-b ;
         C!Dispatch[ Meta + "C" ] :=
         C!Dispatch[ Meta + "c" ] := Loc( C!ChangeString );  ! Meta-c ;
         C!Dispatch[ Meta + "D" ] :=
         C!Dispatch[ Meta + "d" ] := Loc( C!DeltokenF );     ! Meta-d ;
         C!Dispatch[ Meta + "F" ] :=
         C!Dispatch[ Meta + "f" ] := Loc( C!MovTokenF );     ! Meta-f ;
         C!Dispatch[ Meta + "G" ] :=
         C!Dispatch[ Meta + "g" ] := Loc( C!GotoMark );      ! Meta-g ;
         C!Dispatch[ Meta + "H" ] :=
         C!Dispatch[ Meta + "h" ] := Loc( C!DelTokenB );     ! Meta-h ;
         C!Dispatch[ Meta + "I" ] :=
         C!Dispatch[ Meta + "i" ] := Loc( C!AddIndent );     ! Meta-i ;
         C!Dispatch[ Meta + "J" ] :=
         C!Dispatch[ Meta + "j" ] := Loc( C!Err );           ! Meta-j ;
         C!Dispatch[ Meta + "K" ] :=
         C!Dispatch[ Meta + "k" ] := Loc( C!DelToEol );      ! Meta-K ;
         C!Dispatch[ Meta + "M" ] :=
         C!Dispatch[ Meta + "m" ] := Loc( C!MSearch );       ! Meta-M ;
         C!Dispatch[ Meta + "O" ] :=
         C!Dispatch[ Meta + "o" ] := Loc( C!OverWrite );     ! Meta-O ;
         C!Dispatch[ Meta + "P" ] :=
         C!Dispatch[ Meta + "p" ] := Loc( C!FillPara );      ! Meta-Q ;
         C!Dispatch[ Meta + "Q" ] :=
         C!Dispatch[ Meta + "q" ] := Loc( C!QueryChange );   ! Meta-Q ;
         C!Dispatch[ Meta + "R" ] :=
         C!Dispatch[ Meta + "r" ] := Loc( C!RSearch );       ! Meta-R ;
         C!Dispatch[ Meta + "S" ] :=
         C!Dispatch[ Meta + "s" ] := Loc( C!FSearch );       ! Meta-S ;
         C!Dispatch[ Meta + "U" ] :=
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 21-2
     Prt: 06-Jun-84  13:55                                    Bind Meta Commands

         C!Dispatch[ Meta + "u" ] := Loc( C!UnIndent );      ! Meta-U ;
         C!Dispatch[ Meta + "V" ] :=
         C!Dispatch[ Meta + "v" ] := Loc( C!PriorScreen );   ! Meta-V ;
         C!Dispatch[ Meta + "W" ] :=
         C!Dispatch[ Meta + "w" ] := Loc( C!ToggleWrap );    ! Meta-W ;
         C!Dispatch[ Meta + "X" ] :=
         C!Dispatch[ Meta + "x" ] := Loc( C!SymDispatch );   ! Meta-X ;
         C!Dispatch[ Meta + "Z" ] :=
         C!Dispatch[ Meta + "z" ] := Loc( C!ScrollDown );    ! Meta-Z ;
     
         C!Dispatch[ Meta + "^" ] := Loc( C!TokenToggle );   ! Meta-^ ;
         C!Dispatch[ Meta + "{" ] := Loc( C!MovBOP );        ! Meta-{ ;
         C!Dispatch[ Meta + "}" ] := Loc( C!MovEOP );        ! Meta-} ;
         C!Dispatch[ Meta + "~" ] := Loc( C!UnModify );      ! Meta-~ ;
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 22-1
     Prt: 06-Jun-84  13:55                                   Bind Xmeta Commands

     
     
       ! XMeta commands ;
     
         fill( C!Dispatch, '400, '577, Loc(C!Err) );
     
         C!Dispatch[ Meta2 + '03 ] := Loc( C!SafeExit );     ! XMeta-^C ;
         C!Dispatch[ Meta2 + '05 ] := Loc( C!RunRPG );       ! XMeta-^E ;
         C!Dispatch[ Meta2 + '06 ] := Loc( C!Finish );       ! XMeta-^F ;
         C!Dispatch[ Meta2 + '11 ] := Loc( C!InsertFile );   ! XMeta-^I ;
         C!Dispatch[ Meta2 + '13 ] := Loc( C!KillBuffer );   ! XMeta-^K ;
         C!Dispatch[ Meta2 + '14 ] := Loc( C!CmdFile );      ! XMeta-^L ;
         C!Dispatch[ Meta2 + '16 ] := Loc( C!NewBuffer );    ! XMeta-^N ;
         C!Dispatch[ Meta2 + '17 ] := Loc( C!WSwitch );      ! XMeta-^O ;
         C!Dispatch[ Meta2 + '22 ] := Loc( C!ReadFile );     ! XMeta-^R ;
         C!Dispatch[ Meta2 + '23 ] := Loc( C!CheckPoint );   ! XMeta-^S ;
         C!Dispatch[ Meta2 + '24 ] := Loc( C!DateTimeMsg );  ! XMeta-^T ;
         C!Dispatch[ Meta2 + '25 ] := Loc( C!UnCheckPoint ); ! XMeta-^U ;
         C!Dispatch[ Meta2 + '27 ] := Loc( C!WriteFile );    ! XMeta-^W ;
     
         C!Dispatch[ Meta2 + '42 ] := Loc( C!MsgText );      ! XMeta-" ;
         C!Dispatch[ Meta2 + "!" ] := Loc( C!RecoverCheckPointFile ); ! XMeta-!|
                                                                          ->| ;|
         C!Dispatch[ Meta2 + "_" ] := Loc( C!AssignVar );    ! XMeta-_ ;
         C!Dispatch[ Meta2 + "<" ] := Loc( C!LastBuffer );   ! XMeta-< ;
         C!Dispatch[ Meta2 + "=" ] := Loc( C!QueryVar );     ! XMeta-= ;
         C!Dispatch[ Meta2 + ">" ] := Loc( C!NextBuffer );   ! XMeta-> ;
         C!Dispatch[ Meta2 + "?" ] := Loc( C!QueryKey );     ! XMeta-? ;
         C!Dispatch[ Meta2 + "-" ] := Loc( C!Lock );         ! XMeta-- ;
         C!Dispatch[ Meta2 + "+" ] := Loc( C!UnLock );       ! XMeta-+ ;
         C!Dispatch[ Meta2 + "|" ] := Loc( C!Comment );      ! XMeta-| ;
     
         C!Dispatch[ Meta2 + "1" ] := Loc( C!W1 );           ! XMeta-1 ;
         C!Dispatch[ Meta2 + "2" ] := Loc( C!W2 );           ! XMeta-2 ;
     
         C!Dispatch[ Meta2 + "B" ] :=
         C!Dispatch[ Meta2 + "b" ] := Loc( C!ReBind );       ! XMeta-b ;
         C!Dispatch[ Meta2 + "D" ] :=
         C!Dispatch[ Meta2 + "d" ] := Loc( C!ReadMacro );    ! XMeta-d ;
         C!Dispatch[ Meta2 + "E" ] :=
         C!Dispatch[ Meta2 + "e" ] := Loc( C!MacroByExample ); !    -e ;
         C!Dispatch[ Meta2 + "G" ] :=
         C!Dispatch[ Meta2 + "g" ] := Loc( C!WGrow );        ! XMeta-g ;
         C!Dispatch[ Meta2 + "I" ] :=
         C!Dispatch[ Meta2 + "i" ] := Loc( C!EnvironStr );   ! XMeta-i ;
         C!Dispatch[ Meta2 + "M" ] :=
         C!Dispatch[ Meta2 + "m" ] := Loc( C!BindMacro );    ! XMeta-m ;
         C!Dispatch[ Meta2 + "N" ] :=
         C!Dispatch[ Meta2 + "n" ] := Loc( C!NormalMode );   ! XMeta-n ;
         C!Dispatch[ Meta2 + "S" ] :=
         C!Dispatch[ Meta2 + "s" ] := Loc( C!SwapPM );       ! XMeta-s ;
         C!Dispatch[ Meta2 + "T" ] :=
         C!Dispatch[ Meta2 + "t" ] := Loc( C!TextMode );     ! XMeta-t ;
         C!Dispatch[ Meta2 + "W" ] :=
         C!Dispatch[ Meta2 + "w" ] := Loc( C!DelWhiteF );    ! XMeta-w ;
         C!Dispatch[ Meta2 + "V" ] :=
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 22-2
     Prt: 06-Jun-84  13:55                                   Bind Xmeta Commands

         C!Dispatch[ Meta2 + "v" ] := Loc( C!DelWhiteB );    ! XMeta-v ;
         C!Dispatch[ Meta2 + "X" ] :=
         C!Dispatch[ Meta2 + "x" ] := Loc( C!ExecLastMacro ); ! XMeta-x ;
     
         C!Dispatch[ Meta2 + "[" ] := Loc( C!PushBinding );  ! XMeta-[ ;
         C!Dispatch[ Meta2 + "]" ] := Loc( C!PopBinding );   ! XMeta-] ;
     
       end "initialization"; |2|
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 23-1
     Prt: 06-Jun-84  13:55                                 Expand Command Tables

     
     ! Build the symbolic command access tables
     ;
       require " [Expanding Command Tables]
     " message;
     
       define $CC = 0, $CN = {preload!with }, $CA = {};
     
       define $Cmd( N, A ) = {
         redefine $CC = $CC + 1;
         redefine $CN = cvms( $CN ) & {N, };
         redefine $CA = cvms( $CA ) & {SymCmdA[}& cvms($CC) &{] := location(A);|
                                                                         ->| };|
       }; |1|
     
         ! setting the argument ;
     
         $Cmd( "Argument",                   C!Arg );
     
         ! moving around ;
     
         $Cmd( "Up",                         C!MoveUp );
         $Cmd( "Down",                       C!MoveDown );
         $Cmd( "Forward",                    C!MoveF );
         $Cmd( "Backward",                   C!MoveB );
         $Cmd( "Forward Token",              C!MovTokenF );
         $Cmd( "Backward Token",             C!MovTokenB );
         $Cmd( "Beginning of Line",          C!MoveBOL );
         $Cmd( "End of Line",                C!MoveEOL );
         $Cmd( "Forward Window",             C!NextScreen );
         $Cmd( "Backward Window",            C!PriorScreen );
         $Cmd( "Top of Window",              C!MovTOS );
         $Cmd( "Bottom of Window",           C!MovBOS );
         $Cmd( "Top of Page",                C!MovBOP );
         $Cmd( "Bottom of Page",             C!MovEOP );
         $Cmd( "Top of Buffer",              C!MovBOB );
         $Cmd( "Bottom of Buffer",           C!MovEOB );
         $Cmd( "Line to Top of Window",      C!LineTOS );
         $Cmd( "Scroll Window Up",           C!ScrollUp );
         $Cmd( "Scroll Window Down",         C!ScrollDown );
     
         ! deleting stuff ;
     
         $Cmd( "Delete",                     C!DelF );
         $Cmd( "Delete Backward",            C!DelB );
         $Cmd( "Delete Token Forward",       C!DelTokenF );
         $Cmd( "Delete Token Backward",      C!DelTokenB );
         $Cmd( "Kill Line",                  C!DelEOL );
         $Cmd( "Set Append Kill",            C!SetAppendKill );
         $Cmd( "Kill Partial Line",          C!DelToEOL );
         $Cmd( "Delete Whitespace Forward",  C!DelWhiteF );
         $Cmd( "Delete Whitespace Backward", C!DelWhiteB );
     
         ! inserting stuff ;
     
         $Cmd( "Insert",                     C!Insert );
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 23-2
     Prt: 06-Jun-84  13:55                                 Expand Command Tables

         $Cmd( "Insert CRLF",                C!InsertCRLF );
         $Cmd( "Insert TAB",                 C!InsertTAB );
         $Cmd( "Quote",                      C!Quote );
         $Cmd( "Column Insert",              C!InsStrtoCol );
         $Cmd( "Insert Octal",               C!InsertOctal );
     
         ! manipulation of lines ;
     
         $Cmd( "Open Line",                  C!Open );
         $Cmd( "Open Line With Indent",      C!IndentDown );
         $Cmd( "Indent Column Down",         C!ColumnDown );
         $Cmd( "Indent Line Down",           C!IndentDown );
         $Cmd( "Indent Line Up",             C!IndentUp );
         $Cmd( "Center Line",                C!Center );
         $Cmd( "Right Justify Line",         C!RightJustify );
         $Cmd( "Indent Line",                C!AddIndent );
         $Cmd( "Unindent Line",              C!UnIndent );
     
         ! other manipulations ;
     
         $Cmd( "Toggle Case",                C!Toggle );
         $Cmd( "Token UC",                   C!TokenUC );
         $Cmd( "Token LC",                   C!TokenLC );
         $Cmd( "Toggle Token",               C!TokenToggle );
         $Cmd( "Capitalize Token",           C!CapitalizeToken );
         $Cmd( "Transpose",                  C!Twiddle );
         $Cmd( "Up Paragraph",               C!BckHalfPara );
         $Cmd( "Down Paragraph",             C!FwdHalfPara );
         $Cmd( "Fill Line",                  C!FillLine );
         $Cmd( "Fill Paragraph",             C!FillPara );
         $Cmd( "Fill to End of Paragraph",   C!FillToEOP );
         $Cmd( "Set Left Margin",            C!SetLM );
         $Cmd( "Set Right Margin",           C!SetRM );
         $Cmd( "Force Left Margin",          C!ForceLeftMargin );
         $Cmd( "Goto Column",                C!GotoColumn );
         $Cmd( "Show Column",                C!ShowColumn );
         $Cmd( "Show Octal",                 C!ShowOctal );
     
         ! searching ;
     
         $Cmd( "Search",                     C!FSearch );
         $Cmd( "Copy to Search",             C!CopyToSearch );
         $Cmd( "Search Again",               C!RFSearch );
         $Cmd( "Show Search String",         C!ShowSearch );
         $Cmd( "Reverse Search",             C!RSearch );
         $Cmd( "Reverse Search Again",       C!RRSearch );
         $Cmd( "Change",                     C!ChangeString );
         $Cmd( "Query Change",               C!QueryChange );
         $Cmd( "Repeat Query Change",        C!RepeatQChange );
         $Cmd( "Multiple Search",            C!MSearch );
         $Cmd( "Match Parens",               C!MatchDelim );
         $Cmd( "Special Search",             C!MovSpecF );
         $Cmd( "Reverse Special Search",     C!MovSpecB );
     
         ! marks and region commands ;
     
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 23-3
     Prt: 06-Jun-84  13:55                                 Expand Command Tables

         $Cmd( "Set Mark",                   C!SetMark );
         $Cmd( "Clear Mark",                 C!ClearMark );
         $Cmd( "Swap Mark",                  C!SwapPM );
         $Cmd( "Goto Mark",                  C!GotoMark );
         $Cmd( "Copy Region",                C!Copy );
         $Cmd( "Wipe Region",                C!Wipe );
         $Cmd( "Insert Kill Buffer",         C!Yank );
         $Cmd( "Indent Region",              C!IndentRegion );
         $Cmd( "Unindent Region",            C!UnindentRegion );
     
         ! Window Manipulations ;
     
         $Cmd( "Split Window",               C!W2 );
         $Cmd( "Unsplit Window",             C!W1 );
         $Cmd( "Switch Windows",             C!WSwitch );
         $Cmd( "Grow Window",                C!WGrow );
         $Cmd( "Window Bar",                 C!WBar );
         $Cmd( "Refresh Window",             C!Refresh );
     
         ! Buffer manipulations ;
     
         $Cmd( "New Buffer",                 C!NewBuffer );
         $Cmd( "Delete Buffer",              C!KillBuffer );
         $Cmd( "Next Buffer",                C!NextBuffer );
         $Cmd( "Last Buffer",                C!LastBuffer );
         $Cmd( "Lock Buffer",                C!Lock );
         $Cmd( "Unlock Buffer",              C!UnLock );
         $Cmd( "UnModify Buffer",            C!UnModify );
     
         ! Reading/Writing Files ;
     
         $Cmd( "Read File",                  C!ReadFile );
         $Cmd( "Insert File",                C!InsertFile );
         $Cmd( "Write File",                 C!WriteFile );
         $Cmd( "Command File",               C!CmdFile );
         $Cmd( "Finish",                     C!Finish );
         $Cmd( "Finish to RPG",              C!RunRPG );
         $Cmd( "Checkpoint",                 C!Checkpoint );
         $Cmd( "Recover Checkpoint",         C!UnCheckPoint );
         $Cmd( "Recover CheckPoint File",    C!RecoverCheckPointFile );
         $Cmd( "Safe Exit",                  C!SafeExit );
         $Cmd( "Exit",                       C!Exit );
     
         ! mode stuff ;
     
         $Cmd( "Text Mode",                  C!TextMode );
         $Cmd( "Normal Mode",                C!NormalMode );
         $Cmd( "Toggle Wrap Flag",           C!ToggleWrap );
         $Cmd( "Toggle Overwrite Flag",      C!OverWrite );
     
         ! variable, macro and key binding stuff ;
     
         $Cmd( "Bind Variable",              C!AssignVar );
         $Cmd( "Query Variable",             C!QueryVar );
         $Cmd( "Bind Function",              C!ReBind );
         $Cmd( "Query Function",             C!QueryKey );
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 23-4
     Prt: 06-Jun-84  13:55                                 Expand Command Tables

         $Cmd( "Execute Function",           C!SymDispatch );
         $Cmd( "UnBind Key",                 C!UnBindKey );
         $Cmd( "Define Macro",               C!ReadMacro );
         $Cmd( "Define Macro by Example",    C!MacroByExample );
         $Cmd( "Bind Macro",                 C!BindMacro );
         $Cmd( "Name Macro",                 C!NameMacro );
         $Cmd( "UnName Macro",               C!UnNameMacro );
         $Cmd( "Push Binding",               C!PushBinding );
         $Cmd( "Pop Binding",                C!PopBinding );
         $Cmd( "Execute Macro",              C!ExecLastMacro );
     
         ! manipulating the character table ;
     
         $Cmd( "Is Number",                  C!SetNum );
         $Cmd( "Not Number",                 C!ClearNum );
         $Cmd( "Is Token",                   C!SetToken );
         $Cmd( "Not Token",                  C!ClearToken );
         $Cmd( "Is Delim",                   C!SetDelim );
         $Cmd( "Not Delim",                  C!ClearDelim );
         $Cmd( "Is Special",                 C!SetSpecial );
         $Cmd( "Not Special",                C!ClearSpecial );
     
         ! misc. ;
     
         $Cmd( "Delete NULLs",               C!DelNULLs );
         $Cmd( "XOFF Synch",                 C!XOFFSynch );
         $Cmd( "Nothing",                    C!Ignore );
         $Cmd( "Frame Push",                 C!PushFrame );
         $Cmd( "Beep",                       T!Bell );
         $Cmd( "Help",                       C!Help );
         $Cmd( "Abort Command",              C!Err );
         $Cmd( "Start Comment",              C!Comment );
         $Cmd( "Start Message",              C!MsgText );
         $Cmd( "Date Time Message",          C!DateTimeMsg );
         $Cmd( "Insert Information String",  C!EnvironStr );
         $Cmd( "Increment Char",             C!IncrChar );
         $Cmd( "Decrement Char",             C!DecrChar );
         $Cmd( "Set Terminal Type",          C!SetTermType );
     
         ifcr TymcomX thenc
           $Cmd( "CreAux",                   C!CreAux );
           $Cmd( "Set CreAux Esc Char",      C!SetCreEsc );
         endc
     
       ! finish up the macro ;
     
       redefine $CN = cvms( $CN ) &
         {NULL; safe string array SymCmd[ 1 : $CC + 1 ]; }; |1|
     
       ! expand the name table ;
     
       $CN
     
       ! allocate the address table ;
     
       safe integer array SymCmdA[ 1 : $CC ];
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 24-1
     Prt: 06-Jun-84  13:55                                    Rtn InitSymCmdAddr

     
     
     procedure InitSymCmdAddr;
       begin |2|
         $CA
       end; |2|
     
     require InitSymCmdAddr initialization;
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 25-1
     Prt: 06-Jun-84  13:55                                Expand Variable Tables

     
     ! Now do the symbolic variable access stuff
     ;
     
       require " [Expanding Variable Tables]
     " message;
     
       define $VC = 0, $VN = {preload!with }, $VA = {};
     
       define $Var( N, A ) = {
         redefine $VC = $VC + 1;
         redefine $VN = cvms( $VN ) & {N, };
         redefine $VA = cvms( $VA ) & {SymVarA[}& cvms($VC) &{] := location(A);|
                                                                         ->| };|
       }; |1|
     
         $Var( ".Debug",             C!Debug );
         $Var( ".Cmd",               C!Cmd );
         $Var( ".LastCmd",           C!LastCmd );
         $Var( ".Arg",               C!ArgV );
         $Var( ".ScreenWidth",       T!Width );
         $Var( ".ExitToRPG",         F!RPGFlag );
         $Var( ".MetaPrefix",        C!MetaPrefix );
         $Var( ".XMetaPrefix",       C!XMetaPrefix );
         $Var( ".Box",               W!BoxP );
         $Var( ".StickyColumn",      C!StickyColumn );
     
         $Var( "Multiplier",         C!ArgMultiplier );
         $Var( "WrapLongLines",      G!WrapP );
         $Var( "BreakPageOnFF",      G!FFBreak );
         $Var( "EscapeAs$",          G!ESCF );
         $Var( "OverWriteOnInsert",  G!OverWriteP );
         $Var( "UseTabs",            C!UseTabs );
         $Var( "TabWidth",           C!TABWidth );
         $Var( "IndentWidth",        C!IndentUnitWidth );
         $Var( "LeftMargin",         C!LeftMargin );
         $Var( "RightMargin",        C!RightMargin );
         $Var( "ExactCaseMatch",     G!CaseMatch );
         $Var( "CRAsCtl",            G!CRCtl );
         $Var( "JournalMacro",       C!JournalMacro );
         $Var( "JournalFile",        C!JournalFile );
         $Var( "JournalCommand",     C!JournalCommand );
         $Var( "SwapPMRegion",       C!SPMRegion);
         $Var( "VariableFill",       C!VFMode);
     
         $Var( "CheckpointInterval", C!CheckPointInterval );
     
       redefine $VN = cvms( $VN ) &
         { NULL; safe string array SymVar[ 1 : $VC + 1 ]; }; |1|
     
       $VN
     
       safe integer array SymVarA[ 1 : $VC ];
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 26-1
     Prt: 06-Jun-84  13:55                                       Rtn InitVarLocs

     
     
     procedure InitVarLocs;
       begin |2|
         $VA
       end; |2|
     
     require InitVarLocs initialization;
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 27-1
     Prt: 06-Jun-84  13:55                                        Rtn SymCmdAddr

     
     ! Routine to return the address of a function given its name.
     ! Two types of address are returned:
     !        0 ,, Addr of Routine in Command Tables  (or)
     !     Flag ,, Record Pointer to Keyboard Macro
     ;
     
     integer procedure SymCmdAddr( string Cmd );
       begin "addr" |2|
         integer I, Index;
         record!pointer (Macro) Idx, Ptr;
     
         Index := 0;
     
         ! Start with zero index "*unknown*" := 0        ;
         ! If we find a partial match -- then            ;
         !   If an exact match,                          ;
         !     then return the address                   ;
         !     else If non-zero-index [previous match]   ;
         !            then return "*ambigious*" := -1    ;
         !            else set index for match           ;
         ! If Index is non-zero, then return the address ;
         !   else return 0                               ;
     
         Ptr_ C!MacroNames;
         while ( Ptr_ Macro:Next[ Ptr ] ) do
           if ( kequ( Cmd, Macro:Name[ Ptr ][1 for length( Cmd )] )) then
     
             if ( kequ( Cmd, Macro:Name[ Ptr ] )) then
               return( Macro:Id[ Ptr ] )
             else if ( Idx ) then
                    if ( kequ( Macro:Name[ Ptr ], Macro:Name[ Idx ] )) then
                    else return( -1 )
                  else
                    Idx_ Ptr;
     
         if ( Idx ) then
           Index_ Macro:Id[ Idx ];
     
         for I := 1 upto $CC do
           if ( kequ( Cmd, SymCmd[ I ][1 for length( Cmd )] )) then
     
             if ( kequ( Cmd, SymCmd[ I ] )) then
               return( SymCmdA[ I ] )
             else if ( Index ) then
                    if ( lh( Index ) = C!MacroPointer ) then
                      if ( kequ(SymCmd[I], Macro:Name[ Idx ] )) then
                      else return( -1 )
                    else return( -1 )
                  else
                    Index := I;
     
         return( if Index then
                   if ( lh( Index ) = C!MacroPointer ) then
                     Index
                   else
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 27-2
     Prt: 06-Jun-84  13:55                                        Rtn SymCmdAddr

                     SymCmdA[ Index ]
                 else 0 );
     
       end "addr"; |2|
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 28-1
     Prt: 06-Jun-84  13:55                                        Rtn SymVarAddr

     
     ! Given a variable name, return it's address.
     ;
     
     integer procedure SymVarAddr( string Sym );
       begin "val" |2|
         integer I, Index;
     
         Index := 0;
     
         ! Start with zero index "*unknown*" := 0        ;
         ! If we find a partial match -- then            ;
         !   If an exact match,                          ;
         !     then return the address                   ;
         !     else If non-zero-index [previous match]   ;
         !            then return "*ambigious*" := -1    ;
         !            else set index for match           ;
         ! If Index is non-zero, then return the address ;
         !   else return 0                               ;
     
         for I := 1 upto $VC do
           if ( kequ( Sym, SymVar[ I ][1 for length( Sym )] )) then
     
             if ( kequ( Sym, SymVar[ I ] )) then
               return( SymVarA[ I ] )
             else if ( Index ) then
                    return( -1 )
                  else
                    Index := I;
     
         return( if Index then SymVarA[ Index ] else 0 );
     
       end "val"; |2|
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 29-1
     Prt: 06-Jun-84  13:55                                        Rtn SymCmdName

     
     ! Given an address, figure out what routine it is.
     ! Two types of address are deciphered:
     !        0 ,, Addr of Routine in Command Tables  (or)
     !     Flag ,, Record Pointer to Keyboard Macro
     ;
     
     string procedure SymCmdName( integer Addr );
       begin "name" |2|
         integer I;
         record!pointer (Macro) Ptr;
     
         if ( lh( Addr ) = C!MacroPointer ) then
           begin "macro name pointer" |3|
     
             Ptr_ C!MacroNames;
             while ( Ptr_ Macro:Next[ Ptr ] ) do
               if ( Macro:Id[ Ptr ] = Addr ) then
                 return( Macro:Name[ Ptr ] & " (Macro)" );
     
             Ptr_ C!MacroStack;
             while ( Ptr_ Macro:Next[ Ptr ] ) do
               if ( Macro:Id[ Ptr ] = Addr ) then
                 return( if length( Macro:Name[ Ptr ] ) then
                           Macro:Name[ Ptr ] & " (Macro)"
                         else """Un-named"" (Macro)" );
     
           end "macro name pointer" |3|
     
           else
             for I := 1 upto $CC do
               if ( SymCmdA[ I ] = Addr ) then return( SymCmd[ I ] );
     
         return( NULL );
     
       end "name"; |2|
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 30-1
     Prt: 06-Jun-84  13:55                                        Rtn SymVarName

     
     ! Given an address, figure out what variable it is.
     ;
     
     string procedure SymVarName( integer Addr);
       begin "name" |2|
         integer I;
     
         for I := 1 upto $VC do
           if ( SymVarA[ I ] = Addr ) then return( SymVar[ I ] );
     
         return( NULL );
     
       end "name"; |2|
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 31-1
     Prt: 06-Jun-84  13:55                                            Rtn C!Loop

     
     ! C!Loop - the main command dispatch lives here.  "Meta" and "XMeta"
     ! commands are formed by routine C!GetCMD. ;
     
     internal recursive procedure C!Loop;
     begin "command loop" |2|
       integer
         Cmd;
     
       W!NewS;
     
       forever do
       begin "loop" |3|
         Cmd _ C!GetCMD;
     
         if (Cmd < 0) then
           done "loop";
     
         Dispatch(Cmd);
     
         if (C!Quit) then
           done "loop";
       end "loop"; |3|
     end "command loop"; |2|
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 32-1
     Prt: 06-Jun-84  13:55                                            Rtn C!File

     
     ! C!File - take commands from a file ;
     ;
     
     simple boolean procedure C!File (string F);
     begin "cmd file" |2|
       ifcr TymcomX thenc
         if ( not F!Lookup( F )) then return( false );
     
         C!CmdFileP := true;         ! now taking commands from file ;
         C!Loop;                     ! take the commands ;
         C!CmdFileP := false;        ! done with file ;
         F!Release;                  ! release the file ;
         C!Quit := false;            ! keep us in the command loop ;
     
         return( true );             ! return success ;
       endc
     
       ifcr Tops20 thenc
         CF!Chan _ openfile(F, "ROE");
     
           ! Try opening the command file.
           ;
     
         if (!skip!) then
           return(false);
     
           ! Could not open the command file.
           ;
     
         set(C!CmdFileP);
     
           ! Now taking commands from file.
           ;
     
         C!Loop;
     
           ! Take the commands.
           ;
     
         clear(C!CmdFileP);
     
           ! Done with file.
           ;
     
         cfile(CF!Chan);
     
           ! Release the file.
           ;
     
         clear(C!Quit);
     
           ! Keep us in the command loop.
           ;
     
         return(true);
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 32-2
     Prt: 06-Jun-84  13:55                                            Rtn C!File

     
           ! Return success.
           ;
       endc
     end "cmd file"; |2|
     Cre: 25-Apr-84  12:00  (PEAKX)COMAND.SAI                          Page 33-1
     Prt: 06-Jun-84  13:55                                             Rtn C!Ini

     
     ! C!Ini - read initialization file.
     ;
     
     internal procedure C!INI;
       begin |2|
         string IniFileName;
     
         ifcr TymcomX thenc
           IniFileName _ "(" & C!UserName & ")" & DED!Alias & ".INI";
         endc
     
         ifcr Tops20 thenc
           ifcr false thenc
             IniFileName _ "PS:<" & C!UserName & ">" & DED!Alias & ".INI";
           elsec
             IniFileName _ "PS:[" & C!UserName & "]" & "FtPeak.Ini";
           endc
         endc
     
         if (not C!File(IniFileName)) then
           W!Msg("No " & IniFileName)
         else
           W!Msg(null);
       end; |2|
     end "DED - Command module"; |1|
     
     
     ! **************************  End Comand.Sai  *************************** ;

 mN