	.TITLE	LINC   - LINE INTERFACE DRIVER TYPE C (DH11)
	.SBTTL	LINC   - NEXILIS/JRG

	XLPAR				;DON'T LIST PARAMETER FILE
;	SYMBOL

	CODE

	.SBTTL	LINC   - RESET ROUTINE

;THIS ROUTINE IS CALED WHEN THE NODE IS STARTED OR RESTARTED

ASCINT::TST	@ADCSCR#(R4)		;DOES THE HARDWARE FOR THIS LINE EXIST?
	NXMJMP	ASCIN8			;NO!
	BIS	#$S1AVL,SDSTS1#(SD)	;YES-INDICATE THIS LINE IS AVAILABLE
	MOVB	SDTRXA#(SD),R2		;GET INDEX FOR LINE ON INTERFACE
	BNE	ASCIN2			;CONTINUE IF NOT FIRST LINE
	BIS	#004000,@ADCSCR#(R4)	;FIRST LINE-RESET THE INTERFACE
	CLR	ADCBAX#(R4)		;AND CLEAR IN-MEMORY COPY OF ENABLE
					;  BITS
	BISB	#$A1AVL,ADSTS1#(R4)	;INDICATE INTERFACE IS AVAILABLE
ASCIN2:	TST	ADCCSR#(R4)		;IS THERE DATA SET CONTROL HARDWARE FOR
					;  THIS LINE?
	BEQ	4$			;NO
	TST	@ADCCSR#(R4)		;YES-DOES IT REALLY EXIST?
	NXMJMP	2$			;NO
	BR	ASCIN4			;YES-GO ON

;HERE IF HAVE NO DATA SET CONTROL HARDWARE FOR THIS LINE

2$:	CLR	ADCCSR#(R4)		;No data set control
4$:	BIS	#$T0HWR,SDTRS0#(SD)	;FORCE THIS LINE TO BE HARDWIRED!
ASCIN4:	TBBE	$T0HWR,SDTRS0#(SD),ASCIN6;NOTHING NEEDED HERE IF DIAL-UP
	ASL	R1			;FOR WORD INDEXING
	MOVB	R2,@ADCSCR#(R4)		;POINT HARDWARE TO THIS LINE
	MOV	ASCRAT(R1),@ADCLPR#(R4)	;SET HARDWARE BITS FOR THIS BAUD RATE
ASCIN6:	INC	R2			;IS THIS THE LAST LINE ON INTERFACE?
	CMPB	ADMAXI#(R4),R2
	BGT	RTN001			;NO
	MOV	#020100,@ADCSCR#(R4)	;YES-ENABLE THE INTERFACE
RTN001:	RETURN				;FINISHED

;HERE IF HARDWARE FOR INTERFACE DOES NOT EXIST

ASCIN8:	BICB	#$A1AVL,ADSTS1#(R4)	;Indicate hardware does not exist
	RETURN				;THATS ALL
	.PAGE
	.SBTTL	LINC   - INTERRUPT LEVEL ROUTINES

;HERE FOR INPUT READY INTERRUPT
;BEFORE GETTING HERE THE FOLLOWING CODE HAS BEEN EXECUTED:
;	ASnIN:	PUSH	R4		;SAVE R4
;		MOV	#ADCn$,R4	;GET ADDRESS OF ADB
;		JMP	ASCINI		;GO TO COMMON ROUTINE

ASCINI::PUSH	R0			;SAVE R0 TOO
	PUSH	R1			;AND R1
INPGET:	MOV	@ADCRCR#(R4),R0		;GET CHARACTER
	BPL	INPDON			;FINISHED IF NOTHING THERE
	TBBN	020000,R0,INPBRK	;BREAK ON LINE?
	MOV	#.LFDAT,R1		;NO-FUNCTION = .LFDAT
INPGE2:	BIC	#170000,R0		;REMOVE JUNK
	ADD	ADINDX#(R4),R0		;ADD THE LINE INDEX
	CALL	TRINTR#			;CALL THE TERMINAL SERVICE
	BR	INPGET			;GO CHECK FOR ANOTHER CHARACTER

;HERE FOR INPUT OF BREAK CHARACTER

INPBRK:	MOV	#.LFBRK,R1		;FUNCTION = .LFBRK
	BR	INPGE2			;CONTINUE

;HERE FOR OUTPUT DONE INTERRUPT
;BEFORE GETTING HERE THE FOLLOWING CODE HAS BEEN EXECUTED:
;	ASnOU:	PUSH	R4		;SAVE R4
;		MOV	#ADCn$,R4	;GET ADDRESS OF ADB
;		JMP	ASCOUI		;GO TO COMMON ROUTINE

ASCOUI::PUSH	R0			;SAVE R0
	PUSH	R1			;AND R1
OUTLP0:	BIC	#100000,@ADCSCR#(R4)	;CLEAR OUTPUT DONE HARDWARE FLAG
	MOV	ADCBAX#(R4),R1		;GET BITS FOR LINES WE THINK ARE ACTIVE
	MOV	@ADCBAR#(R4),R0		;GET THE INTERFACE'S BITS
	BIC	R0,R1			;GET JUST THOSE WHICH ARE DONE
	BEQ	OUTDON			;FINISHED IF FALSE ALARM!
	MOV	R0,ADCBAX#(R4)		;UPDATE OUR BITS
	MOV	#20,R0			;INITIALIZE COUNTER
OUTLP1:	ROL	R1			;GET NEXT BIT
	BCC	2$
	PUSH	R0			;SAVE AC'S
	PUSH	R1
	DEC	R0			;GET LINE INDEX
	SWAB	R0			;IN THE RIGHT PLACE
	ADD	ADINDX#(R4),R0		;PLUS OFFSET
	CLR	R1			;INDICATE OUTPUT DONE
	CALL	TRINTR#			;CALL TERMINAL SERVICE
	POP	R1			;RESTORE AC'S
	POP	R0
2$:	SOB	R0,OUTLP1		;CONTINUE IF MORE TO CHECK
OUTDON:	TST	@ADCSCR#(R4)		;DID ANOTHER ONE SNEEK IN?
	BMI	OUTLP0			;YES-GO HANDLE IT NOW
INPDON:	POP	R1			;RESTORE R1
	POP	R0			;AND R0
	POP	R4			;AND R4
	RTI				;DISMISS INTERRUPT

;HERE FOR DATA-SET INTERRUPT
;BEFORE GETTING HERE THE FOLLOWING CODE HAS BEEN EXECUTED:
;	ASnDS:	PUSH	R4		;SAVE R4
;		MOV	#ADCn$,R4	;GET ADDRESS OF ADB
;		JMP	ASCDSI		;GO TO COMMON ROUTINE

ASCDSI::PUSH	R0			;SAVE R0
	MOV	@ADCCSR#(R4),R0		;GET DATA-SET WORD
	BPL	ASCDS2			;GO ON IF NOT RING INDICATOR
	PUSH	R0			;SAVE BITS
	MOV	#.LFRNG,R1		;GET FUNCTION = RING INDICATION
	CALL	SNDDSF			;SEND IT TO THE TERMINAL SERVICE
	POP	R0			;RESTORE BITS
ASCDS2:	TBBE	040000,R0,ASCDS4	;CARRIER CHANGE?
	TBBN	100,@ADCLSR#(R4),2$	;YES-DO WE HAVE CARRIER NOW?
	MOV	#.LFCLS,R1		;NO-REPORT CARRIER LOSS
	BR	4$

2$:	MOV	#.LFCDT,R1		;YES-REPROT CARRIER DETECT
4$:	CALL	SNDDSF			;SEND TO THE TERMINAL SERVICE
ASCDS4:	BIS	#100,@ADCCSR#(R4)	;CLEAR DONE TO RE-ENABLE THE SCANNER!
	BR	INPDON			;AND GO DISMISS INTERRUPT

;SUBROUTINE TO SEND DATA-SET FUNCTION TO TERMINAL SERVICE
;	C(R1) = FUNCTION
;	CALL	SNDDSF

SNDDSF:	MOV	@ADCLSR#(R4),R0		;GET OFFSET ON INTERFACE
	BIC	#^C17,R0		;REMOVE JUNK
	SWAB	R0			;GET THINGS IN THE RIGHT PLACE
	ADD	ADINDX#(R4),R0		;ADD IN BASE OFFSET FOR INTERFACE
	CJMP	TRINTR#			;CALL TERMINAL SERVICE AND RETURN
	.PAGE
	.SBTTL	LINC   - OUTPUT ROUTINES

;SUBROUTINE TO OUTPUT DATA - CALLED ONLY AT MAIN PROGRAM LEVEL
;	C(R0) = CHARACTER TO OUTPUT
;	C(R4) = ADDRESS OF ADB
;	C(SD) = ADDRESS OF SDB
;	CALL	ASCOUT
ASCOUT::MOVB	SDTRXA#(SD),R1		;GET OFFSET OF THIS LINE ON THE
					;  INTERFACE
	MOV	#SDTRCC#,R2		;GET ADDRESS OF CHARACTER
	ADD	SD,R2
	MOVB	R0,(R2)			;STORE CHARACTER
	MOV	R1,R3			;MAKE LINE OFFSET INTO WORD INDEX
	ASL	R3
	MOV	ASCBIT(R3),R3		;GET BIT FOR LINE
	BIS	#100,R1			;KEEP RECEIVE ENABLE SET!
	SETPSW	#340			;NO INTERRUPTS NOW!
	MOVB	R1,@ADCSCR#(R4)		;SELECT LINE
	MOV	#-1,@ADCBCR#(R4)	;SET BYTE COUNT = 1
	MOV	R2,@ADCCAR#(R4)		;SET ADDRESS
	BIS	R3,@ADCBAR#(R4)		;START THE LINE
	BIS	R3,ADCBAX#(R4)		;REMEMBER WE DID IT
	CLRPSW				;INTERRUPTS OK NOW!
	RETURN				;THATS ALL
	.PAGE
;SUBROUTINE TO PROFORM FUNCTION - CALLED ONLY AT MAIN PROGRAM LEVEL
;	C(R0) = FUNCTION
;	C(R1) = DATA (IF ANY)
;	C(R4) = ADDRESS OF ADB
;	C(SD) = ADDRESS OF SDB
;	CALL	ASCFNC
;	C:SET = ERROR

ASCFNC::MOVB	SDTRXA#(SD),R2		;GET OFFSET OF LINE ON INTERFACE
	BIS	#100,R2			;SET INTERRUPT ENABLE BIT
	ADD	R0,PC			;DISPATCH ON THE FUNCTION
	BR	SNDBRK			;.LFSBK =  0  SEND BREAK
	BR	SETHWR			;.LFSET =  2  Set interface parameters
	BR	ANSWER			;.LFANS =  4  Answer line
;	BR	HANGUP			;.LFFHG =  6  Force hang up

;HERE TO FORCE HANGUP ON LINE

HANGUP:	TST	ADCCSR#(R4)		;Data set control?
	BEQ	RTNSEC			;No
	SETPSW	#340			;NO INTERRUPTS NOW
	BIC	#20,@ADCCSR#(R4)	;DISABLE DATA-SET SCANNER
	MOV	R2,@ADCCSR#(R4)		;SET LINE
	BIC	#2,@ADCLSR#(R4)		;TURN OFF DTR
	BR	ENBSCN			;THATS ALL

;HERE TO ANSWER LINE

ANSWER:	TST	ADCCSR#(R4)		;Data set control?
	BEQ	RTNSEC
	SETPSW	#340			;NO INTERRUPTS NOW
	BIC	#20,@ADCCSR#(R4)	;DISABLE DATA-SET SCANNER
	MOVB	R2,@ADCCSR#(R4)		;SET LINE
	BIS	#2,@ADCLSR#(R4)		;TURN ON DTR
ENBSCN:	BIS	#20,@ADCCSR#(R4)	;ENABLE DATA-SET SCANNER
	BR	CLRRTN			;THATS ALL

;Here to setup interface parameters to match values stored in the SDB -
;  input speed, output speed, character size, number of stop bits, parity
;  enable, and parity sense are setup
;	C(R2) = Offset for line on interface plus input interrupt enable bit

SETHWR:	MOVB	SDTRS3#+1(SD),R1	;Get input baud rate
	BIC	#^C<$BRIRT/400>,R1
	ASL	R1			;For word indexing
	MOV	ASCRAT(R1),R0		;Get bits for the hardware
	BEQ	RTNSEC			;Error if hardware can't handle this rate
	BIC	#^C036000,R0		;Isolate the baud rate
	ASHI	-4,R0			;Position for input rate field
	MOVB	SDTRS3#(SD),R1		;Get output baud rate
	BIC	#^C$BRORT,R1
	ASL	R1			;For word indexing
	BIS	ASCRAT(R1),R0		;Get bits for the hardware
	BEQ	RTNSEC			;Error if no data for this rate
	TBBE	$T4PAR,SDTRS4#(SD),4$	;Do we want parity handling?
	TBBN	$T1IMO,SDTRS1#(SD),4$	;Really?
	TBBE	3,R0,4$			;Yes-can we do it for this baud rate?
	DEC	R0			;Yes-adjust character size
	BIS	#20,R0			;Indicate want parity handling
	TBBE	$T4ODD,SDTRS4#(SD),4$	;Want odd parity?
	BIS	#40,R0			;Yes
4$:	SETPSW	#340			;No interrupts now
	MOVB	R2,@ADCSCR#(R4)		;Set hardware to this line
	MOV	R0,@ADCLPR#(R4)		;Set bits in hardware
CLRRTN:	CLRPSW				;Interupts OK now
RTNCLC:	CLC				;GIVE GOOD RETURN
	RETURN				;THATS ALL

;HERE IF ERROR

RTNSEC:	SEC				;GIVE ERROR RETURN
	RETURN

;HERE TO SEND BREAK ON LINE

SNDBRK:	BR	RTNSEC			;NOT YET!!
	.PAGE
	.SBTTL	LINC   - PURE DATA

	PURE

;TABLE OF BITS POSITIONED FOR EACH LINE

ASCBIT:	.WORD	000001		; 0TH LINE
	.WORD	000002		; 1ST LINE
	.WORD	000004		; 2ND LINE
	.WORD	000010		; 3RD LINE
	.WORD	000020		; 4TH LINE
	.WORD	000040		; 5TH LINE
	.WORD	000100		; 6TH LINE
	.WORD	000200		; 7TH LINE
	.WORD	000400		; 8TH LINE
	.WORD	001000		; 9TH LINE
	.WORD	002000		;10TH LINE
	.WORD	004000		;11TH LINE
	.WORD	010000		;12TH LINE
	.WORD	020000		;13TH LINE
	.WORD	040000		;14TH LINE
	.WORD	100000		;15TH LINE

;TABLE OF VALUES FOR LPR FOR EACH BAUD RATE

ASCRAT:	.WORD	000000		; 0 =  AUTO-DETECT
	.WORD	002004		; 1 =    50   BAUD, 5 BITS, 1.5 STOP BITS
	.WORD	004004		; 2 =    75   BAUD, 5 BITS, 1.5 STOP BITS
	.WORD	006007		; 3 =   110   BAUD, 8 BITS, 2   STOP BITS
	.WORD	010001		; 4 =   134.5 BAUD, 7 BITS, 1   STOP BIT
	.WORD	012003		; 5 =   150   BAUD, 8 BITS, 1   STOP BIT
	.WORD	014003		; 6 =   200   BAUD, 8 BITS, 1   STOP BIT
	.WORD	016003		; 7 =   300   BAUD, 8 BITS, 1   STOP BIT
	.WORD	016002		;10 =   300   BAUD, 7 BITS, 1   STOP BIT
	.WORD	000000		;11 =   400   BAUD, 8 BITS, 1   STOP BIT
	.WORD	020003		;12 =   600   BAUD, 8 BITS, 1   STOP BIT
	.WORD	022003		;13 =  1200   BAUD, 8 BITS, 1   STOP BIT
	.WORD	024003		;14 =  1800   BAUD, 8 BITS, 1   STOP BIT
	.WORD	000000		;15 =0   BAUD, 8 BITS, 1   STOP BIT
	.WORD	024003		;16 =  2400   BAUD, 8 BITS, 1   STOP BIT
	.WORD	000000		;17 =  3600   BAUD, 8 BITS, 1   STOP BIT
	.WORD   030003		;20 =  4800   BAUD, 8 BITS, 1   STOP BIT
	.WORD	000000		;21 =  7200   BAUD, 8 BITS, 1   STOP BIT
	.WORD	032003		;22 =  9600   BAUD, 8 BITS, 1   STOP BIT
	.WORD	000000		;23 = 19200   BAUD, 8 BITS, 1   STOP BIT

	.END
'@$s