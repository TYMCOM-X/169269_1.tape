	.TITLE	COMMON CONFIGURATION DEPENDENT DATA
	.SBTTL	COMMON - NEXILIS/JRG

	VERNO==!251		; V251.2	21-jan-82
	EDTNO==!3

	XLPAR			;DON'T LIST PARAMETER FILE
	.ENABL	SCM		;SUPPRESS COMMENTS IN MACROS SO WILL ASSEMBLE
				;  IN A REASONABLE AMOUNT OF MEMORY!

	.SBTTL	PASS1 - DETERMINE WHICH DEVICES EXIST ON THIS NODE


;.IF     EQ  .PASS2                      ;JUST DURING PASS 1!
	.MACRO	DEFINE  SYM,VAL
	.ENDM

	.MACRO	NAME  XXX
	.ENDM

	.MACRO	FATAL		;INVOKE THIS TO MAKE ALL NODE CRASHES FATAL
..FTL=!1			;  FOR DEBUGGING
	.ENDM
..FTL=!0

	.MACRO	TYMSAT
..SAT=!1
	.ENDM
..SAT=!0


LK.NUM=!0
TR.NUM=!0



	.MACRO	LINK  NAME,PRIV,AUX,SOC,PS,TYPE,XXX
 LK.NUM=!LK.NUM+1
.IF EQ .PASS2
.IF NDF LK'TYPE'NUM
  LK'TYPE'NUM=!1
.IFF
  LK'TYPE'NUM=!LK'TYPE'NUM+1
.ENDC
.IF IDN <TYPE><H>		;If this is a type H link
	LINKHX	XXX
.ENDC
.ENDC
	.ENDM

	.MACRO	LINKHX  X1,X2,X3
.IF IDN <X3><TPC>
  LHTPC=!1
.ENDC
	.ENDM

	.MACRO	LNKL  CHN,NBR,SPEED,SAT,TYPE,XXX
.IF EQ .PASS2
.IF NDF LH'TYPE'LNS
  LH'TYPE'LNS=!1
.IFF
  LH'TYPE'LNS=!LH'TYPE'LNS+1
.ENDC
.ENDC
	.ENDM

	.MACRO	LNKH  TYMHST,NEXHST,HOSPRT
LHBASE=!1
	.ENDM

	.MACRO	DEV  DV,D1,D2
DV'.NUM=!1
	.MACRO	SOC  SCN,TYPE,XXX
.IF EQ .PASS2
.IF NDF DV''TYPE'NUM
  DV''TYPE'NUM=!1
.IFF
  DV''TYPE'NUM=!DV''TYPE'NUM+1
.ENDC
.ENDC
	.ENDM
	.ENDM

	.MACRO	HCL  A,LIST
	.ENDM

	.MACRO	DHOST  HOST
	.ENDM

	.MACRO	LINX  TYPE,XXX
TR.NUM=!TR.NUM+1
.IF EQ .PASS2
.IF NDF TR'TYPE'NUM
  TR'TYPE'NUM=!1
.IFF
  TR'TYPE'NUM=!TR'TYPE'NUM+1
.ENDC
.ENDC
	.ENDM

	.MACRO	LINE  LN,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
L..LN=LN
	.ENDM

	.MACRO	PVCXX	LNN,PVCSTR,P1,P2
	.PSECT	PURE,RW,D,LCL,REL,CON
PVC'LNN: .BYTE	P1
	.ASCIZ	PVCSTR
	.ENDM

        .MACRO  PVC     PVCSTR,P1,P2
	PVCXX	\<L..LN>,<PVCSTR>,P1,P2
        .ENDM

	.MACRO	MOD	STRING
	.ENDM

	.PSECT	LOWMEM,RW,D,LCL,REL,CON

	.SBTTL	PASS1 - INVOKE THE CONFIGURATION MACRO TO COUNT DEVICES

	CONFIG

;.ENDC			;.IF EQ .PASS2

        .MACRO  PVC     PVCSTR,P1,P2
        .ENDM
	.PAGE
	.SBTTL	DEFINE ORDER OF LOADING PSECT'S

;MUST DO THIS HERE SINCE SOME OF THE CONFIGURATION MACROS PLACE CODE IN VARIOUS
;  PSECTS WHEN THEY ARE INVOKED BY THE CONFIGURATION FILE.  THIS MUST COME
;  FIRST


;THE FOLLOWING PSECT'S ARE PURE AND CONTAIN DATA

	.PSECT	SX    ,RW,D,LCL,REL,CON
SXTBL::
	.PSECT	PURE  ,RW,D,LCL,REL,CON

;THE FOLLOWING PSECT'S ARE PURE AND CONTAIN INSTRUCTIONS

	.PSECT	CODE  ,RW,I,LCL,REL,CON
PURBGN::
	.PSECT	MAIN  ,RW,I,LCL,REL,CON
	.PSECT	SECOND,RW,I,LCL,REL,CON
SECOND::
	.PSECT	TENTHS,RW,I,LCL,REL,CON
TENTHS::
	.PSECT	INIT  ,RW,I,LCL,REL,CON
INISUB::

;THE FOLLOWING PSECT'S ARE IMPURE AND CONTAIN THE DEBUGGER AND ITS SYMBOL
;  TABLE (IF LOADED)

	.PSECT	.XDT. ,RW,I,GBL,REL,OVR
	.PSECT	.SYM. ,RW,D,GBL,REL,OVR

;THE FOLLOWING PSECT'S ARE IMPURE AND CONTAIN DATA

;*****	THE PDATA PSECT ADDED BY DRE 11/20/80 FOR CRASH SAVE SUPPORT
;	PDATA CONTAINS DATA WHICH IS SAVED ACROSS NODE CRASHES
	.PSECT	PDATA ,RW,D,LCL,REL,CON
	.PSECT	DDB   ,RW,D,LCL,REL,CON
DDBBGN::
	.PSECT	LDB   ,RW,D,LCL,REL,CON
LDBBGN::
	.PSECT	ADB   ,RW,D,LCL,REL,CON
	.PSECT	SDB   ,RW,D,LCL,REL,CON
SDBBGN::
	.PSECT	IMPURE,RW,D,LCL,REL,CON
IMPBGN::
CKSVAL::.WORD	0			;MEMORY CHECKSUM VALUE
CKSFLG::.WORD	0			;MEMORY CHECKSUM FLAG (0 MEANS TO
					;  RE-STORE CHECKSUM VALUE)
IMPCLR::

;THE FOLLOWING PSECT'S ARE IMPURE AND CONTAIN ONCE-ONLY INSTRUCTIONS AND DATA
;  (WHEN THE NODE IS RUNNING, PACKET SPACE STARTS HERE)

	.PSECT	ONCE  ,RW,I,LCL,REL,CON
PKTBGN::
	.PSECT	VECTBL,RW,D,LCL,REL,CON
VECTBL::!

;SWITCH TO THE BLANK PSECT SO ITS EASIER TO CATCH ERRORS!!!

	.PSECT

;DEFINE DUMMY MACRO WHICH IS INVOKED BY SEVERAL OTHER MACROS

	.MACRO	RESTOR
	.ENDM
	.PAGE
	.SBTTL	DEFINE MACROS FOR THE CONFIGURATION DEFINITION FILE

;DEFINE MACRO USED TO DEFINE SYMBOLS

	.MACRO	DEFINE  SYM,VAL
SYM==!VAL
	.ENDM

;DEFINE MACRO TO SPECIFY NAME OF THIS NODE

	.MACRO	NAME  XXX
	.PSECT	PURE,RW,D,LCL,REL,CON
	.NCHR	.N,<XXX>
THSNOD::.ASCIZ	"XXX"
.IF GT 5-.N
	.REPT	5-.N
	.BYTE	0
	.ENDR
.ENDC
	.EVEN
	.ENDM

;DEFINE MESSAGE OF THE DAY MACRO

	.MACRO	MOD	STRING
	.PSECT	PURE,RW,D,LCL,REL,CON
..MOD::	.ASCIZ	STRING
	.ENDM
	.PAGE
;DEFINE MACROS FOR LINKS TO OTHER NODES OR HOSTS

.IF NE LK.NUM
	.MACRO	LINK  NAME,PRIV,AUX,SOC,PS,TYPE,XXX
	.IRP	DEV,<\.LK>
LK.S'DEV=!SOC
$$$PL=!PRIV
$$$S=!0
.IF IDN <PS><P>
  $$$S=!$$$S!$D0PRI
.ENDC
.IF IDN <AUX><F>
  $$$S=!$$$S!$D0FAX
.ENDC
.IF IDN <AUX><T>
  $$$S=!$$$S!$D0TAX
.ENDC
.IF IDN <AUX><TF>
  $$$S=!$$$S!$D0FAX!$D0TAX
.ENDC
$$$T=!''TYPE
	.WR50	1,NAME,$$$1	;FIRST HALF OF NODE NAME
	.WR50	4,NAME,$$$2	;SECOND HALF OF NODE NAME
$$$=!0
$$$N0=!0
$$$N1=!0
$$$N2=!0
$$$N3=!0
$$$N4=!0
$$$N5=!0
	.IRPC	QQ,<NAME>
	.IRP	XX,<\$$$>
$$$N'XX=''QQ
	.ENDM
$$$=!$$$+1
	.ENDM
.IF EQ DEV
	.PSECT	SX,RW,D,LCL,REL,CON
  MNLKSX::!
.ENDC
	LINK'TYPE  DEV,SOC,XXX
	.ENDM
.LK=!.LK+1
	.ENDM
.LK=0
HSNUM=!0
	.PAGE
	.SBTTL	LINKA - DR11-C/DR11 USING FLAG PROTOCOL

;DEFINE MACRO FOR TYPE A LINK DRIVERS (16 BIT PARALLEL LINK USING DR-11C OR
;  DRV-11 USING FLAG PROTOCOL)

.IF DF LKANUM
	.MACRO	LINKA	DEV,SOC,DRG,VEC,LEV
$$$R=DRG			;ADDRESS OF FIRST DEVICE REGISTER
$$$P=!LEV			;PRIORITY LEVEL
$$$S=!$$$S!$D0FLG!$D0SII!$D0LNK!$D0CLN!$D0LVL!$D0WLD
				;THIS LINK USES FLAG PROTOCOL WITH SOCKET IS
				;  IDLE MESSAGES AND REQUIRES CLEANUP BY
				;  SNDPKT
LOADDV=!1			;THIS LINK USES THE LOAD DEVICE

	VECTOR	VEC  ,LKI'DEV,LEV;INPUT VECTOR
	VECTOR	VEC+4,LKO'DEV,LEV;OUTPUT VECTOR

	.PSECT	CODE,RW,I,LCL,REL,CON;GENERATE INTERRUPT CODE

LKI'DEV:PUSH	R4		;SAVE REGISTER
	MOV	#L'DEV'$,R4	;GET ADDRESS OF DDB
	JMP	LKAIIN#		;GO TO COMMON ROUTINE

LKO'DEV:PUSH	R4		;SAVE REGISTER
	MOV	#L'DEV'$,R4	;GET ADDRESS OF DDB
	JMP	LKAOIN#		;GO TO COMMON ROUTINE

	XDDB	LK,L,DEV,SOC,A,FGPOKE#,FGRSUM#,0,<NXTFLG#,FLGPKT#>

.S=!1
	.REPT	SOC		;GENERATE THE SDB'S
	XSDB	LK,L,DEV,\.S,A
.S=!.S+1
	.ENDR
.LKA=!.LKA+1
	.ENDM
.LKA=!0
.ENDC
	.PAGE
	.SBTTL	LINKB - DUP11/DUV11 USING DDCMP PROTOCOL

;DEFINE MACRO FOR TYPE B LINK (8 BIT SERIAL LINK USING DDCMP PROTOCOL.DUV-11)

.IF DF LKBNUM
	.MACRO	LINKB  DEV,SOC,DRG,VEC,LEV,LIN
$$$R=DRG			;ADDRESS OF FIRST DEVICE REGISTER
$$$P=!LEV			;Processor level at interrupt level
$$$S=!$$$S!$D0FLG!$D0SII!$D0LNK!$D0CLN!$D0LVL!$D0WLD
				;THIS LINK USES FLAG PROTOCOL WITH SOCKET IS
				;  IDLE MESSAGES AND REQUIRES CLEANUP BY
				;  SNDPKT
.IF B <LIN>
  $$$L=!-1			;If no line no. defined we are line -1
.IFF
  $$$L=!LIN			;The line number on the interface when
  $$$VC=!VEC				;The device vector to set up
.ENDC				; using multiline synchronous devices
LOADDV=!1			;This link uses the load device

	VECTOR	VEC  ,LKI'DEV,LEV;Input vector
.IF B <LIN>			;If not using a DCP we need output vec
	VECTOR	VEC+4,LKO'DEV,LEV;Output vector
.ENDC				;.IF B <LIN>

	.PSECT	CODE,RW,I,LCL,REL,CON

LKI'DEV:PUSH	R4		;Save the users register
	MOV	#L'DEV'$,R4	;Get the DDB address in R4
	JMP	LKBISV#		;Go to the common link type B input service

LKO'DEV:PUSH	R4		;Save the users register
	MOV	#L'DEV'$,R4	;Get the DDB address in R4

	JMP	LKBOSV#		;Go to the common link type B output service


	XDDB	LK,L,DEV,SOC,B,FGPOKE#,FGRSUM#,0,<NXTFLG#,FLGPKT#>

.S=!1
	.REPT	SOC		;GENERATE THE SDB'S
	XSDB	LK,L,DEV,\.S,B
.S=!.S+1
	.ENDR
.LKB=!.LKB+1
	.ENDM
.LKB=!0
.ENDC
	.PAGE
	.SBTTL	LINKC - DR11-C/DRV11 USING RESPONSE PROTOCOL

;DEFINE MACRO FOR TYPE C LINK DRIVERS (16 BIT PARALLEL LINK USING DR-11C OR
;  DRV-11 USING REQUEST PROTOCOL)

.IF DF LKCNUM
	.MACRO	LINKC	DEV,SOC,DRG,VEC,LEV
$$$R=DRG			;ADDRESS OF FIRST DEVICE REGISTER
$$$P=!LEV			;PRIORITY LEVEL
$$$S=!$$$S!$D0SII!$D0LNK!$D0CLN!$D0LVL!$D0WLD;This link uses socket is idle
					     ;  packets and requires cleanup by
					     ;  SNDPKT
LOADDV=!1			;THIS LINK USES THE LOAD DEVICE

	VECTOR	VEC  ,LKI'DEV,LEV;INPUT VECTOR
	VECTOR	VEC+4,LKO'DEV,LEV;OUTPUT VECTOR

	.PSECT	CODE,RW,I,LCL,REL,CON;GENERATE INTERRUPT CODE

LKI'DEV:PUSH	R4		;SAVE REGISTER
	MOV	#L'DEV'$,R4	;GET ADDRESS OF DDB
	JMP	LKCIIN#		;GO TO COMMON ROUTINE

LKO'DEV:PUSH	R4		;SAVE REGISTER
	MOV	#L'DEV'$,R4	;GET ADDRESS OF DDB
	JMP	LKCOIN#		;GO TO COMMON ROUTINE

	XDDB	LK,L,DEV,SOC,C,RSPOKE#,RSRSUM#,0,<NXTRSP#,RSPPKT#>

.S=!1
	.REPT	SOC			;GENERATE THE SDB'S
	XSDB	LK,L,DEV,\.S,C
.S=!.S+1
	.ENDR
.LKC=!.LKC+1
	.ENDM
.LKC=!0
.ENDC
	.PAGE
	.SBTTL	LINKD - HOST INTERFACE TO RT-11 AND RSTS-11 USING DR11-C/DRV11

;DEFINE MACRO FOR TYPE D LINK DRIVERS (RT-11 OR RSTS-11 HOST INTERFACE USING
;  DR11-C OR DRV11 INTERFACE)

.IF DF LKDNUM
	.MACRO	LINKD	DEV,SOC,DRG,VEC,LEV
$$$R=!DRG			;ADDRESS OF FIRST DEVICE REGISTER
$$$P=!LEV			;PRIORITY LEVEL
$$$S=!$$$S!$D0SII!$D0HST!$D0CLN!$D0LVL!$D0WLD;This link uses socket is idle
					     ;  packets and wants SNDPKT to do
					     ;  cleanup on Disconnects and NAKS

	VECTOR	VEC  ,LKI'DEV,LEV;INPUT VECTOR
	VECTOR	VEC+4,LKO'DEV,LEV;OUTPUT VECTOR

	.PSECT	CODE,RW,I,LCL,REL,CON;GENERATE INTERRUPT CODE

LKI'DEV:PUSH	R4		;SAVE REGISTER
	MOV	#L'DEV'$,R4	;GET ADDRESS OF DDB
	JMP	LKDIIN#		;GO TO COMMONINE

LKO'DEV:PUSH	R4		;SAVE REGISTER
	MOV	#L'DEV'$,R4	;GET ADDRESS OF DDB
	JMP	LKDOIN#		;GO TO COMMON ROUTINE

	XDDB	LK,L,DEV,SOC,D,RSPOKE#,LDRSUM#,XXSSRC#,<LDOUTX#,MOVPKE#>

.S=!1
	.REPT	SOC			;GENERATE THE SDB'S
	XSDB	LK,L,DEV,\.S,D
.S=!.S+1
	.ENDR
.LKD=!.LKD+1
	.ENDM
.LKD=!0
.ENDC
	.PAGE
	.SBTTL	LINKE - DUP11/DUV11 Using X.25 (SNAP) protocol

;Define MACRO for type E link drivers (8 bit parallel link using DUP-11 or
;  DUV-11 using modified flag protocol)

.IF DF LKENUM
	.MACRO	LINKE	DEV,SOC,DRG,VEC,LEV,DEST,ADEST,K,T1,N1,N2
$$$R=!DRG			;Address of first device register
$$$P=!LEV			;PRIORITY LEVEL
$$$S=!$$$S!$D0GTW!$D0FLG!$D0WLD!$D0CLN
.IF EQ $$$S&$D0PRI
  $$$A=!1			; DTE outgoing command frame address
  $$$B=!3			; DTE incoming response frame address
.IFF
  $$$A=!3			; DCE outgoing command frame address
  $$$B=!1			; DCE incoming response frame address
.ENDC
$$$C=!K;			; Frame level window size (K)
$$$D=!T1			; No-response timer duration (T1)
$$$E=!N2			; Retransmission max (N2)
$$$F=!N1			; Max # bytes in frame info fld (N1/8)
	.WR50	1,DEST,$$$3	; 1st half of X.25 dest DTE name
	.WR50	4,DEST,$$$4	; 2nd half of X.25 dest DTE name
	.WR50	1,ADEST,$$$5
	.WR50	4,ADEST,$$$6

	VECTOR	VEC  ,LKI'DEV,LEV;Input vector
	VECTOR	VEC+4,LKO'DEV,LEV;Output vector

	.PSECT	CODE,RW,I,LCL,REL,CON;Generate interrupt code

LKI'DEV:PUSH	R4		;Save register
	MOV	#L'DEV'$,R4	;Get address of DDB
	JMP	LKEISV#		;Go to common routine

LKO'DEV:PUSH	R4		;Save register
	MOV	#L'DEV'$,R4	;Get address of DDB
	JMP	LKEOSV#		;Go to common routine

	XDDB	LK,L,DEV,SOC,E,LEPOKE#,LERSUM#,XXSSRC#,<LKEFLG#,0>

.S=!1
	.REPT	SOC			;GENERATE THE SDB'S
	XSDB	LK,L,DEV,\.S,E
.S=!.S+1
	.ENDR
.LKE=!.LKE+1
	.ENDM
.LKE=!0
.ENDC
	.PAGE
	.SBTTL	LINKF - HOST INTERFACE TO TYMSHARE 2020 USING DR11-C

;DEFINE MACRO FOR TYPE F LINK DRIVERS (TYMSHARE 2020 HOST INTERFACE USING
;  DR11-C OR DRV11 INTERFACE)

.IF DF LKFNUM
	.MACRO	LINKF	DEV,SOC,DRG,VEC,LEV,RNGSIZ,XKMC
$$$R=!DRG			;ADDRESS OF FIRST DEVICE REGISTER
$$$P=!LEV			;PRIORITY LEVEL
$$$S=!$$$S!$D0HST!$D0WLD
$$$W=!RNGSIZ			;SIZE OF HOST'S INPUT RING BUFFER

.IF NB <XKMC>
  .IF DIF <XKMC><KMC>
	.ERROR	0;LINKF KMC PARAMETER NOT BLANK OR KMC!
  .IFF
    $$$S=!$$$S!$D0DV0
  .ENDC
.ENDC

	VECTOR	VEC  ,LKI'DEV,LEV;INPUT VECTOR
	VECTOR	VEC+4,LKO'DEV,LEV;OUTPUT VECTOR

	.PSECT	CODE,RW,I,LCL,REL,CON;GENERATE INTERRUPT CODE

LKI'DEV:PUSH	R4		;SAVE REGISTER
	MOV	#L'DEV'$,R4	;GET ADDRESS OF DDB
.IF DIF <XKMC><KMC>
	JMP	LKFIN1#		;GO TO COMMON ROUTINE
.IFF
	JMP	LKFIN2#
.ENDC

LKO'DEV:PUSH	R4		;SAVE REGISTER
	MOV	#L'DEV'$,R4	;GET ADDRESS OF DDB
.IF DIF <XKMC><KMC>
	JMP	LKFOU1#		;GO TO COMMON ROUTINE
.IFF
	JMP	LKFOU2#
.ENDC

	XDDB	LK,L,DEV,SOC,F,RSPOKE#,LFRSUM#,XXSSRC#,<LFOUTX#,0>

.S=!1
	.REPT	SOC			;GENERATE THE SDB'S
	XSDB	LK,L,DEV,\.S,F
.S=!.S+1
	.ENDR
.LKF=!.LKF+1
	.ENDM
.LKF=!0
.ENDC
	.PAGE
	.SBTTL	LINKG - DUP11/DUV11 Using TYMnet extended X.25 protocol

;Define MACRO for type G link drivers (8 bit serial link using DUP-11 or
;  DUV-11 using modified flag protocol)

.IF DF LKGNUM
	.MACRO	LINKG	DEV,SOC,DRG,VEC,LEV,DEST,ADEST,K,T1,N1,N2
$$$R=!DRG			;Address of first device register
$$$P=!LEV			;PRIORITY LEVEL
$$$S=!$$$S!$D0GTW!$D0FLG!$D0WLD
.IF EQ $$$S&$D0PRI
  $$$A=!1			; DTE outgoing command frame address
  $$$B=!3			; DTE incoming response frame address
.IFF
  $$$A=!3			; DCE outgoing command frame address
  $$$B=!1			; DCE incoming response frame address
.ENDC
$$$C=!K;			; FRAME LEVEL WINDOW SIZE (K)
$$$D=!T1			; NO-RESPONSE TIMER DURATION (T1)
$$$E=!N2			; RETRANSMISSION MAX (N2)
$$$F=!N1			; MAX # BYTES IN FRAME INFO FLD (N1/8)
	.WR50	1,DEST,$$$3	; 1ST HALF OF X.25 DEST DTE NAME
	.WR50	4,DEST,$$$4	; 2ND HALF OF X.25 DEST DTE NAME
	.WR50	1,ADEST,$$$5
	.WR50	4,ADEST,$$$6

	VECTOR	VEC  ,LKI'DEV,LEV;Input vector
	VECTOR	VEC+4,LKO'DEV,LEV;Output vector

	.PSECT	CODE,RW,I,LCL,REL,CON;Generate interrupt code

LKI'DEV:PUSH	R4		;Save register
	MOV	#L'DEV'$,R4	;Get address of DDB
	JMP	LKGISV#		;Go to common routine

LKO'DEV:PUSH	R4		;Save register
	MOV	#L'DEV'$,R4	;Get address of DDB
	JMP	LKGOSV#		;Go to common routine

	XDDB	LK,L,DEV,SOC,G,LGPOKE#,LGRSUM#,XXSSRC#,<LKGFLG#,0>

.S=!1
	.REPT	SOC			;GENERATE THE SDB'S
	XSDB	LK,L,DEV,\.S,G
.S=!.S+1
	.ENDR
.LKG=!.LKG+1
	.ENDM
.LKG=!0
.ENDC
	.PAGE
	.SBTTL	LINKH - GATEWAY TO TYMNET T.201 PROTOCOL

;DEFINE MACRO FOR TYPE H LINK DRIVERS (GATEWAY TO TYMNET T.201 PROTOCOL)

.IF DF LKHNUM
	.MACRO	LINKH	DEV,SOC,NODNUM,NSPH,XTPCX
$L0DIR=!100000;			;DEFINE STATUS BITS
$L0SAT=!000200
$$$S=!$$$S!$D0GTW!$D0WLD
$$$NN=!NODNUM;			;NODE NUMBER
$$$ND=!100			;NODE DESCRIPTOR
.IF LT $$$NN-1000		;IF WE ARE A BASE
  $$$ND=!140			;WE LOOK LIKE AN ISIS NODE!
.ENDC
$$$NL=!L.NL'DEV			;NUMBER OF LINES
L.NL'DEV=!0

;DEFINE MACRO USED TO DEFINE A TYMNET "LINE"

	.MACRO	LNKL  CHN,NBR,SPEED,SAT,TYPE,XXX
L.NL'DEV=!L.NL'DEV+1		;COUNT THIS LINE
	.IRP	LINE,<\.L>
$$$Q=!SPEED;			;LINE SPEED
$$$C=!<CHN+17>&^C17;		;NUMBER OF CHANNELS ON THE LINE (MUST BE
				;  MULTIPLE OF 16.)
$$$N=!NBR;			;NUMBER OF NEIGHBOR NODE
$$$S=!0;			;VALUE FOR PURE STATUS WORD
$$$X=!4;			;NORMAL LINE HAS 4 OUTSTANDING FRAMES
.IF IDN <S><SAT>;		;IF THIS IS A SATELLITE LINK
  $$$S=!$L0SAT;		;  SET CORRESPONDING PURE STATUS BIT
  $$$X=!10;			;  SATELLITE LINE HAS 8 OUTSTANDING FRAMES
.ENDC
.IF LT NODNUM-NBR;		;ALSO SET THE DIRECTION BIT CORRECTLY
  $$$S=!$$$S!$L0DIR
.ENDC
	.IRP	LX,<\<.L+1>>
.IF DF	L'DEV'.'LX
  L'DEV'H'LINE=!L'DEV'.'LX
.IFF
  L'DEV'H'LINE=!0
.ENDC
	.ENDM
	.ENDM
.LKH'TYPE=!.L
	LNKL'TYPE  DEV,\.L,CHN,XXX
.L=!.L+1;			;BUMP LINE NUMBER ON GATEWAY
	.ENDM

;END OF DEFINITION OF LNKL MACRO

.L=!0;				;INITIALIZE LINE NUMBER ON GATEWAY

;DEFINE MACRO USED TO DEFINE A TYMNET "HOST" ON THIS BASE

	.MACRO	LNKH	TYMHST,NXLHST,HOSPRT ;MACRO FOR "HOST" ON THE GATEWAY
L.NH'DEV=!L.NH'DEV+1;		;COUNT THE HOST
.IF EQ .H			;IF THIS IS FIRST HOST ON GATEWAY
	.PSECT	IMPURE,RW,D,LCL,REL,CON;GENERATE HOST BUFFER TABLE
  HBFT'DEV:.BLKW  200
.ENDC
	.PSECT	PURE,RW,D,LCL,REL,CON
.IF NDF L.HM'DEV
  L.HM'DEV:
.ENDC
	.WORD	$$$SH*100+100002
	.WORD	.H*10000+^D'TYMHST
	.IRP	HOST,<\.H>
LD'DEV'.'HOST=!100000!^D'TYMHST'.;FIRST WORD OF HOST DESCRIPTOR
LD'DEV'.'HOST'P=!$$$PH
.IF NB	<HOSPRT>
 .IF GT	$$$PH-HOSPRT
   LD'DEV'.P'HOST=!HOSPRT
 .ENDC
.ENDC 
	.WR50	1,NXLHST,L.'HOST'A'DEV;DEFINE SYMBOLS FOR NEXILIS HOST NAME
	.WR50	4,NXLHST,L.'HOST'B'DEV
	.ENDM
.H=!.H+1;			;BUMP HOST NUMBER ON GATEWAY
	.ENDM

;END OF DEFINITION OF LNKH MACRO

$$$NH=!0			;ASSUME NO HOSTS

.IF DF LHBASE			;ONLY NEED THIS IF HAVE BASE SUPPORT ON THIS
				;  NODE

$$$NH=!L.NH'DEV
L.NH'DEV=!0
.H=!0
.IF GE $$$NH-3
  $$$SH=!100
  $$$SO=!4
.IFF
  $$$SO=!10
  .IF GE $$$NH-2
    $$$SH=!200
  .IFF
    $$$SH=!400
  .ENDC
.ENDC

$$$PH=!NSPH			;NUMBER OF AVAILABLE PORTS PER HOST
.IF GT $$$PH-$$$SH		;MUST BE LESS THAN TOTAL NUMBER
  $$$PH=!$$$SH
.ENDC
.IF GT $$$PH-SOC+$$$NH
  $$$PH=!SOC-$$$NH
.ENDC

.IF EQ $$$NH			;IF NO HOSTS ON THIS GATEWAY
  $$$0A=!0
  $$$0B=!0
  $$$1A=!0
  $$$1B=!0
  $$$2A=!0
  $$$2B=!0
  $$$3A=!0
  $$$3B=!0
  $$$S0=!-1
  $$$S1=!-1
  $$$S2=!-1
  $$$S3=!-1
.ENDC
.IF EQ $$$NH-1			;IF 1 HOST
  $$$0A=!L.0A'DEV
  $$$0B=!L.0B'DEV
  $$$1A=!L.0A'DEV
  $$$1B=!L.0B'DEV
  $$$2A=!L.0A'DEV
  $$$2B=!L.0B'DEV
  $$$3A=!L.0A'DEV
  $$$3B=!L.0B'DEV
  $$$S0=!$$$SH-2
  $$$S1=!-1
  $$$S2=!-1
  $$$S3=!-1
.ENDC
.IF EQ $$$NH-2			;IF 2 HOSTS
  $$$0A=!L.0A'DEV
  $$$0B=!L.0B'DEV
  $$$1A=!L.0A'DEV
  $$$1B=!L.0B'DEV
  $$$2A=!L.1A'DEV
  $$$2B=!L.1B'DEV
  $$$3A=!L.1A'DEV
  $$$3B=!L.1B'DEV
  $$$S0=!$$$SH-2
  $$$S1=!-1
  $$$S2=!$$$S0+200
  $$$S3=!-1
.ENDC
.IF GE $$$NH-3			;3 OR 4 HOSTS
  $$$0A=!L.0A'DEV
  $$$0B=!L.0B'DEV
  $$$1A=!L.1A'DEV
  $$$1B=!L.1B'DEV
  $$$2A=!L.2A'DEV
  $$$2B=!L.2B'DEV
  $$$S0=!$$$SH-2
  $$$S1=!$$$S0+100
  $$$S2=!$$$S0+200
  .IF DF L.3A'DEV
    $$$3A=!L.3A'DEV
    $$$3B=!L.3B'DEV
    $$$S3=!$$$S0+300
  .IFF
    $$$3A=!0
    $$$3B=!0
    $$$S3=!-1
  .ENDC
.ENDC
.ENDC		;.IF DF LHBASE

	XDDB	LK,L,DEV,SOC,H,LHPOKE#,LHRSUM#,XXSSRC#,<0,0>

.S=!1
	.REPT	SOC		;GENERATE THE SDB'S
	XSDB	LK,L,DEV,\.S,H
.S=!.S+1
	.ENDR
.LKH=!.LKH+1
	.ENDM
.LKH=!0

.ENDC		;.IF DF LKHNUM
	.PAGE
;DEFINE MACRO FOR TYPE A LINE ON TYPE H LINK

.IF DF LKHNUM
.IF DF LHALNS
	.MACRO	LNKLA  DEV,LINE,CHN,DRG,VEC,LEV
$$$R=DRG;			;ADDRESS OF FIRST DEVICE REGISTER
$$$P=!LEV;			;PRIORITY LEVEL

	VECTOR	VEC  ,LI'DEV'.'LINE,LEV;INPUT VECTOR
	VECTOR	VEC+4,LO'DEV'.'LINE,LEV;OUTPUT VECTOR

	.PSECT	CODE,RW,I,LCL,REL,CON;;GENERATE INTERRUPT CODE

LI'DEV'.'LINE:PUSH  R3;		;SAVE REGISTER
	MOV	#L'DEV'.'LINE,R3;GET ADDRESS OF LDB
	JMP	LHAISV#;	;GO TO COMMON ROUTINE

LO'DEV'.'LINE:PUSH  R3;		;SAVE REGISTER
	MOV	#L'DEV'.'LINE,R3;GET ADDRESS OF LDB
	JMP	LHAOSV#;	;GO TO COMMON ROUTINE

	.PSECT	IMPURE,RW,D,LCL,REL,CON;GENERATE THE SDB TABLES FOR EACH LINE

LS'DEV'.'LINE:.BLKW  CHN;	;ONE ENTRY FOR EACH CHANNEL ON THE LINE

	XLDB	DEV,LINE,A

	.ENDM
.ENDC		;.IF DF LHALNS

;DEFINE MACRO FOR TYPE B LINE ON TYPE H LINK

.IF DF LHBLNS
	.MACRO	LNKLB  DEV,LINE,CHN,DRG,VEC,LEV,PORT
$$$R=DRG;			;ADDRESS OF FIRST DEVICE REGISTER
$$$P=!LEV;			;PRIORITY LEVEL
$$$PN=!PORT			; Port number on DCP
$$$VC=!VEC			; Interrupt vector for DCP port

	VECTOR	VEC  ,LI'DEV'.'LINE,LEV	;Interrupt vector

	.PSECT	CODE,RW,I,LCL,REL,CON;;GENERATE INTERRUPT CODE

LI'DEV'.'LINE:PUSH  R3;		;SAVE REGISTER
	MOV	#L'DEV'.'LINE,R3;GET ADDRESS OF LDB
	JMP	LHBINT#;	;GO TO COMMON ROUTINE

	.PSECT	IMPURE,RW,D,LCL,REL,CON;GENERATE THE SDB TABLES FOR EACH LINE

LS'DEV'.'LINE:.BLKW  CHN;	;ONE ENTRY FOR EACH CHANNEL ON THE LINE

	XLDB	DEV,LINE,B

	.ENDM
.ENDC		;.IF DF LHBLNS
.ENDC		;.IF DF LKHNUM
.ENDC		;.IF NE LK.NUM
	.PAGE
	.SBTTL	MACROS FOR PARAMETERS FOR DEVICES

	.MACRO	DEV  DV,PRIV,XXX
$$$N=DV'.S0			;NUMBER OF SOCKETS ON DEVICE
DV'.S0==!0
$$$S=!0				;Initialize symbol for pure status word
$$$PL=!PRIV			;Privildge level
	DV'XX	XXX		;Define the "SOC" macro for this device and
				;  create the DDB
	.ENDM
	.PAGE
;DEFINE MACROS FOR DEFINING PARAMETERS FOR THE STATUS DEVICE

.IF DF ST.NUM
	.MACRO	STXX,EPL,DPL
	.MACRO	SOC  SN
.IF NE ST.S0+1-SN
	.ERROR	SN;SOC MACRO OUT OF ORDER FOR DEVICE ST
.ENDC
ST.S0==!ST.S0+1
	XSDB	ST,S,0,\SN
	.ENDM
$$$S=!$$$S!$D0WLD
$$$EPL=!EPL			;Priviledge level for examine and status
				;  changing commands
$$$DPL=!DPL			;Priviledge level for deposit command
	XDDB	ST,S,0,\$$$N,,STPOKE#,STRSUM#,XXSSRC#
	.ENDM
.ENDC

;DEFINE MACROS FOR THE LOAD DEVICE

.IF DF WD.NUM
	.MACRO	WDXX
	.MACRO	SOC  SN
.IF NE WD.S0+1-SN
	.ERROR	SN;SOC MACRO OUT OF ORDER FOR DEVICE WD
.ENDC
WD.S0==!WD.S0+1
	XSDB	WD,W,0,\SN
	.ENDM
	XDDB	WD,W,0,\$$$N,,WDPOKE#,WDRSUM#,XXSSRC#
	.ENDM
.ENDC
	.PAGE
;DEFINE MACROS FOR DEFINING PARAMETERS FOR EACH TYPE OF HARDWARE DEVICE DRIVER

;LINE PRINTER

.IF DF LP.NUM
	.MACRO	LPXX
	.MACRO	SOC  SN,TYPE,XXX
.IF NE LP.S0+1-SN
	.ERROR	SN;SOC MACRO OUT OF ORDER FOR DEVICE LP
.ENDC
LP.S0==!LP.S0+1
	SOCLP'TYPE  \SN,XXX
	.ENDM
	XDDB	LP,P,0,\$$$N,,LPPOKE#,LPRSUM#,XXSSRC#
	.ENDM

;LINE PRINTER TYPE A (USES EITHER LP-11A PARALLEL INTERFACE OR MODIFIED DL-11
;  SERIAL INTERFACE)

.IF DF LPANUM
	.MACRO	SOCLPA  SN,REG,VEC,EREG
$$$R=!REG
.IF B <EREG>
  $$$E=!REG
.IFF
  $$$E=!EREG
.ENDC

	VECTOR	VEC,LP'SN'I,7

	.PSECT	CODE,RW,I,LCL,REL,CON

LP'SN'I:PUSH	SD
	MOV	#P0$'SN,SD
	JMP	LPACMI#

	XSDB	LP,P,0,SN,A

	.ENDM
.ENDC

;LINE PRINTER TYPE B (USES ONE PORT ON DZ-11 OR DZV-11 SERIAL INTERFACE)

.IF DF LPBNUM
	.MACRO	SOCLPB  SN

	.PSECT	CODE,RW,I,LCL,REL,CON

LPB'SN'X:PUSH	SD		;SAVE SD
	MOV	P0$'SN,SD	;POINT TO OUR SDB
	JMP	LPBXTR#		;GO TO COMMON CODE

	.ENDM
.ENDC
.ENDC			;.IF NE LP.NUM
	.PAGE
;DEFINE MACRO FOR GENERATING THE HOST CONNECT LIST DATA

	.MACRO	HCL  X,LIST
	.PSECT	PURE,RW,D,LCL,REL,CON
	.IRP	H,<\.HCL>
HOST.'X=.HCL*2+2
HST$'H:
	.ENDM
	.IRP	NAME,<LIST>
	.ASCIZ	"NAME"
	.ENDM
	.BYTE	0
.HCL=.HCL+1
	.ENDM
.HCL=!0

;DEFINE MACRO FOR DEFINING DEFAULT HOST

	.MACRO	DHOST  HOST
DFTH$$=!1
	.PSECT	PURE,RW,D,LCL,REL,CON
DFTHST::.ASCIZ	"HOST"
	.ENDM
	.PAGE
	.SBTTL	MACROS FOR PARAMETERS FOR ASYNC LINE INTERFACES

.IF NE	TR.NUM
	.MACRO	LINX  TYPE,XXX
	.IRP	UNIT,<\.TT>
$$$M=!L.'UNIT'LN
L.'UNIT'LN=!0
$$$X=!L..LN
	LINX'TYPE  UNIT,XXX
	.ENDM
.TT=!.TT+1
	.ENDM
TR.S0=!L..LN
L..LN=!0
.TT=!0

;DEFINE COMMON MACRO THAT IS USED TO DEFINE LINE PARAMETERS FOR TERMINAL LINES

	.MACRO	LINEX  LNN,UNIT,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
$$$LN=!L.'UNIT'LN
$$$ADB=!ADB'UNIT'$
L.'UNIT'LN=!L.'UNIT'LN+1
L..LN=!L..LN+1
.IF NE LNN-L..LN
	.ERROR	LNN;LINE MACRO FOR LINE LNN OUT OF ORDER
.ENDC
.IF IDN <AF><A>
  $$$B=!ABX.'OBR+1+RATAT0
  ABR$'OBR=!1
  ABR$=!1
.IFF
  .IF NB IBR
    $$$B=!R.'IBR*400!OBR
  .IFF
    $$$B=!R.'OBR*400!R.'OBR
  .ENDC
.ENDC

$$$B=!$$$B+<<.XX'COD*20>&340>;	;INSERT CODE INTO BAUD RATE WORD

X$$'COD=!1			;CAUSE ENTRY FOR XLATE TABLES TO BE MADE

.IF DF C.'CMD
  $$$C=!C.'CMD
.IFF
  .ERROR ;ILLEGAL COMMAND DECODER TYPE CMD FOR TERMINAL LINE LNN
.ENDC
C$'CMD=!1
$$$S=!0
.IF IDN <XX><HW>
  $$$S=!$$$S!$T0HWR		;IF HARDWIRED TERMINAL
.ENDC
.IF IDN <AS><Y>
  $$$S=!$$$S!$T0ASK		;IF SHOULD ASK ABOUT TYPE AND PROFILE
.ENDC

.IF DIF <CM><N>
  $$$S=!$$$S!$T0CMD		;IF SHOULD ALLOW CMD MODE
  .IF DIF <CM><R>
    .IF IDN <CM><Y>
      $$$S=!$$$S!$T0CMX		;If CMD mode should be default
    .IFF
      .ERROR	0;Illegal value for command mode line parameter
    .ENDC
  .ENDC
.ENDC
.IF IDN <ACD><Y>		;If want auto-connect on disconnect
  $$$S=!$$$S!$T0ACD
.ENDC
.IF IDN <ROB><Y>		;IF WANT TO RELEASE ON BREAK
  $$$S=!$$$S!$T0ROB
.ENDC
.IF NB HCL
  $$$S=!$$$S!<HOST.'HCL*400>	;HOST CONNECT LIST INDEX
.ENDC
.IF IDN <SNM><Y>
  $$$S=!$$$S!$T0SFM!$T0SIM	;If should suppress all network messages
.ENDC
.IF IDN <SNM><I>
  $$$S=!$$$S!$T0SIM		;If should suppress informative network messages
.ENDC
$$$CL=!CL			;DEFINE SYMBOL FOR PRIV. CLASS
$$$T=T.'TT			;DEFINE SYMBOL FOR DEFAULT TERMINAL TYPE
$$$P=!P.'TP			;DEFINE SYMBOL FOR DEFAULT TERMINAL PROFILE

	.ENDM
	.PAGE
	.SBTTL	LINXA - SINGLE LINE DRIVER FOR DL11/DLV11

.IF DF TRANUM
;DL11/DLV11 DRIVER (SINGLE LINE)

	.MACRO	LINXA  UNIT,REG,VEC
$$$R=REG			;REGISTER BASE ADDRESS

	VECTOR	VEC  ,A'UNIT'II,7
	VECTOR	VEC+4,A'UNIT'OI,7

	.PSECT	CODE,RW,I,LCL,REL,CON

A'UNIT'II:PUSH	R4		;SAVE REGISTER
	MOV	#ADB'UNIT'$,R4	;GET ADDRESS OF ADB
	JMP	ASAINI#		;GO TO COMMON ROUTINE

A'UNIT'OI:PUSH	R4		;SAVE REGISTER
	MOV	#ADB'UNIT'$,R4	;GET ADDRESS OF ADB
	JMP	ASAOUI#		;GO TO COMMON ROUTINE

	.MACRO	LINE  LN,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	LINEX	LN,UNIT,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	XSDB	TR,T,0,\LN,A
	.ENDM

$$$AS=!0

	XADB	UNIT,A

	.ENDM
.ENDC
	.PAGE
	.SBTTL	LINXB - MULTIPLE LINE DRIVER FOR DZ11/DZV11

.IF DF TRBNUM
;DZ11/DZV11 DRIVER (UP TO 8 LINES/DEVICE)

	.MACRO	LINXB  UNIT,REG,VEC
$$$R=!REG			;REGISTER BASE ADDRESS

	VECTOR	VEC  ,A'UNIT'II,7
	VECTOR	VEC+4,A'UNIT'OI,7

	.PSECT	CODE,RW,I,LCL,REL,CON

A'UNIT'II:PUSH	R4		;SAVE REGISTER
	MOV	#ADB'UNIT'$,R4	;GET ADDRESS OF ADB
	JMP	ASBINI#		;GO TO COMMON ROUTINE

A'UNIT'OI:PUSH	R4		;SAVE REGISTER
	MOV	#ADB'UNIT'$,R4	;GET ADDRESS OF ADB
	JMP	ASBOUI#		;GO TO COMMON ROUTINE

	.MACRO	LINE  LN,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
.IF IDN <AF>,<L>			;IF SPECIAL LINE PRINTER PORT
	SETXTR	LN
	.IRP	$$$,<\CMD>
	.WORD	LPB'$$$'X
	.ENDM
  LPB'$$$'R=!$$$R
.IFF
  .IF IDN <AF>,<C>			;IF SPECIAL HIGH SPEED CLOCK PORT
	SETXTR	LN
	.WORD	FSCINT#
    FSCLNX==!L.'UNIT'LN
	.SHFT	$$$,1,FSCLNX
    FSCBIT==!$$$
    FSCREG==!$$$R
    FSCFLG==!ADB'UNIT'$+ADBFLG+FSCLNX
  .IFF
	LINEX	LN,UNIT,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	XSDB	TR,T,0,\LN,B
  .ENDC
.ENDC
	.ENDM

$$$AS=!$A1CHG

	XADB	UNIT,B

	.ENDM
.ENDC

	.MACRO	SETXTR  LN
	.EVEN
.IF NDF DSPXTR
  MINXTR==!<LN-1>*400
  MINXT2==!<LN-1>*2
  DSPXTR::
  DSXXTR==!.-MINXT2
.ENDC
	.ENDM
	.PAGE
	.SBTTL	LINXC - MULTIPLE LINE DRIVER FOR DH11

.IF DF TRCNUM
;DH11 DRIVER (UP TO 16 LINES/DEVICE)

	.MACRO	LINXC  UNIT,REG,VEC,REGDS,VECDS
$$$R=!REG			;REGISTER BASE ADDRESS
.IF NB REGDS
  $$$E=!REGDS			;DATA-SET REGISTER BASE ADDRESS
.IFF
  $$$E=!0
.ENDC

	VECTOR	VEC  ,A'UNIT'II,7
	VECTOR	VEC+4,A'UNIT'OI,7
.IF NB REGDS
	VECTOR	VECDS,A'UNIT'DS,7
.ENDC

	.PSECT	CODE,RW,I,LCL,REL,CON

A'UNIT'II:PUSH	R4		;SAVE REGISTER
	MOV	#ADB'UNIT'$,R4	;GET ADDRESS OF ADB
	JMP	ASCINI#		;GO TO COMMON ROUTINE

A'UNIT'OI:PUSH	R4		;SAVE REGISTER
	MOV	#ADB'UNIT'$,R4	;GET ADDRESS OF ADB
	JMP	ASCOUI#		;GO TO COMMON ROUTINE

.IF NB REGDS
  A'UNIT'DS:PUSH  R4		;SAVE REGISTER
	MOV	#ADB'UNIT'$,R4	;GET ADDRESS OF ADB
	JMP	ASCDSI#		;GO TO COMMON ROUTINE
.ENDC

	.MACRO	LINE  LN,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	LINEX	LN,UNIT,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	XSDB	TR,T,0,\LN,C
	.ENDM

$$$AS=!$A1CHG!$A1SPT

	XADB	UNIT,C

	.ENDM
.ENDC
.ENDC			;.IF NE TR.NUM
	.PAGE
	.SBTTL	LINXD - SOFTWARE DE-MUX DRIVER FOR INFOTRON SUPER-MUX

.IF DF TRDNUM
;INFOTRON SUPER MUX DRIVER USING DUP11 OR DU11/DUV11

	.MACRO	LINXD  UNIT,REG,VEC
$$$R=!REG			;REGISTER BASE ADDRESS
A'UNIT'PL=5		;PROCESOR STATUS WORD FOR INTERUPT LEVEL

	VECTOR	VEC,A'UNIT'II,A'UNIT'PL;RECEIVE VECTOR
	VECTOR	VEC+4,A'UNIT'OI,A'UNIT'PL;TRANSMIT VECTOR

	.PSECT	CODE,RW,I,LCL,REL,CON

A'UNIT'II: PUSH	R4		;SAVE R4
	MOV	#ADB'UNIT'$,R4	;GET THE ADB POINTER
	JMP	ASDINI#		;DO COMMON CODE

A'UNIT'OI: PUSH	R4		;SAVE R4
	MOV	#ADB'UNIT'$,R4	;GET THE ADB POINTER
	JMP	ASDOUI#		;DO COMMON OUTPUT SERVICE

	.MACRO	LINE  LN,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	LINEX	LN,UNIT,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	$$$S=!$$$S!$T0FWN	;For a multiplexer fill with nulls
	XSDB	TR,T,0,\LN,D
	.ENDM

$$$AS=!0

$$$L=!5
	XADB	UNIT,D

	.ENDM
.ENDC
	.PAGE
	.SBTTL	LINXE - SOFTWARE DE-MUX DRIVER FOR INFOTRON SUPER-MUX
;-----
; The LINXE driver is similar to the LINXD driver except that the SuperMux
; that we talk to does NOT invert the CRC from normal for a bit stuffed
; interface.
;-----

.IF DF TRENUM
;INFOTRON SUPER MUX DRIVER USING DUP11

	.MACRO	LINXE  UNIT,REG,VEC
$$$R=!REG			;REGISTER BASE ADDRESS
A'UNIT'PL=5		;PROCESOR STATUS WORD FOR INTERUPT LEVEL

	VECTOR	VEC,A'UNIT'II,A'UNIT'PL;RECEIVE VECTOR
	VECTOR	VEC+4,A'UNIT'OI,A'UNIT'PL;TRANSMIT VECTOR

	.PSECT	CODE,RW,I,LCL,REL,CON

A'UNIT'II: PUSH	R4		;SAVE R4
	MOV	#ADB'UNIT'$,R4	;GET THE ADB POINTER
	JMP	ASEINI#		;DO COMMON CODE

A'UNIT'OI: PUSH	R4		;SAVE R4
	MOV	#ADB'UNIT'$,R4	;GET THE ADB POINTER
	JMP	ASEOUI#		;DO COMMON OUTPUT SERVICE

	.MACRO	LINE  LN,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	LINEX	LN,UNIT,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	$$$S=!$$$S!$T0FWN	;For a multiplexer fill with nulls
	XSDB	TR,T,0,\LN,E
	.ENDM

$$$AS=!0
$$$L=!5

	XADB	UNIT,E

	.ENDM
.ENDC
	.PAGE
	.SBTTL	LINXF - Nexilis 8086 IO processor

.IF DF TRFNUM
;Nexilis 8086 IO processor for LSI-11

	.MACRO	LINXF  UNIT,REG,VEC
$$$R=!REG			;Register base address
A'UNIT'PL=!5			;Processor status word for interrupt level
$$$VC=VEC			;Address of vector

	VECTOR	VEC,A'UNIT'XI,A'UNIT'PL;Interrupt vector (there's only one!)

	.PSECT	CODE,RW,I,LCL,REL,CON

A'UNIT'XI: PUSH	R4		;Save R4
	MOV	#ADB'UNIT'$,R4	;Get the ADB pointer
	JMP	ASFXXI#		;Go to common code

	.MACRO	LINE  LN,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	LINEX	LN,UNIT,AF,OBR,IBR,CMD,TT,COD,TP,AS,SNM,CM,ACD,ROB,XX,HCL,CL
	XSDB	TR,T,0,\LN,F
	.ENDM

$$$AS=!0
	XADB	UNIT,F

	.ENDM
.ENDC
	.PAGE
	.SBTTL	DEFINE CONTENTS OF DATA BLOCKS

;DEFINE MACRO'S USED IN DEFINING THE DATA BLOCKS

	.MACRO	W  LABEL,CNTS
LABEL==!OS
OS=!OS+2
	.WORD	CNTS
	.ENDM

	.MACRO	WX  CNTS
OS=!OS+2
	.WORD	CNTS
	.ENDM

	.MACRO	B  LABEL,CNTS
LABEL==!OS
OS=!OS+1
	.BYTE	CNTS
	.ENDM

	.MACRO	BX  CNTS
OS=!OS+1
	.BYTE	CNTS
	.ENDM

	.MACRO	M  LABEL,SIZE
LABEL==!OS
OS=!OS+<SIZE>
	.BLKB	SIZE
	.ENDM

	.MACRO	L  LABEL
LABEL==!OS
	.ENDM
	.PAGE
	.SBTTL	DEVICE DATA BLOCKS (DDB'S)

;DEFINE MACRO USED TO GENERATE EACH DDB

	.MACRO	XDDB  DV,DX,DEV,SOC,TYPE,POKE,RSUM,SSRC,QQQ

	.PSECT	DDB,RW,D,LCL,REL,CON
	.EVEN
OS=!0
DX'DEV'$::
W  DDSTS0,$$$S;			;PURE STATUS WORD
B  DDPRIV,$$$PL;		;Privilege level associated with device
BX        0
W  DDSOC ,SOC;			;HIGHEST VALID SOCKET FOR DEVICE
B  DDID  ,.ID'DV;		;DEVICE I.D.
B  DDINDX,.DX'DEV'DX		;DEVICE INDEX
W  DDPOKE,POKE;			;ADDRESS OF POKE SUBROUTINE FOR DEVICE
W  DDRSUM,RSUM;			;ADDRESS OF RESUME SUBROUTINE FOR DEVICE
W  DDSSRC,SSRC;			;ADDRESS OF SRC SETUP SUBROUTINE FOR RECONNECT
W  DDDDBI,DV'DDBI#		;ADDRESS OF DDB INITIALIZATION ROUTINE
W  DDSDBI,DV'SDBI#		;ADDRESS OF SDB INITIALIZATION ROUTINE
W  DDSX  ,DX'DEV'SX		;ADDRESS OF SX TABLE ENTRY FOR SOCKET
.IF DF DX'DEV'$0		;DO WE HAVE A WILD SOCKET SDB FOR THIS DEVICE
W  DDWLD ,DX'DEV'$0		;ADDRESS OF SDB FOR WILD SOCKET (SOCKET 0)
.IFF
W  DDWLD ,0			;DEFINE ITS VALUE AS 0!
.ENDC
L  DDCBGN			;FIRST WORD TO CLEAR ON STARTUP
W  DDSTS1,0			;IMPURE STATUS WORD
W  DDNCON,0			;NUMBER OF CONNECTIONS ON THE DEVICE
L  DDCEND			;LAST WORD TO CLEAR ON STARTUP + 2
DDCSIZ==!<DDCEND-DDCBGN>/2
	DDB'DV	DEV,SOC,TYPE,QQQ
	.ENDM

;DEFINE MACROS FOR GENERATING THE DEVICE DEPENDENT PARTS OF THE DDB'S

.IF DF ST.NUM
	.MACRO	DDBST  DEV,SOC,TYPE,QQQ
B  DDSTEP,$$$EPL;		;Priviledge level for examine and status
				;  changing commands
B  DDSTDP,$$$DPL;		;Priviledge level for deposit command
	.ENDM
.ENDC

.IF NE TR.NUM
	.MACRO	DDBTR  DEV,SOC,TYPE,QQQ
	.ENDM
.ENDC

.IF DF TX.NUM
	.MACRO	DDBTX  DEV,SOC,TYPE,QQQ
	.ENDM
.ENDC

.IF DF TY.NUM
	.MACRO	DDBTY  DEV,SOC,TYPE,QQQ
	.ENDM
.ENDC

.IF DF TZ.NUM
	.MACRO	DDBTZ  DEV,SOC,TYPE,QQQ
	.ENDM
.ENDC

.IF DF LP.NUM
	.MACRO	DDBLP  DEV,SOC,TYPE,QQQ
	.ENDM
.ENDC

.IF DF CR.NUM
	.MACRO	DDBCR  DEV,SOC,TYPE,QQQ
	.ENDM
.ENDC

.IF DF MT.NUM
	.MACRO	DDBMT  DEV,SOC,TYPE,QQQ
	.ENDM
.ENDC

.IF DF FD.NUM
	.MACRO	DDBFD  DEV,SOC,TYPE,QQQ
	.ENDM
.ENDC

.IF DF WD.NUM
	.MACRO	DDBWD  DEV,SOC,TYPE,QQQ
	.ENDM
.ENDC
	.PAGE
	.SBTTL	MACROS FOR LINK DDB'S

.IF NE LK.NUM
	.MACRO	DDBLK  DEV,SOC,TYPE,NXTPKT,MOVPKT
L'DEV'$'TYPE=!L'DEV'$
	.IRP	DVX,<\DEV+1>
.IF DF L'DVX'$
  $$$=!L'DVX'$
.IFF
  $$$=!0
.ENDC
W  DDLKNX,$$$;			;ADDRESS OF NEXT LINK DDB
.IF DF L'DVX'$'TYPE
  $$$=!L'DVX'$'TYPE
.IFF
  $$$=!0
.ENDC
W  DDLKNS,$$$;			;ADDRESS OF NEXT LINK DDB OF SAME TYPE
	.ENDM
W  DDLKIN,LK'TYPE'INI#;		;ADDRESS OF SUBROUTINE TO INITIALIZE PROTOCOL
				;  ROUTINE AT DEVICE LEVEL
W  DDLKIS,LK'TYPE'INS#;		;ADDRESS OF SUBROUTINE TO INITIALIZE PROTOCOL
				;  ROUTINE AT SOCKET LEVEL
W  DDLKST,LK'TYPE'STR#;		;ADDRESS OF SUBROUTINE TO START IDLE LINK
W  DDLKLD,LK'TYPE'LOD#;		;ADDRESS OF SUBROUTINE TO CONTROL DOWN-LINE
				;  LOADING OVER THE LINK
W  DDLKFP,NXTPKT		;ADDRESS OF LAST PART OF NXTPKT
W  DDLKP0,MOVPKT		;ADDRESS OF LAST PART OF MOVPKT
W  DDLKN1,$$$1			;FIRST HALF OF NAME OF NODE
W  DDLKN2,$$$2			;SECOND HALF OF NAME OF NODE
B  DDLKNA,$$$N0			;Node name in ASCIZ
BX        $$$N1
BX        $$$N2
BX        $$$N3
BX        $$$N4
BX        $$$N5
BX        0			;This must be 0 to end the string!
B  DDLKTP,$$$T			;Link type (ASCII)
B  DDLKEC,LK'DEV'EC/2		;Number of error counters for this link
BX        0
L  DDLKFC			;FIRST WORD TO CLEAR ON STARTUP
W  DDLK0H,0			;LEVEL 0 SOCKET LIST HEAD POINTER
W  DDLK0T,0			;LEVEL 0 SOCKET LIST TAIL POINTER
DDLKXT==!DDLK0T-DDLK0H
W  DDLK1H,0			;LEVEL 1 SOCKET LIST HEAD POINTER
W  DDLK1T,0			;LEVEL 1 SOCKET LIST TAIL POINTER
W  DDLK2H,0			;LEVEL 2 SOCKET LIST HEAD POINTER
W  DDLK2T,0			;LEVEL 2 SOCKET LIST TAIL POINTER
W  DDLKSP,0			;SUPERVISORY SOCKET LIST POINTER
W  DDLKFH,0			;FLAG SOCKET LIST HEAD POINTER
W  DDLKFT,0			;FLAG SOCKET LIST TAIL POINTER
B  DDLKFN,0			;FLAG COUNTER
B  DDLKPS,0			;STATE BITS
L  DDLKER			;Address of first error counter (for status dev)
W  DDERIS,0			;ERROR COUNT - ILLEGAL SOCKET NUMBER
W  DDERBF,0			;ERROR COUNT - BAD FLAG COUNT
W  DDERIP,0			;ERROR COUNT - ILLEGAL PACKET TYPE
W  DDEROR,0			;ERROR COUNT - OVERRUN
W  DDERNP,0			;ERROR COUNT - NO PACKET AVAILABLE
W  DDERSZ,0			;ERROR COUNT - SIZE ERROR
W  DDERPC,0			;ERROR COUNT - PROTOCOL ERROR
W  DDERCS,0			;ERROR COUNT - CHECKSUM ERROR
W  DDERBC,0			;ERROR COUNT - BAD CONNECTION COUNT
W  DDERSI,0			;ERROR COUNT - SPERIOUS INTERRUPT
W  DDERHO,0			;ERROR COUNT - HARD OUTPUT ERROR
W  DDERFT,0			;ERROR COUNT - FATAL ERROR
W  DDERRX,0			;ERROR COUNT - MESSAGE RETRANSMISSION
L  DDLKLC			;LAST WORD TO CLEAR ON STARTUP + 2
DDLKCZ==!<DDLKLC-DDLKFC+1>/2
	DDBLK'TYPE  DEV,SOC
	.ENDM
	.PAGE
	.SBTTL	DDB FOR TYPE A LINKS

.IF DF LKANUM
	.MACRO	DDBLKA  DEV,SOC
.IF NDF LKADDB
  LKADDB==!L'DEV'$		;LABEL FOR FIRST DDB FOR TYPE A LINK
.ENDC
LK'DEV'EC=!OS-DDLKER
W  DDLAIB,$$$R+4		;ADDRESS OF DEVICE INPUT BUFFER
W  DDLAOB,$$$R+2		;ADDRESS OF DEVICE OUTPUT BUFFER
W  DDLASR,$$$R			;ADDRESS OF DEVICE CONTROL AND STATUS REGISTER
L  DDLAFC			;FIRST LOCATION TO CLEAR ON STARTUP
B  DDLAXC,0			;RETRY COUNTER
B  DDLATR,0			;RESPONSE TIMER
B  DDLATP,0			;POKE TIMER
B  DDLATD,0			;DATA TIMER
W  DDLAIK,0			;POINTER TO START OF INPUT PACKET
W  DDLAIP,0			;POINTER TO CURRENT INPUT WORD
W  DDLAIX,0			;INPUT CHECKSUM
B  DDLAIC,0			;INPUT WORD COUNT
B  DDLAIS,0			;INPUT STATE
W  DDLAOK,0			;POINTER TO START OF OUTPUT PACKET
W  DDLAOP,0			;POINTER TO CURRENT OUTPUT WORD
W  DDLAOD,0			;ADDRESS OF SDB FOR OUTPUT PACKET
W  DDLAOX,0			;OUTPUT CHECKSUM
B  DDLAOC,0			;OUTPUT WORD COUNT
B  DDLAOS,0			;OUTPUT STATE
B  DDLAXA,0			;BITS FOR PENDING ACK/NAK REQUESTS
L  DDLALC			;LAST LOCATION + 2 TO CLEAR ON STARTUP
DDLACZ==!<DDLALC-DDLAFC+1>/2
	XSDB	LK,L,DEV,0,A	;THIS LINK USES A WILD SOCKET SDB
	.ENDM
.ENDC
	.PAGE
	.SBTTL	DDB FOR TYPE B LINKS

.IF DF LKBNUM
	.MACRO	DDBLKB  DEV,SOC
.IF NDF LKBDDB
  LKBDDB==!L'DEV'$		;LABEL FOR FIRST DDB FOR TYPE B LINK
.ENDC
;-----
; These are the error counters for the NAK reasons
;-----
W  DDERHB,0				;Header Block Check error
W  DDERDB,0				;Data Block Check error
W  DDERRR,0				;Rep response
W  DDERHF,0				;Message header format error
;-----
; These are the local error counters (Local to this node)
;-----
W  DDLBAE,0				;Ack error
W  DDERRC,0				;Sent rep counter
W  DDCDWN,0				;Current down time
W  DDTDW2,0				;High order total down time
W  DDTDW1,0				;Low order total down time
W  DDERTU,0				;Transmitter under runs
W  DDERHE,0				;Header CRC error
W  DDERFH,0				;Header format error
W  DDERBU,0				;Buffer unavailable
W  DDERML,0				;Message too large
W  DDERDE,0				;Data CRC error
W  DDERRO,0				;Receiver overrun
W  DDERH2,0				;Header CRC error in qsync block
W  DDERF2,0				;Header format error in qsync block
W  DDERD2,0				;Data CRC error in qsync block
LK'DEV'EC=!OS-DDLKER

.IF EQ	$$$L+1			;If no DCP is being used
W  DDLBRS,$$$R			;RXCSR - Reciver status register
W  DDLBRB,$$$R+2		;RXDBUF- Reciever data buffer
W  DDLBPR,$$$R+2		;PARCSR- Parameter status register
W  DDLBTS,$$$R+4		;TXCSR - Transmitter status register
W  DDLBTB,$$$R+6		;TXDBUF- Transmitter data buffer
W  DDOCRC,0			;Output CRC
W  DDICRC,0			;Input CRC
	.ENDC

.IF NE $$$L+1			;If we are using a DCP
W  DDLBRX,$$$R			;The DCP recieve control word
W  DDLBRB,$$$R+2		;The DCP recieve buffer word
W  DDLBTX,$$$R+10		;The DCP transmit control word
W  DDLBTB,$$$R+12		;The DCP transmit buffer word
W  DDLBVC,$$$VC				;The device vector to init
	.ENDC

W  DDPSLV,$$$P*40		;Processor status level at interrupt
W  DDLBLN,<$$$L*400>		;The line number on the DCP
W  DDHNDR,LKO'DEV		;Starting address of output handler
W  DDCIMI,0			;Input to main in pointer
W  DDCIMO,0			;Input to main out pointer
W  DDCIME,DDIMEX+L'DEV'$	;Input to main end pointer
W  DDCIMB,DDIMSX+L'DEV'$	;Input to main beginning pointer
W  DDCMOI,0			;Main to output in pointer
W  DDCMOO,0			;Main to output out pointer
W  DDCMOE,DDMOEX+L'DEV'$	;Main to output end pointer
W  DDCMOB,DDMOSX+L'DEV'$	;Main to output beginning pointer
W  DDSTHO,DDLBBF+L'DEV'$	;Start of header buffer
W  DDEDHO,DDLBEB+L'DEV'$	;End of header buffer
W  DDLBEP,DDLBLP+L'DEV'$	;End of input buffer
W  DDLBBP,DDLBFP+L'DEV'$	;Beginning of input buffer
L  DDLBFC			;First location to clear on init.
W  DDLBIP,0			;The in pointer for the input buffer
W  DDCNTI,0			;Input character count for SOH
W  DDCNTO,0			;Output character count for SOH
W  DDLBOH,0			;The output head pointer
W  DDPKTI,0			;Current input packet pointer
W  DDPKTO,0			;Current output packet pointer
W  DDPKTC,0			;Current packet being filled
W  DDPKTT,0			;Packet list, tail pointer
W  DDPKTH,0			;Packet list, head pointer
W  DDDCP ,0			;DDCMP current header pointer
W  DDFLAG,0			;Status flags for protocol
W  DDFLG2,0			;  "      "    "      "
W  DDLBPO,0			;Packet to send for Remote Loading
W  DDOST,0			;Output state
W  DDLBT1,0			;LOAD TYPE
W  DDLBP1,0			;PREFIX
W  DDLBC1,0			;LOAD CHECK SUM
W  DDLBLS,0			;LOAD STATE
W  DDCTHO,0			;
W  DDSNAK,0			;Current nak reason
W  DDSACK,0			;send ack flag
W  DDSREP,0			;Send rep flag
W  DDLBWT,0			;Packet waiting to go out
W  DDREPT,0			;Reply threshold count(Till link down)
B  DDSYN ,0			;Synchronize flag for protocol
B  DDSTAT,0			;The state of the protocol
B  DDNUM ,0			;NUM(Number of packet)
B  DDRESP,0			;RESP(Respose field)
B  DDACK ,0			;A(Last number ack'ed)
B  DDCTRN,0			;X(Last currently transmitted)
B  DDTRNS,0			;T(Next to be transmitted)
B  DDTIMR,0			;Rep timer
B  DDCACK,0			;The DDCMP packet number relating to
B  DDLBSS,0			;The Send Synch counter
B  DDSCNT,0			;The send ahead counter
B  DDLBSN,0			;The dummy byte to keep it even
M  DDLBBF,6			;DDCMP header block
L  DDLBEB			;End of header + 2
M  DDLBFP,6			;The input buffer
L  DDLBLP			;The end of the input buffer + 2
M  DDIMSX,IMSIZ*10.		;The input to main circular buffer
L  DDIMEX			;The end of the buffer + 2
M  DDMOSX,MOSIZ*10.		;The main to output circular buffer
L  DDMOEX			;The end of the buffer + 2
L  DDLBLC			;The last location to clear + 2
DDLBCZ==!<DDLBLC-DDLBFC+1>/2
	XSDB	LK,L,DEV,0,B	;THIS LINK USES A WILD SOCKET SDB
	.ENDM
.ENDC
	.PAGE
	.SBTTL	DDB FOR TYPE C LINKS

.IF DF LKCNUM
	.MACRO	DDBLKC  DEV,SOC
.IF NDF LKCDDB
  LKCDDB==!L'DEV'$;		;LABEL FOR FIRST DDB FOR TYPE C LINK
.ENDC
LK'DEV'EC=!OS-DDLKER
W  DDLCIB,$$$R+4		;ADDRESS OF DEVICE INPUT BUFFER
W  DDLCOB,$$$R+2		;ADDRESS OF DEVICE OUTPUT BUFFER
W  DDLCSR,$$$R			;ADDRESS OF DEVICE CONTROL AND STATUS REGISTER
L  DDLCFC			;FIRST LOCATION TO CLEAR ON STARTUP
B  DDLCTM,0			;MESSAGE TIMER
B  DDLCTD,0			;DATA TIMER
B  DDLCRQ,0			;MAIN PROGRAM REQUEST BYTE
B  DDLCXX,0
W  DDLCIK,0			;POINTER TO START OF INPUT PACKET
W  DDLCIP,0			;POINTER TO CURRENT INPUT WORD
W  DDLCIX,0			;INPUT CHECKSUM
B  DDLCIC,0			;INPUT WORD COUNT
B  DDLCIS,0			;INPUT STATE
W  DDLCIW,0			;INPUT HEADER WORD
W  DDLCOK,0			;POINTER TO START OF OUTPUT PACKET
W  DDLCOP,0			;POINTER TO CURRENT OUTPUT WORD
W  DDLCOD,0			;ADDRESS OF SDB FOR OUTPUT PACKET
W  DDLCOX,0			;OUTPUT CHECKSUM
B  DDLCOC,0			;OUTPUT WORD COUNT
B  DDLCOS,0			;OUTPUT STATE
B  DDLCXA,0			;BITS FOR PENDING ACK/NAK REQUESTS
L  DDLCLC			;LAST LOCATION + 2 TO CLEAR ON STARTUP
DDLCCZ==!<DDLCLC-DDLCFC+1>/2
	XSDB	LK,L,DEV,0,C	;THIS LINK USES A WILD SOCKET SDB
	.ENDM
.ENDC
	.PAGE
	.SBTTL	DDB FOR TYPE D LINKS

.IF DF LKDNUM
	.MACRO	DDBLKD  DEV,SOC
.IF NDF LKDDDB
  LKDDDB==!L'DEV'$;		;LABEL FOR FIRST DDB FOR TYPE D LINK
.ENDC
LK'DEV'EC=!OS-DDLKER
W  DDLDIR,$$$R+4		;ADDRESS OF DEVICE INPUT REGISTER
W  DDLDOR,$$$R+2		;ADDRESS OF DEVICE OUTPUT REGISTER
W  DDLDSR,$$$R			;ADDRESS OF DEVICE CONTROL AND STATUS REGISTER
L  DDLDFC			;FIRST LOCATION TO CLEAR ON STARTUP
W  DDLDOZ,0			;ADDRESS OF SDB FOR CURRENT OUTPUT PACKET
W  DDLDOK,0			;ADDRESS OF CURRENT OUTPUT PACKET
W  DDLDOP,0			;ADDRESS OF CURRENT OUTPUT WORD
B  DDLDOC,0			;OUTPUT WORD COUNT
B  DDLDIS,0			;INPUT STATE
W  DDLDIX,0			;INPUT DATA WORD
W  DDLDIP,0			;ADDRESS OF INPUT WORD
W  DDLDIK,0			;ADDRESS OF INPUT PACKET
B  DDLDIC,0			;INPUT WORD COUNT
B  DDLDCC,0			;INPUT CHARACTER COUNT (MUST BE DDLDIC+1!)
B  DDLDTM,0			;INPUT MESSAGE TIMER
B  DDLDTD,0			;OUTPUT DATA TIMER
B  DDLDRQ,0			;SERVICE REQUEST BITS
B  DDLDXX,0
L  DDLDLC			;LAST LOCATION + 2 TO CLEAR ON STARTUP
DDLDCZ==!<DDLDLC-DDLDFC+1>/2
	XSDB	LK,L,DEV,0,D	;THIS LINK USES A WILD SOCKET SDB
	.ENDM
.ENDC
	.PAGE
	.SBTTL	DDB FOR TYPE E LINKS

.IF DF LKENUM
	.MACRO	DDBLKE  DEV,SOC
.IF NDF LKEDDB
  LKEDDB==!L'DEV'$;		; Label for first DDB for type E link
.ENDC
LK'DEV'EC=!OS-DDLKER
W  DDLERS,$$$R			; Receiver status register
W  DDLERB,$$$R+2		; Receiver data buffer
W  DDLEPR,$$$R+2		; Parameter control register
W  DDLEXS,$$$R+4		; Transmitter status register
W  DDLEXB,$$$R+6		; Transmitter data buffer
W  DDLEPX,0			; Parameter control register initial value
W  DDLELV,$$$P*40		; Interrupt priority level
W  DDLELB,L'DEV'$+DDLELR	; Ptr to beginning of TRANSMIT ring
W  DDLELE,L'DEV'$+DDLELR+<2*<$$$C+1>>; Pointer to end of TRANSMIT ring
W  DDLELH,L'DEV'$+DDLELR	; Ring pointer to head of XMIT RING
W  DDLELN,L'DEV'$+DDLELR	; Ring pointer to next frame to send
W  DDLELT,L'DEV'$+DDLELR	; Ring pointer to tail of XMIT RING
W  DDLEQB,L'DEV'$+DDLEQR	; Ptr to start of input to main ring
W  DDLEQE,L'DEV'$+DDLEQR+<4*<$$$C+3>> ; Ptr to end of input to main ring
W  DDLEQP,L'DEV'$+DDLEQR	; Input to main ring putter
W  DDLEQT,L'DEV'$+DDLEQR	; Input to main ring taker
W  DDLED1,$$$3			; 1ST HALF OF X.25 DESTINATION NAME
W  DDLED2,$$$4			; 2ND HALF OF X.25 DESTINATION NAME
W  DDLEX1,$$$5
W  DDLEX2,$$$6
B  DDLEXC,$$$A			; TRANSMITted command frame address
B  DDLEXR,$$$B			; Transmitted response frame address
B  DDLERC,$$$B			; Received command frame address
B  DDLERR,$$$A			; Received response frame address
B  DDLEK0,$$$C			; FRAME TRANSMIT RING WINDOW SIZE
B  DDLEK1,$$$D			; DURATION OF NO-RESPONSE TIMER T1
B  DDLEK2,$$$E			; RETRANSMISSION COUNTER N2
B  DDLEK3,$$$F			; MAX # BYTES IN FRAME INFO FIELD
L  DDLEFC			; 1st word to clear on STARTUP
B  DDLET3,0			; IDLE OUTPUT RR FRAME TIMER
B  DDLET4,0			; REJECT CONDITION TIMER
B  DDLET5,0			; COMMAND REJECT CONDITION TIMER
B  DDLET6,0			; Idle input take-down timer
W  DDLEBX,0			; ERROR COUNT - BAD RETRANSMISSIONS
				;   (NOTHING IN RING TO RETRANSMIT)
W  DDLEAH,0			; PACKET LEVEL SEND BACK LIST HEAD
W  DDLEAT,0			; PACKET LEVEL SEND BACK LIST TAIL
W  DDLEFG,0			; Protocol flags word
W  DDLEF2,0			; 2ND FLAG WORD
W  DDLEIS,0			; Input state dispatch
W  DDLEOS,0			; Output state dispatch
W  DDLETS,0			; Temp storage for output state
				;   dispatch during transparent output
W  DDLEOI,0			; Dispatch for output frame info field
W  DDLECI,0			; Input CRC-16
W  DDLECO,0			; Output CRC-16
W  DDLEIF,0			; Input packet list head pointer
W  DDLEMF,0			; Main level packet list head pointer
W  DDLEOF,0			; Output packet list head pointer
W  DDLEIP,0			; Input current packet pointer
W  DDLEOP,0			; Output current packet pointer
W  DDLEIB,0			; Input byte pointer
W  DDLEOB,0			; Output byte pointer
W  DDLETX,0			; Timer T1 expiration dispatch
W  DDLEUR,0			; Waiting to receive UA frame dispatch
M  DDLELR,2*<$$$C+1>		; Send list ring (window of K frames)
M  DDLEQR,4*<$$$C+3>		; Input to main ring
B  DDLEIA,0			; Input frame address byte
B  DDLEOA,0			; Output frame address byte
B  DDLEIX,0			; Input frame control byte
B  DDLEMX,0			; Main level frame control byte
B  DDLEOX,0			; Output frame control byte
B  DDLEIK,0			; Input frame byte count
B  DDLEIC,0			; Input current packet byte count
B  DDLEOC,0			; Output currenmt packet byte count
B  DDLEIZ,0			; Input frame error status function
B  DDLET1,0			; Timer T1
B  DDLEN2,0			; Retransmission count N2
B  DDLENR,0			; N(R) of last good info or SUPV frame
B  DDLEVR,0			; V(R) next info frame expected
B  DDLEVS,0			; V(S) next info frame to send
B  DDLEVT,0			; Tranmit ring frame count
B  DDLEAK,0			; Response function (acknowledgement)
B  DDLECM,0			; Pending command function to send
B  DDLECR,0			; CMDR reason byte
B  DDLECX,0			; Bad control byte causing CMDR
B  DDLEXX,0			; Temp storage for 1 byte at main level
L  DDLELC			; Last word (+2) to clear on startup
DDLECZ==!<DDLELC-DDLEFC+1>/2
	XSDB	LK,L,DEV,0,E	;THIS LINK USES A WILD SOCKET SDB
	.ENDM
.ENDC
	.PAGE
	.SBTTL	DDB FOR TYPE F LINKS

.IF DF LKFNUM
	.MACRO	DDBLKF  DEV,SOC
.IF NDF LKFDDB
  LKFDDB==!L'DEV'$;		;LABEL FOR FIRST DDB FOR TYPE F LINK
.ENDC
LK'DEV'EC=!OS-DDLKER
W  DDLFIR,$$$R+4		;ADDRESS OF DEVICE INPUT REGISTER
W  DDLFOR,$$$R+2		;ADDRESS OF DEVICE OUTPUT REGISTER
W  DDLFSR,$$$R			;ADDRESS OF DEVICE CONTROL AND STATUS REGISTER
W  DDLFAV,$$$W			;SIZE OF HOST'S INPUT RING BUFFER IN PDP-10
				;  WORDS
W  DDLFPL,$$$P*40		;INTERRUPT PRIORITY LEVEL
L  DDLFFC			;FIRST LOCATION TO CLEAR ON STARTUP
W  DDLFBI,0			;BLOCK MODE-TO HOST-CHARACTER COUNT
W  DDLFOV,0			;BLOCK MODE-TO HOST-ADDRESS OF DATA TO SEND
W  DDLFBH,0			;BLOCK MODE-FROM HOST-LIST HEAD POINTER
W  DDLFBT,0			;BLOCK MODE-FROM HOST-LIST TAIL POINTER
W  DDLFBS,0			;BLOCK MODE-FROM HOST-SDB ADDRESS
W  DDLFBC,0			;BLOCK MODE-FROM HOST-TOTAL WORD COUNT
W  DDLFBJ,0			;BLOCK MODE-FROM HOST-TOTAL CHARACTER COUNT
W  DDLFBK,0			;BLOCK MODE-FROM HOST-ADDRESS OF FIRST PACKET
W  DDLFBQ,0			;BLOCK MODE-FROM HOST-ADDRESS OF CURRENT PACKET
W  DDLFBW,0			;BLOCK MODE-FROM HOST-DATA POINTER
B  DDLFBY,0			;BLOCK MODE-FROM HOST-WORDS LEFT IN PACKET
B  DDLFBP,0			;BLOCK MODE-NUMBER OF CHANNELS
W  DDLFXR,0			;PACKET WAIT-RECOVERY ADDRESS
W  DDLFXS,0			;PACKET WAIT-SDB ADDRESS
W  DDLFX1,0			;PACKET WAIT-DATA WORD
W  DDLFX2,0			;PACKET WAIT-DATA WORD
W  DDLFX3,0			;PACKET WAIT-DATA WORD
W  DDLFX4,0			;PACKET WAIT-DATA WORD
W  DDLFT1,0			;TEST PATTERN-FIRST WORD
W  DDLFT2,0			;TEST PATTERN-SECOND WORD
W  DDLFS1,0			;HOST SAD BITS-FIRST WORD
W  DDLFS2,0			;HOST SAD BITS-SECOND WORD
W  DDLFPO,0			;PORT OFFSET ON HOST
W  DDLFAL,0			;NUMBER OF PDP-10 WORDS TO END OF HOST'S INPUT
				;  RING BUFFER
W  DDLFGS,0			;Address of current supervisory SDB
W  DDLFIQ,0			;ADDRESS OF CURRENT INPUT PACKET
W  DDLFIK,0			;ADDRESS OF FIRST INPUT PACKET
W  DDLFIP,0			;INPUT POINTER
W  DDLFIC,0			;INPUT WORD COUNT
W  DDLFCC,0			;INPUT CHARACTER COUNT
B  DDLFIS,0			;INPUT STATE (MUST BE EVEN ADDRESS)
B  DDLFPC,0			;SPACE LEFT IN CURRENT INPUT PACKET
M  DDLFIX,20.			;INPUT MESSAGE BUFFER
W  DDLFOK,0			;ADDRESS OF OUTPUT PACKET
W  DDLFOP,0			;OUTPUT POINTER
W  DDLFOC,0			;OUTPUT WORD COUNT
W  DDLFOZ,0			;ADDRESS OF SDB FOR OUTPUT PACKET
W  DDLFQX,0			;WORD USED FOR TERMINAL PARAMETER MESSAGES
				;  (MUST PRECEED DDLFOX!)
DDLFQQ==!DDLFQX/2+1
M  DDLFOX,PKCMAX*2-2		;OUTPUT MESSAGE BUFFER
W  DDLFOS,0			;OUTPUT STATE
B  DDLFRQ,0			;MAIN PROGRAM LEVEL REQUEST BITS
B  DDLFTM,0			;MESSAGE TIMER
B  DDLFTD,0			;DATA TIMER (MUST BE EVEN BYTE)
B  DDLFTP,0			;POKE TIMER (MUST BE DDLFTD + 1)
L  DDLFLC			;LAST LOCATION + 2 TO CLEAR ON STARTUP
DDLFCZ==!<DDLFLC-DDLFFC+1>/2
	XSDB	LK,L,DEV,0,F;	;THIS LINK USES A WILD SOCKET SDB
	.ENDM
.ENDC
	.PAGE
	.SBTTL	DDB FOR TYPE G LINKS

.IF DF LKGNUM
	.MACRO	DDBLKG  DEV,SOC
.IF NDF LKGDDB
  LKGDDB==!L'DEV'$;		; Label for first DDB for type E link
.ENDC
LK'DEV'EC=!OS-DDLKER
W  DDLGRS,$$$R			; Receiver status register
W  DDLGRB,$$$R+2		; Receiver data buffer
W  DDLGPR,$$$R+2		; Parameter control register
W  DDLGXS,$$$R+4		; Transmitter status register
W  DDLGXB,$$$R+6		; Transmitter data buffer
W  DDLGPX,0			; Parameter control register initial value
W  DDLGPL,$$$P*40		;PROCESSOR LEVEL FOR INTERRUPT LEVEL
W  DDLGLB,L'DEV'$+DDLGLR	; Ptr to beginning of TRANSMIT ring
W  DDLGLE,L'DEV'$+DDLGLR+<2*<$$$C+1>>; Pointer to end of TRANSMIT ring
W  DDLGLH,L'DEV'$+DDLGLR	; Ring pointer to head of XMIT RING
W  DDLGLN,L'DEV'$+DDLGLR	; Ring pointer to next frame to send
W  DDLGLT,L'DEV'$+DDLGLR	; Ring pointer to tail of XMIT RING
W  DDLGQB,L'DEV'$+DDLGQR	; Ptr to start of input to main ring
W  DDLGQE,L'DEV'$+DDLGQR+<4*<$$$C+3>> ; Ptr to end of input to main ring
W  DDLGQP,L'DEV'$+DDLGQR	; Input to main ring putter
W  DDLGQT,L'DEV'$+DDLGQR	; Input to main ring taker
W  DDLGD1,$$$3			; 1ST HALF OF X.25 DESTINATION NAME
W  DDLGD2,$$$4			; 2ND HALF OF X.25 DESTINATION NAME
W  DDLGD3,$$$4			; 1ST HALF OF ALTERNATE DST NAME
W  DDLGD4,$$$5			; 2ND HALF OF ALTERNATE DST NAME
B  DDLGXC,$$$A			; TRANSMITted command frame address
B  DDLGXR,$$$B			; Transmitted response frame address
B  DDLGRC,$$$B			; Received command frame address
B  DDLGRR,$$$A			; Received response frame address
B  DDLGK0,$$$C			; FRAME TRANSMIT RING WINDOW SIZE
B  DDLGK1,$$$D			; DURATION OF NO-RESPONSE TIMER T1
B  DDLGK2,$$$E			; RETRANSMISSION COUNTER N2
B  DDLGK3,$$$F			; MAX # BYTES IN FRAME INFO FIELD
L  DDLGFC			; 1st word to clear on STARTUP
B  DDLGT3,0			; IDLE LINK RR FRAME TIMER
B  DDLGT4,0			; REJECT CONDITION TIMER
B  DDLGT5,0			; COMMAND REJECT CONDITION TIMER
B  DDLGT6,0			; Idle input take-down timer
W  DDLGBX,0			; ERROR COUNT - BAD RETRANSMISSIONS
				;   (NOTHING IN RING TO RETRANSMIT)
W  DDLGAH,0			; PACKET LEVEL SEND BACK LIST HEAD
W  DDLGAT,0			; PACKET LEVEL SEND BACK LIST TAIL
W  DDLGFG,0			; Protocol flags word
W  DDLGF2,0			; 2ND FLAG WORD
W  DDLGIS,0			; Input state dispatch
W  DDLGOS,0			; Output state dispatch
W  DDLGTS,0			; Temp storage for output state
				;   dispatch during transparent output
W  DDLGOI,0			; Dispatch for output frame info field
W  DDLGCI,0			; Input CRC-16
W  DDLGCO,0			; Output CRC-16
W  DDLGIF,0			; Input packet list head pointer
W  DDLGMF,0			; Main level packet list head pointer
W  DDLGOF,0			; Output packet list head pointer
W  DDLGIP,0			; Input current packet pointer
W  DDLGOP,0			; Output current packet pointer
W  DDLGIB,0			; Input byte pointer
W  DDLGOB,0			; Output byte pointer
W  DDLGTX,0			; Timer T1 expiration dispatch
W  DDLGUR,0			; Waiting to receive UA frame dispatch
M  DDLGLR,2*<$$$C+1>		; Send list ring (window of K frames)
M  DDLGQR,4*<$$$C+3>		; Input to main ring
B  DDLGIA,0			; Input frame address byte
B  DDLGOA,0			; Output frame address byte
B  DDLGIX,0			; Input frame control byte
B  DDLGMX,0			; Main level frame control byte
B  DDLGOX,0			; Output frame control byte
B  DDLGIK,0			; Input frame byte count
B  DDLGIC,0			; Input current packet byte count
B  DDLGOC,0			; Output currenmt packet byte count
B  DDLGIZ,0			; Input frame error status function
B  DDLGT1,0			; Timer T1
B  DDLGN2,0			; Retransmission count N2
B  DDLGNR,0			; N(R) of last good info or SUPV frame
B  DDLGVR,0			; V(R) next info frame expected
B  DDLGVS,0			; V(S) next info frame to send
B  DDLGVT,0			; Tranmit ring frame count
B  DDLGAK,0			; Response function (acknowledgement)
B  DDLGCM,0			; Pending command function to send
B  DDLGCR,0			; CMDR reason byte
B  DDLGCX,0			; Bad control byte causing CMDR
B  DDLGXX,0			; Temp storage for 1 byte at main level
L  DDLGLC			; Last word (+2) to clear on startup
DDLGCZ==!<DDLGLC-DDLGFC+1>/2
	XSDB	LK,L,DEV,0,G	;THIS LINK USES A WILD SOCKET SDB
	.ENDM
.ENDC
	.PAGE
	.SBTTL	DDB FOR TYPE H LINKS

.IF DF LKHNUM
	.MACRO	DDBLKH  DEV,SOC
.IF NDF LKHDDB
  LKHDDB==!L'DEV'$;		;LABEL FOR FIRST DDB FOR TYPE H LINK
.ENDC
LK'DEV'EC=!OS-DDLKER
W  DDLHNN,$$$NN;		;TYMNET NODE NUMBER
W  DDLHND,$$$ND;		;NODE DESCRIPTOR
W  DDLHLD,L'DEV'.0;		;ADDRESS OF FIRST LDB
W  DDLHNL,$$$NL;		;NUMBER OF LINES ON GATEWAY
W  DDLHMX,204+<$$$NH*4>		;HIGHEST LEGAL ADDRESS IN SUPERVISOR AREA
W  DDLHTR,100000+<$$$NH*100>+$$$NL;SR2 WORD FOR TAKEOVER RESPONSE
.IF DF LHBASE			;ONLY IF HAVE TYM-BASE SUPPORT
  W  DDLHXP,$$$S0		;TABLE OF PORTS TO USE AS KEYS FOR BUILDING
  WX        $$$S1		;  AUX-CIRCUITS
  WX        $$$S2
  WX        $$$S3
  W  DDLHNH,$$$NH		;NUMBER OF HOSTS ON THIS TYMBASE
  W  DDLHSH,$$$SH		;NUMBER OF PORTS ALLOCATED TO EACH HOST
  W  DDLHPH,$$$PH		;NUMBER OF PORTS ACTUALLY AVAILABLE TO EACH HOST
  W  DDLHHM,L.HM'DEV		;ADDRESS OF MESSAGE TABLE FOR THIS TYMBASE
  W  DDLHBF,HBFT'DEV;		;ADDRESS OF HOST BUFFER TABLE
  W  DDLHDH,$$$0A;		;LIST OF NAMES FOR DST HOSTS
  WX        $$$0B
  WX        $$$1A
  WX        $$$1B
  WX        $$$2A
  WX        $$$2B
  WX        $$$3A
  WX        $$$3B
  W  DDLHHY,$$$SO		;HOST TABLE OFFSET VALUE
.ENDC
L  DDLHFC;			;FIRST LOCATION TO CLEAR ON STARTUP
.IF DF LHBASE
  M  DDLHXS,8.			;ADDRESSES OF SDB'S FOR AUX-CIRCUIT DIALOGS
  M  DDLHSS,16.			;ADDRESSES OF SUPERVISORY SDB'S FOR EACH HOST
.ENDC
B  DDLHNU,0;			;NUMBER OF LINES WHICH ARE UP
BX        0
W  DDLHUP,0;			;UPSTREAM SWITCH
W  DDLHDW,0;			;DOWNSTREAM SWITCH
B  DDLHTY,0;			;SUPERVISOR TYPE
B  DDLHSN,0;			;CURRENT SUPERVISOR NUMBER
M  DDLHSM,212;			;SUPERVISOR MEMORY AREA
L  DDLHLC;			;LAST LOCATION + 2 TO CLEAR ON STARTUP
DDLHCZ==!<DDLHLC-DDLHFC+1>/2
.IF DF LHBASE
  .IF DF LD'DEV'.0
    W  DDLHHD,LD'DEV'.0
    WX        $$$PH
  .IFF
    W  DDLHHD,0
    WX        0
  .ENDC
  .IF DF LD'DEV'.1
    WX         LD'DEV'.1
    WX         $$$PH
  .IFF
    WX         0
    WX         0
  .ENDC
  .IF DF LD'DEV'.2
    WX         LD'DEV'.2
    WX         $$$PH
  .IFF
    WX         0
    WX         0
  .ENDC
  .IF DF LD'DEV'.3
    WX         LD'DEV'.3
    WX         $$$PH
  .IFF
    WX         0
    WX         0
  .ENDC
.ENDC
	.ENDM
.ENDC
.ENDC				;.IF NE LK.NUM
	.PAGE
	.SBTTL	LINE DATA BLOCKS FOR LINKS (LDB'S)

.IF DF LKHNUM			;ONLY HAVE LDB'S IF HAVE TYPE H LINKS

;DEFINE MACRO USED TO GENERATE COMMON PART OF EACH LDB

	.MACRO	XLDB  DEV,LINE,TYPE
	.PSECT	LDB,RW,D,LCL,REL,CON
OS=!0
L'DEV'.'LINE::
W  LDHSTX,LH'TYPE'STX#;		;ADDRESS OF FRAME LEVEL START ROUTINE
W  LDHDWX,LH'TYPE'DWX#;		;ADDRESS OF FRAME LEVEL "DOWN" ROUTINE
W  LDHINX,LH'TYPE'INX#;		;ADDRESS OF FRAME LEVEL INITIALIZATION ROUTINE
W  LDHSDB,LS'DEV'.'LINE		;ADDRESS OF SDB TABLE FOR THIS LINE
B  LDHSPD,$$$Q;			;LINE SPEED
B  LDHGRP,$$$C/10;		;NUMBER OF 8 LINE GROUPS
B  LDHCHN,$$$C;			;NUMBER OF CHANNELS
B  LDHLNO,LINE;			;LINE NUMBER
W  LDHDDB,L'DEV'$;		;ADDRESS OF DDB
W  LDHNBR,$$$N;			;NUMBER OF NEIGHBOR NODE
W  LDHNXT,L'DEV'H'LINE;		;ADDRESS OF NEXT LDB
W  LDHNXS,0;			;NEXT LDB OF SAME LINE TYPE
W  LDHST0,$$$S;			;PURE STATUS WORD
W  LDHNPT,L'DEV'$+DDLHSM+<<65+LINE>*2> ;POINTER TO NODE NUMBER IN FAKE MEMORY
W  LDHBPT,L'DEV'$+DDLHSM+<<5+LINE>*2> ;POINTER TO BORI IN FAKE MEMORY
L  LDHFCL;			;FIRST LOCATION TO CLEAR ON STARTUP
W  LDHST1,0;			;IMPURE STATUS WORD
W  LDHZLH,0;			;ZAP LIST HEAD POINTER
W  LDHZLT,0;			;ZAP LIST TAIL POINTER
W  LDHSLH,0;			;SUPERVISOR LIST HEAD POINTER
W  LDHSLT,0;			;SUPERVISOR LIST HEAD POINTER
W  LDHXLH,0;			;SEND LIST HEAD POINTER
W  LDHXLT,0;			;SEND LIST TAIL POINTER
W  LDHZCN,0;			;NUMBER OF TIMES BUFFERS ZAPPED BY LNKH
W  LDHSR0,0;			;Place to save R0 if no packets
W  LDHSR2,0;			;Place to save R2 if no packets
W  LDHSSD,0;			;PLACE TO SAVE SD IF NO PACKETS
W  LDHSFC,0;			;Place to save frame count if no packets
W  LDHSRC,0;			;Place to save record count if no packets
W  LDHSPC,0;			;Place to save PC if no packets
W  LDPKOT,0;			;Packets sent out
W  LDPKIN,0;			;Packets received
W  LDERBD,0;			;ERROR COUNT - BAD DATA IN FRAME
W  LDHERC,0;			;ERROR COUNT - BAD CHECKSUM
W  LDHERB,0;			;ERROR COUNT - LOOP BACK
W  LDHERS,0;			;ERROR COUNT - FRAMES RECEIVED OUT OF SEQUENCE
W  LDHERX,0;			;ERROR COUNT - FRAMES RETRANSMITTED
L  LDHLCL;			;LAST LOCATION TO CLEAR ON STARTUP
LDHCSZ==!<LDHLCL-LDHFCL>/2
	LDB'TYPE  DEV,LINE
	.ENDM

;Define interface dependent part for type A interface

.IF DF LHALNS
	.MACRO	LDBA  DEV,LINE
.IF NDF LHALDB
  LHALDB==!L'DEV'.'LINE
.ENDC
W  LDHARS,$$$R;			;Device receiver control status register
W  LDHARB,$$$R+2;		;Device receiver data buffer
W  LDHAPR,$$$R+2;		;Device parameter control status register
W  LDHAXS,$$$R+4;		;Device transmitter control status register
W  LDHAXB,$$$R+6;		;Device transmitter data buffer
W  LDHAPL,$$$P*40		;Interrupt priority level
W  LDHASB,L'DEV'.'LINE+LDHASX;	;Pointer to beginning of input sector storage
W  LDHASE,L'DEV'.'LINE+LDHASX+<2*$$$X>; End of input sectors
W  LDHAST,L'DEV'.'LINE+LDHASX;	;Input sector storage taker
W  LDHAQB,L'DEV'.'LINE+LDHAQX;	;Pointer to beginning of output queue
W  LDHAQE,L'DEV'.'LINE+LDHAQX+<2*<$$$X+1>>; End of output queue
W  LDHAQT,L'DEV'.'LINE+LDHAQX;	;Output queue taker (1st frame in queue)
W  LDHAQN,L'DEV'.'LINE+LDHAQX;	;Output queue next to send pointer
W  LDHAQP,L'DEV'.'LINE+LDHAQX;	;Output queue putter (1st available slot)
W  LDHAKB,L'DEV'.'LINE+LDHAKX;	;Pointer to beginning of INTERRUPT RING
W  LDHAKE,L'DEV'.'LINE+LDHAKX+<2*<$$$X+1>>; End of INTERRUPT RING
W  LDHAKT,L'DEV'.'LINE+LDHAKX;	;INTERRUPT RING taker (1st frame in queue)
W  LDHAKP,L'DEV'.'LINE+LDHAKX;	;INTERRUPT RING putter (1st available slot)
B  LDHAMX,$$$X;			;Maximum number of frames outstanding
B  LDHAMD,<^C<<2*$$$X>-1>>;	; Bit mask for modulus arith on REC & ACK
L  LDHAFC;			;First location to clear on startup
W  LDHAFG,0;			;Flag word
W  LDHAEA,0;			;Error count - bad ACK received
W  LDHAED,0;			;Error count - line take down timer expired
W  LDHAEI,0;			;Error count - lost input (idle too long)
W  LDHAEL,0;			;Error count - lost output interrupt (IRMA)
W  LDHAEN,0;			;Error count - bad neighbor in reset pattern
W  LDHAEO,0;			;Error count - input overrun
W  LDHAEP,0;			;Error count - hardware output error
W  LDHASC,0;			;Shift count for input byte synchronization
W  LDHAIS,0;			;Input state
W  LDHAOS,0;			;Output state
W  LDHAIF,0;			;Input frame pointer
W  LDHAIW,0;			;Input word pointer
W  LDHAOW,0;			;Output word pointer
W  LDHAIL,0;			;Input longitudinal checksum word
W  LDHAID,0;			;Input diagonal checksum word
W  LDHAOL,0;			;Output longitudinal checksum word
W  LDHAOD,0;			;Output diagonal checksum word
M  LDHASX,2*$$$X;		;Input sector storage area
M  LDHAQX,2*<$$$X+1>;		;Output frame queue
M  LDHAKX,2*<$$$X+1>;		;INPUT INTERRUPT LEVEL TO MAIN PROGRAM RING
B  LDHAIB,0;			;Input high byte of word
B  LDHAOB,0;			;Output low byte of word
B  LDHAIC,0;			;Input word count
B  LDHAOC,0;			;Output word count
B  LDHACK,0;			;ACK number (last record read)
B  LDHAIA,0;			;ACK received on input
B  LDHALA,0;			;Last record ACK'd & removed from output queue
B  LDHAOR,0;			;Next record number to output
B  LDHAIX,0;			;Input word left-over bit storage
B  LDHAFR,0;			;Output queue frame count
B  LDHAUA,0;			;Unsent ACK count
B  LDHATD,0;			;Timer - retransmission state take down
B  LDHATI,0;			;Timer - idle input master reset
B  LDHATR,0;			;Timer - ignore reset pattern
L  LDHALC;			;Last location + 2 to clear on startup
LDHACZ==!<LDHALC-LDHAFC+1>/2
	.ENDM
.ENDC		;.IF DF LHALNS

;Define interface dependent part for type B interface

.IF DF LHBLNS
	.MACRO	LDBB  DEV,LINE
.IF NDF LHBLDB
  LHBLDB==!L'DEV'.'LINE
.ENDC
W  LDHBRS,$$$R;			;Device receiver function register
W  LDHBRB,$$$R+2;		;Device receiver data buffer
W  LDHBXS,$$$R+10;		;Device transmitter function register
W  LDHBXB,$$$R+12;		;Device transmitter data buffer
W  LDHBPL,$$$P*40		;Interrupt priority level
W  LDHBFN,$$$PN*$BIT08;		;Function byte (low) and DCP port number (hi)
W  LDHBVC,$$$VC			;Interrupt vector for DCP port
W  LDHBSB,L'DEV'.'LINE+LDHBSX;	;Pointer to beginning of input sector storage
W  LDHBSE,L'DEV'.'LINE+LDHBSX+<2*$$$X>; End of input sectors
W  LDHBST,L'DEV'.'LINE+LDHBSX;	;Input sector storage taker
W  LDHBQB,L'DEV'.'LINE+LDHBQX;	;Pointer to beginning of output queue
W  LDHBQE,L'DEV'.'LINE+LDHBQX+<2*<$$$X+1>>; End of output queue
W  LDHBQT,L'DEV'.'LINE+LDHBQX;	;Output queue taker (1st frame in queue)
W  LDHBQN,L'DEV'.'LINE+LDHBQX;	;Output queue next to send pointer
W  LDHBQP,L'DEV'.'LINE+LDHBQX;	;Output queue putter (1st available slot)
W  LDHBKB,L'DEV'.'LINE+LDHBKX;	;Pointer to beginning of interrupt ring
W  LDHBKE,L'DEV'.'LINE+LDHBKX+<2*<$$$X+1>>; End of interrupt ring
W  LDHBKT,L'DEV'.'LINE+LDHBKX;	;Interrupt ring taker (1st frame in queue)
W  LDHBKP,L'DEV'.'LINE+LDHBKX;	;Interrupt ring putter (1st available slot)
B  LDHBMX,$$$X;			;Maximum number of frames outstanding
B  LDHBMD,<^C<<2*$$$X>-1>>;	;Bit mask for modulus arith on REC & ACK
L  LDHBFC;			;First location to clear on startup
L  LDHAFG;			;Label for flag word (used by LKHPK2)
W  LDHBFG,0;			;Flag word
W  LDHBEA,0;			;Error count - bad ACK received
W  LDHBEC,0			;Error count - DCP device error
W  LDHBED,0;			;Error count - line take down timer expired
W  LDHBEI,0;			;Error count - lost input (idle too long)
W  LDHBEL,0;			;Error count - lost output interrupt (IRMA)
W  LDHBEN,0;			;Error count - bad neighbor in reset pattern
W  LDHBEO,0;			;Error count - input overrun
W  LDHBEP,0;			;Error count - hardware output error
W  LDHBLK,0			;Interrupt code lock, 0 = locked, 2 = unlocked
W  LDHBIS,0;			;Input state
W  LDHBOS,0;			;Output state
W  LDHBIF,0;			;Input frame pointer
W  LDHBIW,0;			;Input word pointer
W  LDHBOW,0;			;Output word pointer
W  LDHBIL,0;			;Input longitudinal checksum word
W  LDHBID,0;			;Input diagonal checksum word
W  LDHBOL,0;			;Output longitudinal checksum word
W  LDHBOD,0;			;Output diagonal checksum word
M  LDHBSX,2*$$$X;		;Input sector storage area
M  LDHBQX,2*<$$$X+1>;		;Output frame queue
M  LDHBKX,2*<$$$X+1>;		;Input interrupt level to main program ring
B  LDHBIB,0;			;Input high byte of word
B  LDHBOB,0;			;Output low byte of word
B  LDHBIC,0;			;Input word count
B  LDHBOC,0;			;Output word count
B  LDHBCK,0;			;ACK number (last record read)
B  LDHBIA,0;			;ACK received on input
B  LDHBLA,0;			;Last record ACK'd & removed from output queue
B  LDHBOR,0;			;Next record number to output
B  LDHBIX,0;			;Input word left-over bit storage
B  LDHBFR,0;			;Output queue frame count
B  LDHBUA,0;			;Unsent ACK count
B  LDHBTD,0;			;Timer - retransmission state take down
B  LDHBTI,0;			;Timer - idle input master reset
B  LDHBTR,0;			;Timer - ignore reset pattern
L  LDHBLC;			;Last location + 2 to clear on startup
LDHBCZ==!<LDHBLC-LDHBFC+1>/2
	.ENDM
.ENDC		;.IF DF LHBLNS
.ENDC		;.IF DF LKHNUM
	.PAGE
	.SBTTL	ASYNC INTERFACE DATA BLOCKS (ADB'S)

;DEFINE MACRO USED TO GENERATE COMMON PART OF EACH ADB

	.MACRO	XADB  UNIT,TYPE
	.PSECT	ADB,RW,D,LCL,REL,CON
	.EVEN
OS=!0
ADB'UNIT'$::
A'UNIT'$'TYPE=!ADB'UNIT'$
.IF NDF AS'TYPE'ADB
  AS'TYPE'ADB==!ADB'UNIT'$
.ENDC
W  ADOUTP,AS'TYPE'OUT#		;ADDRESS OF OUTPUT SUBROUTINE
W  ADFUNC,AS'TYPE'FNC#		;ADDRESS OF FUNCTION SUBROUTINE
W  ADINIT,AS'TYPE'INT#		;ADDRESS OF INITIALIZE SUBROUTINE
W  ADINDX,$$$X*400		;LINE INDEX FOR FIRST LINE ON UNIT (POSITIONED
				;  FOR THE TERMINAL SERVICE INTERRUPT RING)
	.IRP	UNTX,<\UNIT+1>
.IF DF A'UNTX'$'TYPE
  $$$=!A'UNTX'$'TYPE
.IFF
  $$$=!0
.ENDC
W  ADNEXT,$$$;			;ADDRESS OF ADB FOR NEXT INTERFACE OF SAME
	.ENDM			;  TYPE
B  ADSTS1,$$$AS;		;STATUS BYTE
B  ADMAXI,$$$M;			;HIGHEST VALID INDEX FOR UNIT + 1
	ADB'TYPE  UNIT
	.ENDM

;DEFINE INTERFACE DEPENDENT PART FOR TYPE A INTERFACE (DL11/DLV11)

.IF DF TRANUM
	.MACRO	ADBA  UNIT
W  ADARSR,$$$R;			;ADDRESS OF RECEIVE STATUS REGISTER
W  ADARBF,$$$R+2;		;ADDRESS OF RECEIVE BUFFER
W  ADAXSR,$$$R+4;		;ADDRESS OF XMIT STATUS REGISTER
W  ADAXBF,$$$R+6;		;ADDRESS OF XMIT BUFFER
	.ENDM
.ENDC

;DEFINE INTERFACE DEPENDENT PART FOR TYPE B INTERFACE (DZ11/DZV11)

.IF DF TRBNUM
	.MACRO	ADBB  UNIT
W  ADBCSR,$$$R;			;ADDRESS OF CONTROL AND STATUS REGISTER (R/W)
L  ADBRBF			;ADDRESS OF RECEIVE BUFFER (RO)
W  ADBLPR,$$$R+2;		;ADDRESS OF LINE PARAMETER REGISTER (WO)
W  ADBTCR,$$$R+4;		;ADDRESS OF XMIT CONTROL REGISTER (R/W)
L  ADBMSR			;ADDRESS OF MODEM STATUS REGISTER (RO)
W  ADBTDR,$$$R+6;		;ADDRESS OF XMIT DATA REGISTER (WO)
W  ADBBRK,$$$R+7;		;ADDRESS OF BREAK REGISTER (WO)
B  ADBBRB,0;			;CURRENT BREAK BITS
BX        0
W  ADBMSB,0;			;CURRENT MODEM STATUS BITS
M  ADBFLG,8.;			;Output available flag byte
M  ADBBFR,8.;			;Output character buffer
	.ENDM
.ENDC

;DEFINE INTERFACE DEPENDENT PART FOR TYPE C INTERFACE (DH11)

.IF DF TRCNUM
	.MACRO	ADBC  UNIT
W  ADCSCR,$$$R;			;ADDRESS OF SYSTEM CONTROL REGISTER
W  ADCRCR,$$$R+2;		;ADDRESS OF RECEIVED CHARACTER REGISTER
W  ADCLPR,$$$R+4;		;ADDRESS OF LINE PARAMETER REGISTER
W  ADCCAR,$$$R+6;		;ADDRESS OF CURRENT ADDRESS REGISTER
W  ADCBCR,$$$R+10;		;ADDRESS OF BYTE COUNT REGISTER
W  ADCBAR,$$$R+12;		;ADDRESS OF BUFFER ACTIVE REGISTER
W  ADCBKR,$$$R+14;		;ADDRESS OF BREAK CONTROL REGISTER
W  ADCSSR,$$$R+16;		;ADDRESS OF SILO STATUS REGISTER
W  ADCCSR,$$$X;			;ADDRESS OF DATA SET CONTROL AND STATUS
				;  REGISTER (CSR)
W  ADCLSR,$$$X+2;		;ADDRESS OF DATA SET LINE STATUS REGISTER (LSR)
W  ADCBAX,0			;SOFTWARE LINE ENABLE BITS
	.ENDM
.ENDC

;DEFINE INTERFACE DEPENDENT PART FOR TYPE D INTERFACE (INFOTRON SUPER-MUX)

.IF DF TRDNUM
	.MACRO	ADBD  UNIT
W  ADDRS,$$$R;			;RECEIVER STATUS
W  ADDRB,$$$R+2;		;RECEIVER BUFFER
W  ADDPR,$$$R+2;		;PARAMETER REGISTER
W  ADDTS,$$$R+4;		;TRANSMITTER STATUS
W  ADDTB,$$$R+6;		;TRANSMITTER BUFFER
W  ADDLNX,$$$X;			;line index on mux
W  ADDIMB,ADIMSX+ADB'UNIT'$;	;POINTER TO THE BEGINNING OF BUFFER
W  ADDIME,ADIMEX+ADB'UNIT'$;	;POINTER TO THE END OF THE BUFFER
W  ADDPSL,$$$L*40;		;THE INTERRUPT LEVEL OF THIS ADB'S HANDLER
W  ADDOSR,A'UNIT'OI;		;THE OUTPUT SERVICE ROUTINE ADDRESS
W  ADDPRB,ADDBUG+ADB'UNIT'$	;**DEBUG**
W  ADDPRE,ADDDBE+ADB'UNIT'$	;**DEBUG**
L  ADDFTC;			;THE FIRST LOCATION TO CLEAR ON STARTUP
W  ADDABT,0;			;THE ABORT MESSAGE COUNTER
W  ADDBLN,0;			;Bad line number from supermux
W  ADDLPA,0;			;Local packet address
W  ADDCDN,0;			;COUNT DOWN OF CHARACTERS LEFT
W  ADDCRI,0;			;The input CRC
W  ADDCRO,0;			;The output CRC
W  ADDCLC,0;			;CURRENT LINE COUNT (MARKER MESSAGE)
W  ADDCLN,0;			;CURRENT LINE NUMBER OF INFOTRON MUX
W  ADDCPK,0;			;CURRENT PACKET NUMBER
W  ADDCRC,0;			;CRC ERROR COUNTER
W  ADDCTT,0;			;CHARACTER COUNT, TOTAL
W  ADDFLG,0;			;ADB FLAG WORD
W  ADDTCL,0;			;The transmit clock loss counter
W  ADDRCL,0;			;The receive clock loss counter
W  ADDFPK,0;			;FIRST PACKET IN CHAIN
W  ADDFCP,0;			;First control packet
W  ADDGLP,0;			;GARBAGE PACKET COUNTER
W  ADDHLE,0;			;HIGH SPEED LINE ERROR COUNTER
W  ADDIBO,0;			;INPUT BUFFER OVERFLOW COUNTER
W  ADDIMI,0;			;BUFFER IN POINTER
W  ADDIMO,0;			;BUFFER OUT POINTER
W  ADDIP,0;			;IN POINTER
W  ADDOP,0;			;OUT POINTER
W  ADDIST,0;			;INPUT STATE
W  ADDOST,0;			;OUTPUT STATE
W  ADDIC1,0;			;The first input character
W  ADDIC2,0;			;The second input character
W  ADDTBL,0;			;Table pointer into P and R tables
W  ADDCCT,0;			;LOCAL CHARACTER COUNTER (MAIN)
W  ADDMRK,0;			;THE MARKER MESSAGE (MAIN)
W  ADDNFG,0;			;THE NAK MESSAGE FLAGS
W  ADDOC,0;			;OUTPUT COUNT
W  ADDOVR,0;			;OVERRUN ERROR COUNTER
W  ADDPIP,0;			;PACKET IN PROGRESS POINTER
W  ADDPKI,0;			;PACKET IN POINTER
W  ADDOPP,0;			;(Output interrupt) packet pointer
W  ADDOTP,0;			;Output tail pointer (Linked list)
W  ADDOHP,0;			;Output head pointer (Linked list)
W  ADDATP,0;			;Output ack tail pointer (Linked list)
W  ADDAHP,0;			;Output ack head pointer (Linked list)
W  ADDPTU,0;			;Number of packets we can use
W  ADDPHE,0;			;Number of phase errors we have had
W  ADDLBA,0;			;Local buffer address (Pseudo 12k buffer)
W  ADDPPT,0;			;(MAIN) PACKET POINTER
W  ADDRBA,0;			;REMOTE BUFFER ADDRESS
W  ADDPTZ,0;			;PACKET TO ZAP
W  ADDTCT,0;			;TOTAL CHARACTER COUNT
W  ADDLCT,0;			;Local count of characters in current packet
B  ADDTSY,0;			;"Sync loss" timer byte
BX        0
W  ADDPRI,0;			;**DEBUG**
M  ADDBUG,20*2;			;**DEBUG**
L  ADDDBE;			;**DEBUG**
M  ADIMSX,40.*2;		;CIRCULAR BUFFER FOR INTERRUPT SERVICE
L  ADIMEX;			;LAST WORD OF BUFFER + 2
L  ADDLTC;			;LAST WORD TO CLEAR ON STARTUP + 2
	.ENDM
.ENDC
	.PAGE
;DEFINE INTERFACE DEPENDENT PART FOR TYPE E INTERFACE (INFOTRON SUPER-MUX)

.IF DF TRENUM
	.MACRO	ADBE  UNIT
W  ADERS,$$$R;			;RECEIVER STATUS
W  ADERB,$$$R+2;		;RECEIVER BUFFER
W  ADEPR,$$$R+2;		;PARAMETER REGISTER
W  ADETS,$$$R+4;		;TRANSMITTER STATUS
W  ADETB,$$$R+6;		;TRANSMITTER BUFFER
W  ADELNX,$$$X;			;line index on mux
W  ADEIMB,ADESIM+ADB'UNIT'$;	;POINTER TO THE BEGINNING OF BUFFER
W  ADEIME,ADEEIM+ADB'UNIT'$;	;POINTER TO THE END OF THE BUFFER
W  ADEPSL,$$$L*40;		;THE INTERRUPT LEVEL OF THIS ADB'S HANDLER
W  ADEOSR,A'UNIT'OI;		;THE OUTPUT SERVICE ROUTINE ADERESS
W  ADEPRB,ADEBUG+ADB'UNIT'$	;**DEBUG**
W  ADEPRE,ADEDBE+ADB'UNIT'$	;**DEBUG**
L  ADEFTC;			;THE FIRST LOCATION TO CLEAR ON STARTUP
W  ADEABT,0;			;THE ABORT MESSAGE COUNTER
W  ADEBLN,0;			;Bad line number from supermux
W  ADELPA,0;			;Local packet ADEress
W  ADECDN,0;			;COUNT DOWN OF CHARACTERS LEFT
W  ADECLC,0;			;CURRENT LINE COUNT (MARKER MESSAGE)
W  ADECLN,0;			;CURRENT LINE NUMBER OF INFOTRON MUX
W  ADECPK,0;			;CURRENT PACKET NUMBER
W  ADECRC,0;			;CRC ERROR COUNTER
W  ADECTT,0;			;CHARACTER COUNT, TOTAL
W  ADEFLG,0;			;ADB FLAG WORD
W  ADETCL,0;			;The transmit clock loss counter
W  ADERCL,0;			;The receive clock loss counter
W  ADEFPK,0;			;FIRST PACKET IN CHAIN
W  ADEFCP,0;			;First control packet
W  ADEGLP,0;			;GARBAGE PACKET COUNTER
W  ADEHLE,0;			;HIGH SPEED LINE ERROR COUNTER
W  ADEIBO,0;			;INPUT BUFFER OVERFLOW COUNTER
W  ADEIMI,0;			;BUFFER IN POINTER
W  ADEIMO,0;			;BUFFER OUT POINTER
W  ADEIP,0;			;IN POINTER
W  ADEOP,0;			;OUT POINTER
W  ADEIST,0;			;INPUT STATE
W  ADEOST,0;			;OUTPUT STATE
W  ADETBL,0;			;Table pointer into P and R tables
W  ADECCT,0;			;LOCAL CHARACTER COUNTER (MAIN)
W  ADEMRK,0;			;THE MARKER MESSAGE (MAIN)
W  ADENFG,0;			;THE NAK MESSAGE FLAGS
W  ADEOC,0;			;OUTPUT COUNT
W  ADEOVR,0;			;OVERRUN ERROR COUNTER
W  ADEPIP,0;			;PACKET IN PROGRESS POINTER
W  ADEPKI,0;			;PACKET IN POINTER
W  ADEOPP,0;			;(Output interrupt) packet pointer
W  ADEOTP,0;			;Output tail pointer (Linked list)
W  ADEOHP,0;			;Output head pointer (Linked list)
W  ADEATP,0;			;Output ack tail pointer (Linked list)
W  ADEAHP,0;			;Output ack head pointer (Linked list)
W  ADEPTU,0;			;Number of packets we can use
W  ADEPHE,0;			;Number of phase errors we have had
W  ADELBA,0;			;Local buffer ADEress (Pseudo 12k buffer)
W  ADEPPT,0;			;(MAIN) PACKET POINTER
W  ADERBA,0;			;REMOTE BUFFER ADERESS
W  ADEPTZ,0;			;PACKET TO ZAP
W  ADETCT,0;			;TOTAL CHARACTER COUNT
W  ADELCT,0;			;Local count of characters in current packet
B  ADETSY,0;			;"Sync loss" timer byte
BX        0
W  ADEPRI,0;			;**DEBUG**
M  ADEBUG,20*2;			;**DEBUG**
L  ADEDBE;			;**DEBUG**
M  ADESIM,40.*2;		;CIRCULAR BUFFER FOR INTERRUPT SERVICE
L  ADEEIM;			;LAST WORD OF BUFFER + 2
L  ADELTC;			;LAST WORD TO CLEAR ON STARTUP + 2
	.ENDM
.ENDC

;Define interface dependent part for type F interface (Nexilis 8086 IO
;  processor)

.IF DF TRFNUM
	.MACRO	ADBF  UNIT
W  ADFRFR,$$$R			;Receive function register
W  ADFRDR,$$$R+2		;Receive data register
W  ADFXFR,$$$R+10		;Xmit function register
W  ADFXDR,$$$R+12		;Xmit data register
W  ADFVEC,$$$VC			;Address of vector
	.ENDM
.ENDC
	.PAGE
	.SBTTL	SOCKET DATA BLOCKS (SDB'S)

;DEFINE MACRO FOR GENERATING EACH SOCKET DATA BLOCK

	.MACRO	XSDB  DV,DX,DEV,SOC,TYPE
NUMSOC=!NUMSOC+1

.IF NE SOC
	.PSECT	SX,RW,D,LCL,REL,CON
  .IF EQ SOC-1
    .IF DF DX'DEV'$0
	.WORD	DX'DEV'$0
    .IFF
	.WORD	0
    .ENDC
    DX'DEV'SX::
  .ENDC
  .IF EQ .PASS2
    .IF IDN <LK>,<DV>
      MXLKSX==!.
    .ENDC
  .ENDC
	.WORD	DX'DEV'$'SOC
.ENDC

	.PSECT	SDB,RW,D,LCL,REL,CON
	.EVEN
OS=!0
DX'DEV'$'SOC::
W  SDLINK,0			;Address of linked SDB
B  SDPMAX,0			;Maximum number of packets which may be
				;  buffered for this socket
B  SDSOC ,SOC			;Socket number on device
W  SDDDB ,DX'DEV'$		;Address of DDB for device
W  SDDBUG,0			;Debug or trace data
L  SDCBGN			;First word to clear on startup
W  SDSTS1,0			;Device status word
W  SDPKDH,0			;Head pointer for packet destionation list
W  SDPKDT,0			;Tail pointer for packet destination list
W  sdpkcp,0			;Pointer to current packet (from DST list)
W  SDPKSP,0			;Pointer to packet SRC list
B  SDPCNT,0			;Number of packets which are buffered for
				;  this socket **** MUST BE EVEN BYTE! ****
B  SDXCNT,0			;Excess packet count (packets buffered for this
				;  SDB but included in SDPCNT for the linked
				;  SDB)
B  SDSDID,0			;device I.D. for linked DEVICE
B  SDSDSC,0			;Socket number for linked device
W  SDREQL,0			;Request link word
B  SDREQB,0			;Request bits
B  SDRSMC,0			;Resume count
L  SDCEND			;Last word to clear on startup + 2
SDCSIZ==!<SDCEND-SDCBGN>/2
	SDB'DV	DEV,SOC,TYPE
	.ENDM
NUMSOC=!0

;DEFINE MACROS FOR GENERATING THE DEVICE DEPENDENT PARTS OF THE SDB'S

;STATUS DEVICE DEVICE DEPENDENT PART

	.MACRO	SDBST  DEV,SOC,TYPE
L  SDSTFC			;FIRST WORD TO CLEAR ON STARTUP
W  SDSTSS,0			;STATUS WORD
W  SDSTID,0			;Input dispatch address
B  SDSTCC,0			;Command character
B  SDSTPL,0			;Priviledge level of connected device
B  SDSTSC,0			;Place to save character on failure return from
				;  PUTCHR
BX        0
W  SDSTR1,0			;LEVEL 1 SUBROUTINE RETURN ADDRESS
W  SDSTSR,0			;Return address for failure return from PUTCHR
W  SDSTD1,0			;Data word 1
W  SDSTD2,0			;Data word 2
W  SDSTD3,0			;Data word 3
W  SDSTD4,0			;Data word 4
W  SDSTS3,0			;Place to save R3
L  SDSTCF			;FIRST WORD TO CLEAR AT COMMAND END
B  SDSTVP,0			;Value pointer
B  SDSTER,0			;Error code
W  SDSTV1,0			;First argument value
W  SDSTV2,0			;Second argument value
W  SDSTV3,0			;Third argument value
L  SDSTLC			;LAST WORD TO CLEAR ON STARTUP OR COMMAND
				;  END + 2
SDSTCZ==!<SDSTLC-SDSTFC+1>/2
SDSTCY==!<SDSTLC-SDSTCF+1>/2
	.ENDM

;TERMINAL DEVICE DEPENDENT PART

.IF NE TR.NUM
	.MACRO	SDBTR  DEV,SOC,TYPE
W  SDTRS0,$$$S;			;"PURE" STATUS WORD 0
W  SDTRBR,$$$B;			;DEFAULT BAUD RATES
B  SDTRTT,$$$T;			;DEFAULT TERMINAL TYPE FOR TERMINAL
.IF EQ ..SAT
  B  SDTRPC,$$$CL;		;PRIV. CLASS
  B  SDTRCX,$$$C;		;COMMAND DECODER INDEX
  B  SDTRTP,$$$P;		;DEFAULT TERMINAL PROFILE FOR TERMINAL
.IFF
  B  SDTRXC,0;			;TRANSLATION CODE
.ENDC
W  SDTRAD,$$$ADB;		;ADDRESS OF ADB FOR ASYNC INTERFACE
L  SDTRFC			;FIRST TO CLEAR ON STARTUP
W  SDTRIP,0			;Packet pointer for input hold list
W  SDTRCP,0			;Packet pointer for command input list
W  SDTROD,0			;OUTPUT READY DISPATCH ADDRESS
W  SDTRS1,0			;IMPURE STATUS WORD 1
W  SDTRS2,0			;IMPURE STATUS WORD 2
W  SDTRS3,0			;IMPURE STATUS WORD 3
W  SDTRS4,0			;IMPURE STATUS WORD 4
W  SDTRS5,0			;IMPURE STATUS WORD 5
W  SDTRS6,0			;IMPURE STATUS WORD 6
B  SDTROS,0			;OUTPUT STATE
B  SDTRBS,0			;Active break character set bits
B  SDTRIL,0			;Input buffer limit value
B  SDTRIC,0			;Input buffer character count

.IF EQ ..SAT
  L  SDTRLP			;WARNING *** The following 9 bytes must be
				;  in the same order as the entries in the
				;  PRFPNT table in TRMT!!
  B  SDTRBX,0			;Current break character set bits
  B  SDTRDL,0			;Delete character
  L  SDTRSL			;Start of list of special echo characters
  B  SDTRLX,0			;Line delete character
  B  SDTRSO,0			;Suppress output character
  B  SDTRRE,0			;Line retype character
  B  SDTRHI,0			;Hard interrupt character
  B  SDTRSI,0			;Soft interrupt character
  B  SDTRCI,0			;Command interrupt character
  B  SDTRSR,0			;Status request character
  L  SDTRSE			;Last of special echo characters + 1
  B  SDTREC,0;			;Error counter

  SDTRSN==!SDTRSE-SDTRSL
.ENDC

L  SDTRLT			;WARNING *** The following 10 bytes must be
				;  in the same order as the entries in the
				;  TYPPNT table in TRMT!!
B  SDTRCD,0			;Fixed carriage return delay constant
B  SDTRCV,0			;Varialbe carriage return delay constant
B  SDTRCM,0			;Min/max carriage return delay constant
B  SDTRHD,0			;Horizontal tab delay constant
B  SDTRBD,0			;Backspace delay constant
B  SDTRLD,0			;Line feed delay constant
B  SDTRVD,0			;Vertical tab delay constant
B  SDTRFD,0			;Fixed form feed delay constant
.IF EQ  ..SAT
  B  SDTRFV,0			;Variable form feed delay constant
  B  SDTRLW,0			;Line width
.IFF
  B  SDTREC,0			;Error count for TYMNET command decoder
  B  SDTRHP,0			;Horizontal position on line
.ENDC
B  SDTRCL,0;			;COUNT OF CHARACTERS PER LINE
BX        0
.IF EQ ..SAT
  B  SDTRVT,0			;Vertical tab spacing
  B  SDTRPG,0			;Page size
  B  SDTRHP,0			;Current horizontal position on line
  B  SDTRVP,0			;Current vertical position on page
.ENDC
B  SDTRSC,0			;2nd level saved character
B  SDTRFP,0			;2nd level filler pointer
B  SDTRSX,0			;1st level saved character
B  SDTRFX,0			;1st level filler pointer
B  SDTRDY,0			;Delay count
B  SDTRBL,0			;Number of bells to output
B  SDTRCT,0			;Current terminal type
.IF EQ ..SAT
  B  SDTRES,0			;Input ESC sequence processing state
  B  SDTRXC,0			;Translation code
.ENDC
B  SDTRCS,0			;Carrier State
W  SDTRC1,0			;Command decoder data word 1
W  SDTRC2,0			;Command decoder data word 2
W  SDTRC3,0			;Command decoder data word 3
W  SDTRC4,0			;Command decoder data word 4
L  SDTRLC			;Last word to clear on startup + 2
SDTRCZ==!<SDTRLC-SDTRFC+1>/2
.IF DF PVC'SOC
W  SDTPVC,PVC'SOC               ;ADDRESS OF PVC STRING
.IFF
W  SDTPVC,0			;, OR NULL (0).
.ENDC
	SDBTR'TYPE  SOC
	.ENDM

;INTERFACE DEPENDENT PARTS OF THE TERMINAL SDB'S

;TYPE A INTERFACE - DL11/DLV11

.IF DF TRANUM
	.MACRO	SDBTRA	DEV,SOC
W  SDTXAP,0;		;Output packet pointer
	.ENDM
.ENDC

;TYPE B INTERFACE - DZ11/DZV11

.IF DF TRBNUM
	.MACRO	SDBTRB	DEV,SOC
B  SDTRXA,$$$LN;		;INDEX ON INTERFACE
BX        0
W  SDTXBP,0;		;Output packet pointer
	.ENDM
.ENDC

;TYPE C INTERFACE - DH11

.IF DF TRCNUM
	.MACRO	SDBTRC	DEV,SOC
B  SDTRXA,$$$LN;		;INDEX ON INTERFACE
B  SDTRCC,0			;CURRENT OUTPUT CHARACTER BUFFER
	.ENDM
.ENDC

;TYPE D INTERFACE - INFOTRON SUPER MUX

.IF DF TRDNUM
	.MACRO	SDBTRD	DEV,SOC
B  SDDLIN,$$$LN;		;The line number of this port
B  SDDCHR,0;			;Where to save the held character
L  SDDFTC;			;FIRST LOCATION TO CLEAR
W  SDDBTW,0;			;BIT WORD FOR MARKER MESSAGES
W  SDDCCT,0;			;COUNT LEFT TO DO
W  SDDCPP,0;			;CURRENT POINTER IN PACKET
W  SDDFLG,0;			;SDB FLAG WORD
W  SDDMOP,0;			;MARKER MESSAGE POINTER
W  SDDPAD,0;			;PACKET ADDRESS
W  SDDPCT,0;			;PACKET CHARACTER COUNT
W  SDDUT1,0;			;TIMER FOR OUTGOING CHARACTERS (LOW ORDER)
W  SDDUT2,0;			;"			"      (HIGH ORDER)
L  SDDLTC;			;LAST TO CLEAR + 2
	.ENDM
.ENDC
;TYPE E INTERFACE - INFOTRON SUPER MUX

.IF DF TRENUM
	.MACRO	SDBTRE	DEV,SOC
B  SDELIN,$$$LN;		;The line number of this port
B  SDECHR,0;			;Where to save the held character
L  SDEFTC;			;FIRST LOCATION TO CLEAR
W  SDEBTW,0;			;BIT WORD FOR MARKER MESSAGES
W  SDECCT,0;			;COUNT LEFT TO DO
W  SDECPP,0;			;CURRENT POINTER IN PACKET
W  SDEFLG,0;			;SDB FLAG WORD
W  SDEMOP,0;			;MARKER MESSAGE POINTER
W  SDEPAD,0;			;PACKET ADDRESS
W  SDEPCT,0;			;PACKET CHARACTER COUNT
W  SDEUT1,0;			;TIMER FOR OUTGOING CHARACTERS (LOW ORDER)
W  SDEUT2,0;			;"			"      (HIGH ORDER)
L  SDELTC;			;LAST TO CLEAR + 2
	.ENDM
.ENDC

.IF DF TRFNUM
	.MACRO	SDBTRF  DEV,SOC
B  SDTRXA,$$$LN;		;Index on interface
BX        0
W  SDTXFP,0;			;Index on interface
	.ENDM
.ENDC
.ENDC

;OTHER TERMINAL DEVICES DEVICE DEPENDENT PARTS

.IF DF TX.NUM
	.MACRO	SDBTX  DEV,SOC,TYPE
	.ENDM
.ENDC

.IF DF TY.NUM
	.MACRO	SDBTY  DEV,SOC,TYPE
	.ENDM
.ENDC

.IF DF TZ.NUM
	.MACRO	SDBTZ  DEV,SOC,TYPE
	.ENDM
.ENDC

;LINE PRINTER DEVICE DEPENDENT PART

.IF DF LP.NUM
	.MACRO	SDBLP	DEV,SOC,TYPE
	SDBLP'TYPE  SOC,DEV
	.ENDM

;LINE PRINTER SOCKET DEPENDENT PART - DRIVER TYPE A

.IF DF LPANUM
	.MACRO	SDBLPA  DEV,SOC,TYPE
W  SDPAER,$$$E;			; Device error status register
W  SDPAOR,$$$R;			; Device output status register
W  SDPAOB,$$$R+2;		; Device output buffer
L  SDPAFC			; First word to clear at startup
W  SDPASR,0			; Socket status register
W  SDPASI,0			; Spurious interrupt counter
W  SDPAHZ,0			; Horizontal carriage position
W  SDPASP,0			; Pending spaces for tab simulation
L  SDPALC			; Last word to clear + 2
SDPACZ==!<SDPALC-SDPAFC+1>/2
	.ENDM
.ENDC

;LINE PRINTER DRIVER DEPENDENT PART - DRIVER TYPE B

.IF DF LPBNUM
	.MACRO	SDBLPB  DEV,SOC,TYPE
	.ENDM
.ENDC
.ENDC			;.IF DF LP.NUM

;CARD READER DEVICE DEPENDENT PART

.IF DF CR.NUM
	.MACRO	SDBCR	DEV,SOC,TYPE
	.ENDM
.ENDC

;MAGNETIC TAPE DEVICE DEPENDENT PART

.IF DF MT.NUM
	.MACRO	SDBMT	DEV,SOC,TYPE
	.ENDM
.ENDC

;FLOPPY DISK DEVICE DEPENDENT PART

.IF DF FD.NUM
	.MACRO	SDBFD	DEV,SOC,TYPE
	.ENDM
.ENDC

;LOAD DEVICE DEVICE DEPENDENT PART

.IF DF WD.NUM
	.MACRO	SDBWD	DEV,SOC,TYPE
L  SDWDFC
W  SDWDLK,0			;ADDRESS OF DDB FOR LINK BEING USED
W  SDWDPP,0			;POINTER TO DATA PACKET
W  SDWDTO,0			;THE 1 MINUTE TIMER LOCATION
W  SDWDFG,0			;STATUS FLAG WORD
W  SDWDDP,0			;POINTER TO DATA BYTE
W  SDWDBC,0			;BYTE COUNT
W  SDWDSA,0			;STATE
W  SDWDN1,0			;FIRST HALF OF NAME OF NODE BEING LOADED
W  SDWDN2,0			;SECOND HALF OF NAME OF NODE BEING LOADED
L  SDWDLC
SDWDCZ==!<SDWDLC-SDWDFC+1>/2
	.ENDM
.ENDC

;LINK DEVICE DEPENDENT PART

.IF NE LK.NUM
	.MACRO	SDBLK	DEV,SOC,TYPE
L  SDLKFC			;FIRST WORD TO CLEAR ON STARTUP
W  SDLKLK,0			;SOCKET SEND LIST LINK WORD
W  SDLKFL,0			;SOCKET FLAG LIST LINK WORD
B  SDACNT,0			;SEND-AHEAD COUNT **** MUST BE EVEN BYTE! ****
B  SDLKLV,0			;LINK PRIORITY LEVEL *** MUST FOLLOW SDACNT -
				;  SOME ROUTINES REFERENCE SDACNT AS A WORD AND
				;  EXPECT THIS BYTE TO BE THE HIGH ORDER
				;  HALF!! ***
B  SDFCNT,0			;FLAG COUNT **** MUST BE EVEN BYTE! ****
B  SDLKXX,0			;DUMMY (THIS BYTE IS USED BY SOME OF THE LINK
				;  TYPE DEPENDENT ROUTINES)
L  SDLKLC			;LAST WORD TO CLEAR ON STARTUP + 2
SDLKCZ==!<SDLKLC-SDLKFC+1>/2
	SDBLK'TYPE  DEV,SOC
	.ENDM

;LINK TYPE DEPENDENT PARTS

;LINK TYPE A

.IF DF LKANUM
	.MACRO	SDBLKA  DEV,SOC
	.ENDM
.ENDC

;LINK TYPE B

.IF DF LKBNUM
	.MACRO	SDBLKB  DEV,SOC
	.ENDM
.ENDC

;LINK TYPE C

.IF DF LKCNUM
	.MACRO	SDBLKC  DEV,SOC
	.ENDM
.ENDC

;LINK TYPE D

.IF DF LKDNUM
	.MACRO	SDBLKD  DEV,SOC
	.ENDM
.ENDC

;LINK TYPE E

.IF DF LKENUM
	.MACRO	SDBLKE	DEV,SOC
L  SDLEFC			; 1st word to clear on startup
W  SDLES1,0			; PACKET LEVEL IMPURE STATUS WORD
W  SDLEBP,0			; ERROR COUNT - BAD X.25 PACKET TYPE
B  SDLEPR,0			; P(R) for logical channel
B  SDLEPS,0			; P(S) for logical channel
B  SDLEVR,0			; Saved P(R) from last numbered packet
B  SDLERR,0			; PENDING RR COUNT FOR CHANNEL
L  SDLELC			; Last word to clear on startup
SDLECZ==!<SDLELC-SDLEFC+1>/2
	.ENDM
.ENDC

;LINK TYPE F

.IF DF LKFNUM
	.MACRO	SDBLKF	DEV,SOC
L  SDLFFC			;FIRST LOCATION TO CLEAR ON START-UP
W  SDLFBI,0			;BLOCK MODE-TO HOST-COUNT
W  SDLFI0,0			;BLOCK MODE-TO HOST-ADDRESS-LOW ORDER PART
W  SDLFI1,0			;BLOCK MODE-TO HOST-ADDRESS-HIGH ORDER PART
W  SDLFXF,0			;BLOCK MODE-TO HOST-AMOUNT ACTUALLY INPUT
M  SDLFVH,4			;BLOCK MODE-TO HOST-INPUT HOLD BUFFER
B  SDLFVC,0			;BLOCK MODE-TO HOST-INPUT HOLD BUFFER COUNT
B  SDLFQN,0			;DIALOG NUMBER FOR CONNECTION PROTOCOL
W  SDLFBO,0			;BLOCK MODE-FROM HOST-COUNT
W  SDLFO0,0			;BLOCK MODE-FROM HOST-ADDRESS-LOW ORDER PART
W  SDLFO1,0			;BLOCK MODE-FROM HOST-ADDRESS-HIGH ORDER PART
W  SDLFBL,0			;BLOCK MODE-FROM HOST-LIST LINK WORD
W  SDLFRQ,0			;MESSAGE REQUEST BITS
W  SDLFS1,0			;HOST PORT STATUS REGISTER
W  SDLFAX,0			;PACKET POINTER FOR SUPERVISOR DIALOG
L  SDLFLC			;LAST LOCATION + 2 TO CLEAR ON START-UP
SDLFCZ==!<SDLFLC-SDLFFC+1>/2
	.ENDM
.ENDC

;LINK TYPE G

.IF DF LKGNUM
	.MACRO	SDBLKG	DEV,SOC
L  SDLGFC			; 1st word to clear on startup
W  SDLGS1,0			; PACKET LEVEL IMPURE STATUS WORD
W  SDLGBP,0			; ERROR COUNT - BAD X.25 PACKET TYPE
W  SDLGPH,0			; Packet holding list head
W  SDLGPT,0			; Packet holding list tail
B  SDLGPR,0			; P(R) for logical channel
B  SDLGPS,0			; P(S) for logical channel
B  SDLGVR,0			; Saved P(R) from last numbered packet
B  SDLGRR,0			; PENDING RR COUNT FOR CHANNEL
L  SDLGLC			; Last word to clear on startup
SDLGCZ==!<SDLGLC-SDLGFC+1>/2
	.ENDM
.ENDC

;LINK TYPE H

.IF DF LKHNUM
	.MACRO	SDBLKH	DEV,SOC
L  SDLHFC			;FIRST LOCATION TO CLEAR ON STARTUP
.IF EQ ..SAT			;DON'T NEED NEXT WORD IF SIMPLE TYMSAT
  W  SDLHSC,0			;ADDRESS OF SAVED CONNECT PACKET
.ENDC
W  SDLHLD,0			;ADDRESS OF LINKED LDB
B  SDLHCN,0			;CHANNEL NUMBER
B  SDLHSP,0			;CIRCUIT SPEED
W  SDLHS1,0			;IMPURE STATUS WORD 1
.IF DF LHTPC			;Only need these words if have terminal
				;  protocol conversion support
				;WARNING *** These entries must line up with the
				;  corresponding entries in the terminal (TR)
				;  SDB's!  There are exactly 8 words between
				;  the end of the common part of the SDB's and
				;  the start of this area!!
  W  SDLHT1,0			;* SDTRS1 *  Terminal status word 1
  W  SDLHT2,0			;* SDTRS2 *  Terminal status word 2
  W  SDLHT3,0			;* SDTRS3 *  Terminal status word 3
  W  SDLHT4,0			;* SDTRS4 *  Terminal status word 4
  W  SDLHT5,0			;* SDTRS5 *  Terminal status word 5
  B  SDLHLW,0			;* SDTRS6 *  Terminal line width
  B  SDLHHP,0			;* SDTRS6 *  Terminal current horizontal position
  B  SDLHES,0			;* SDTROS *  Input ESC processing state
  B  SDLHBS,0			;* SDTRBS *  Active break set
  B  SDLHIL,0			;* SDTRIL *  Input buffer limit value
  B  SDLHIC,0			;* SDTRIC *  Input buffer character count
  BX        0			;* SDTRBX *  Current break set (Not used here!)
  B  SDLHDL,0			;* SDTRDL *  Terminal delete character
  B  SDLHLX,0			;* SDTRLX *  Terminal line delete character
  B  SDLHSO,0			;* SDTRSO *  Terminal suppress output character
  B  SDLHRE,0			;* SDTRRE *  Terminal line retype character
  B  SDLHHI,0			;* SDTRHI *  Terminal hard interrupt character
  B  SDLHSI,0			;* SDTRSI *  Terminal soft interrupt character
  BX        0
				;End of entries which must match terminal
				;  service entries!!!
.ENDC

W  SDLHS2,0			;IMPURE STATUS WORD 2

.IF DF LHBASE			;ONLY NEED THESE WORDS IF HAVE BASE SUPPORT
  W  SDLHVH,0			;HIGH ORDER PART OF INVOICE NUMBER
  W  SDLHVL,0			;LOW ORDER PART OF INVOICE NUMBER
  W  SDLHI2,0			;HIGH ORDER PART OF INPUT CHARACTER COUNT
  W  SDLHI1,0			;LOW ORDER PART OF INPUT CHARACTER COUNT
  W  SDLHO2,0			;HIGH ORDER PART OF OUTPUT CHARACTER COUNT
  W  SDLHO1,0			;LOW ORDER PART OF OUTPUT CHARACTER COUNT
  W  SDLHPC,0			;PLACE TO ACCUMULATE PROJECT CODE CHARACTERS
  B  SDLHBF,0			;"BUFFER NUMBER"/2 OR "PORT NUMBER"
  BX        0
.ENDC				;END OF BASE SUPPORT ONLY STUFF
L  SDLHLC			;LAST LOCATION + 2 TO CLEAR ON STARTUP
SDLHCZ==!<SDLHLC-SDLHFC+1>/2
	.ENDM
.ENDC

.IFF			;.IF NE LK.NUM
SDLKLV==!0			;DUMMY IF NO LINKS SINCE PKT2 REFERENCES IT!
.ENDC			;.IF NE LK.NUM
	.PAGE
	.SBTTL	PASS2 - INVOKE CONFIG FILE TO DEFINE PARAMTERS AND BUILD THE DATA BLOCKS

;INVOKE THE CONFIGURATION MACRO TO DEFINE PARAMTERS AND TO BUILD THE DATA BLOCKS


	CONFIG

;GENERATE THE TERMINAL DDB IF IT IS NEEDED SINCE THERE IS NOTHING IN THE
;  CONFIG FILE TO DO THIS NICELY!

.IF NE TR.NUM
$$$S=!$D0TRM
$$$PL=!0
	XDDB	TR,T,0,TR.S0,,TRPOKE#,TRRSUM#,TRSSRC#
  TRMTTL==!L..LN
.ENDC
	.PAGE
	.SBTTL	DEFINE GENERAL PARAMETERS

	.PSECT	PURE,RW,D,LCL,REL,CON

;DEFINE SOME PARAMETERS AND CONSTANTS

	.GLOBL	PKTWDS,PKCMAX

.IF NDF MXNPKT			;If no maximum number of packet specified,
  MXNPKT==!77777		;  make this a very large number!
.ENDC

.IF NDF TRMPLM			;If no packet limit for terminal ESC
  TRMPLM==!40.			;  is specified, assume resonable limit
.ENDC

.IF NDF JIFSEC
  JIFSEC==!60.			;Default clock freqency is 60 hertz
.ENDC
	JIFO10==!JIFSEC/10.	;Define symbols for various time intervals
	JIFO4 ==!JIFSEC/4.
	JIFO2 ==!JIFSEC/2.
	JIFX2 ==!JIFSEC*2.
	JIFX8 ==!JIFSEC*8.
	JIFX10==!JIFSEC*10.
	JIFX15==!JIFSEC*15.
	JIFX16==!JIFSEC*16.
	JIFX20==!JIFSEC*20.
	JIFX30==!JIFSEC*30.
	JIFX60==!JIFSEC*60.
	JIF150==!JIFSEC*150.
	JIFM05==!JIFSEC*60.*5.
	JIFM10==!JIFSEC*60.*10.
	JIFM15==!JIFSEC*60.*15.
	MAXTIME==!177777
.IF EQ JIFSEC-60.
  JIFMUL==!3			;MULTIPLIER TO CONVERT FROM 100'S TO 60'S
  JIFDIV==!5			;DIVISOR TO CONVERT FROM 100'S TO 60'S
.ENDC
.IF EQ JIFSEC-50.
  JIFMUL==!1			;MULTIPLIER TO CONVERT FROM 100'S TO 50'S
  JIFDIV==!2			;DIVISOR TO CONVERT FROM 100'S TO 50'S
.ENDC
.IF NDF JIFMUL
	.ERROR ;POWER FREQUENCY NOT DEFINED AS 50 OR 60 HERTZ
.ENDC
.IF NDF CLKREG
  CLKREG==177546		;LINE CLOCK STATUS REGISTER ADDRESS
.ENDC
.IF NDF TRPWRN
  TRPWRN==!11.			;NUMBER OF PACKETS FOR WARNING FOR TERMINALS
.ENDC
	TRPWRX==!<TRPWRN+1>/2
.IF NDF TRPMAX
  TRPMAX==!17			;MAXIMUM NUMBER OF PACKETS FOR TERMINALS
.ENDC

;Define limit parameters for MAKPKT

.IF NDF LKHNUM			;Define normal values if no type H links
  .PLKIL==!0			;For making Kill Packets - only used by MAKKIL
  .PLTRM==!2			;Terminal input packet
  .PLZAP==!3			;Auto-zap routine
  .PLSTP==!5			;Stoppable or don't care routines
  .PLOPT==!15.			;Optional routines
.IFF				;Define special values if have type H link(s)
  .PLKIL==!0			;For making Kill Packets - only used by MAKKIL
  .PLSPR==!1			;For buffering supervisor messages for type
				;  H link
  .PLTRM==!3			;Terminal input packet
  .PLZAP==!12.			;Auto-zap routine
  .PLSTP==!16.			;Stoppable or don't care routines
  .PLOPT==!20.			;Optional routines
.ENDC

;DEFINE SOME PARAMETERS FOR LINKS

VLLK0C==!10.			;VALUE FOR LINK LEVEL 0 FAIRNESS COUNT
VLLK1C==!10.			;VALUE FOR LINK LEVEL 1 FAIRNESS COUNT
VLLKFC==!6.			;VALUE FOR LINK FLAG FAIRNESS COUNT

;GENERATE THE HOST CONNECT LIST POINTER TABLE - EACH ENTRY POINTS TO THE START
;  OF A HOST CONNECT LIST

	.EVEN
.N=!0
HCLTBL::.REPT	.HCL
	.IRP	NN,<\.N>
	.WORD	HST$'NN
	.ENDM
.N=!.N+1
	.ENDR
	.PAGE
	.SBTTL	PURE DATA

	.PSECT	PURE,RW,D,LCL,REL,CON
;	.EVEN

.IF NDF VERNUM			;IF VERSION NUMBER NOT DEFINED
  VERNUM==!250			;  THIS IS VERSION 2
.ENDC

.IF NDF EDTNUM			;If edit number not defined
  EDTNUM==!1			;  This is edit 1
.ENDC

.IF NDF DFTH$$
  DFTHST::.BYTE	0		;NULL DEFAULT HOST NAME
.ENDC

.IF NDF ..MOD			;Check for message of the day
  ..MOD::.BYTE 0
.IFF
 .IF EQ ..MOD-.
  ..MOD::.BYTE 0
 .ENDC
.ENDC
	.PAGE
	.SBTTL	PURE TABLES INDEXED BY NETWORK DEVICE I.D.

	.PSECT	PURE,RW,D,LCL,REL,CON
	.EVEN

;DEFINE MACRO WHICH CONTAINS ALL OF THE DATA FOR THE FOLLOWING TABLES

	.MACRO	DVXX
	DVX	ST,S,4,5	; 1  STATUS DEVICE
	DVX	TR,T,4,5	; 2  USER TERMINAL
.IF EQ ..SAT
	DVX	TX,X,4,5	; 3  AUX TERMINAL
	DVX	TY,Y,4,5	; 4  AUX TERMINAL
	DVX	TZ,Z,4,5	; 5  AUX TERMINAL
.ENDC
	DVX	LP,P,4,5	; 6  LINE PRINTER
.IF EQ ..SAT
	DVX	CR,C,4,5	; 7  CARD READER
	DVX	MT,M,4,5	;10  MAGNETIC TAPE
	DVX	FD,F,4,5	;11  FLOPPY DISK
.ENDC
	DVX	WD,W,4,5	;12  LOAD DEVICE
	.ENDM

;GENERATE TABLE OF NETWORK DEVICE NAMES - INDEXED BY 2 TIMES THE NETWORK
;  DEVICE I.D.

	.MACRO	DVX  DV,D,PWRN,PMAX
	.WORD	"DV
.ID'DV==!.N
.N=!.N+1
	.ENDM

.N=!1
DEVNAM::.WORD	"HS		;FIRST ENTRY IS FOR HOSTS
	DVXX			;REST ARE FOR DEVICES
DEVMAX==!.-DEVNAM

.IDLK==!0

;Generate table of single device specifiers

	.MACRO	DVX  DV,D,PWRN,PMAX
	.BYTE	''D
	.ENDM

DEVLTR::.BYTE	'L		;First is a "link"
	DVXX

;GENERATE TABLE OF DX'S INDEXED BY NETWORK DEVICE I.D.

	.MACRO	DVX  DV,D,PWRN,PMAX
.IF DF DV'.NUM
	.BYTE	.N
  .N=!.N+2
.IFF
	.BYTE	-1
.ENDC
	.ENDM

.N=!0
NIDDX::	.BYTE	-1		;HOST
	DVXX
NIDMAX==!.-NIDDX

;GENERATE TABLE OF WARNING VALUES FOR EACH TYPE OF DEVICE

	.MACRO	DVX  DV,D,PWRN,PMAX
	.BYTE	PWRN
	.ENDM

NIDPWN::.BYTE	4			;VALUE FOR HOSTS
	DVXX

;GENERATE TABLE OF MAXIMUM PACKET COUNTS VALUES FOR EACH TYPE OF DEVICE

	.MACRO	DVX  DV,D,PWRN,PMAX
	.BYTE	PMAX
	.ENDM

NIDPMX::.BYTE	5			;VALUE FOR HOSTS
	DVXX
	.EVEN
	.PAGE
	.SBTTL	DEVICE INDEX (DX) TABLE

	PURE

	.MACRO	DVX  DV,D,PWRN,PMAX
.IF DF DV'.NUM
	.WORD	D'0$
.DX0'D=!.N
.N=!.N+1
.ENDC
	.ENDM

.N=!0
	.EVEN
DXTBL::	DVXX

LKOFS$==!.-DXTBL			;OFFSET FOR FIRST LINK ENTRY

NN=!0
	.REPT	LK.NUM			;ONCE FOR EACH LINK
	.IRP	DEV,<\NN>
	.WORD	L'DEV'$
.DX'DEV'L=!.N
	.ENDM
NN=!NN+1
.N=!.N+1
	.ENDR

MAXDX==!.-DXTBL-2
DXSIZE==!<.-DXTBL>/2
DXTOP==!.-2

;Define symbol for top of SXTBL

	.PSECT	SX,RW,D,LCL,REL,CON

SXTOP::!
	.PAGE
	.SBTTL	COMMAND DECODER TABLES

	PURE

;GENERATE TABLE OF ADDRESSES OF ENTRY TABLES FOR EACH COMMAND DECODER

.N=!0

CMDETB::.IRP	CMD,<NEX,TYM,SAT>
.IF DF C$'CMD
  C.'CMD=!.N
	.WORD	CMD'ENT#
  .N=!.N+2
.ENDC
	.ENDM
	.PAGE
	.SBTTL	AUTO-BAUD RATE DETECT TABLES

	PURE

.IF DF ABR$				;NEED THIS IF ANY LINES HAVE AUTO-
					;  BAUD RATE SPECIFIED

;DEFINE MACRO WHICH DEFINES AN AUTO-BAUD DETECT CLASS
;  PARAMETERS ARE AS FOLLOWS:
;	ABC	N,DET,STR,RST
;  WHERE:
;	N   = AUTO-BAUD RATE NUMBER (AS USED IN THE LINE MACRO IN CONFIG -
;		MUST BE TIGHT MOMOTONIC INCREASING STARTING AT 1)
;	DET = BAUD RATE TO BE USED FOR RATE DETECTION
;	SET = ADDRESS OF SETUP ROUTINE
;	RST = ADDRESS OF RESET ROUTINE

	.MACRO	ABC  N,DET,SET,RST
	TRMLST			;TERMINATE PREVIOUS LIST IF NECESSARY
	.EVEN
RAT$'N:	.WORD	SET'#
	.WORD	R.'DET
	.WORD	RST'#
	.ENDM

	.MACRO	TRMLST
	.MACRO	TRMLST
	.BYTE	377
	.ENDM
	.ENDM

;DEFINE MACRO WHICH DEFINES EACH ENTRY IN THE AUTO-BAUD DETECT TABLES
;  PARAMETERS ARE AS FOLLOWS:
;	AB	RAT,TYP,COD,CHR,MSK,F
;  WHERE:
;	RAT = ACTUAL BAUD RATE CORRESPONDING TO CHARACTER
;	TYP = TERMINAL TYPE OR SECONDARY TABLE NUMBER IF RAT IS BLANK
;	COD = TERMINAL CODE
;	CHR = CHARACTER FOR MATCH
;	MSK = MASK FOR MATCH
;	F   = F IF MUST HAVE FRAMING ERROR, BLANK IF CANNOT HAVE FRAMING
;		ERROR, X IF DON'T CARE

	.MACRO	AB  RAT,TYP,COD,CHR,MSK,FFF
.FLG=!200
.IF IDN <FFF><X>
  .FLG=!000
.ENDC
.IF IDN <FFF><F>
  .FLG=!300
.ENDC
.IF NB <RAT>
  .IF NB <TYP>
    .IF NDF T.'TYP
	.ERROR ;ILLEGAL TERMINAL TYPE IN AB MACRO FOR AUTO-BAUD TABLE
    .ENDC
    $$$T=!T.'TYP
  .IFF
    $$$T=!-1
  .ENDC
	.BYTE	^C<MSK>,CHR,.FLG,R.'RAT,$$$T
.IFF
  .IF NDF SEC.'TYP
	.ERROR ;UNDEFINED SECONDARY TABLE IN AB MACRO FOR AUTO-BAUD TABLE
  .ENDC
	.BYTE	^C<MSK>,CHR,.FLG,0,SEC.'TYP
  SBT$'TYP=!1
  SBT$=!1
.ENDC
.IF B <COD>
	.BYTE	0
.IFF
  .IF NDF .XX'COD
	.ERROR ;ILLEGAL TERMINAL CODE IN AB MACRO FOR AUTO-BAUD TABLE
  .ENDC
	.BYTE	.XX'COD
  X$$'COD=!1
.ENDC
	.ENDM

.B0=!0

;GENERATE TABLES
;  THE FORMAT OF EACH TABLE IS AS FOLLOWS:
;RAT$n::.WORD	SET		;ADDRESS OF SETUP ROUTINE
;	.WORD	DET		;RATE TO USE FOR DETECT
;	.WORD	RST		;ADDRESS OF RESET ROUTINE
;	.BYTE	MSK		;COMPLEMENT OF DETECT MASK FOR FIRST RATE
;	.BYTE	CHR		;DETECT CHARACTER FOR FIRST RATE
;	.BYTE	FLG		;FLAG BITS FOR FIRST RATE
;				;  200 = CHECK FRAMING ERROR
;				;  100 = MUST HAVE FRAMING ERROR
;	.BYTE	RAT		;FIRST RATE
;	.BYTE	TYP		;TERMINAL TYPE OR INDEX FOR NEXT LEVEL TABLE
;				;  IF RATE = 0
;	.BYTE	COD		;TERMINAL CODE
;	.BYTE	MSK		;COMPLEMENT OF DETECT MASK FOR SECOND RATE
;	.BYTE	CHR		;DETECT CHARACTER FOR SECOND RATE
;	.BYTE	RAT		;SECOND RATE
;	.BYTE	TYP		;TYPE FOR SECOND RATE
;	....
;	.BYTE	377		;END OF TABLE

;GENERATE TABLES FOR AUTO-BAUD DETECT TYPE 1

.IF DF ABR$1
	ABC	1,300,AINI13,ARST13	;DETECT AT 300 FOR 110,135,150,300
	AB	300  ,    ,ASC,015,177,X	;CR -  300 BAUD, ASCII
	AB	150  ,    ,ASC,346,377,X	;CR -  150 BAUD, ASCII
	AB	134X ,SEL ,CRS,300,337,X	;D  -  134.5 BAUD, CORRESPONDENCE
	AB	110  ,    ,ASC,014,155,X	;CR -  110 BAUD, ASCII
.ENDC

;GENERATE TABLES FOR AUTO-BAUD DETECT TYPE 2

.IF DF ABR$2
	ABC	2,600,AINI13,ARST13	;DETECT AT 600 FOR 110,135,300,1200
	AB	1200 ,    ,ASC,370,370,X	;CR - 1200 BAUD, ASCII
	AB	300  ,    ,ASC,302,336,X	;CR -  300 BAUD, ASCII
	AB	300  ,    ,ASC,312,336,X
	AB	300  ,    ,ASC,322,336,X
	AB	300  ,    ,ASC,304,336,X
	AB	300  ,    ,ASC,314,336,X
	AB	300  ,    ,ASC,324,336,X
	AB	300  ,    ,ASC,306,336,X
	AB	300  ,    ,ASC,316,336,X
	AB	300  ,    ,ASC,326,336,X
	AB	134X ,SEL ,CRS,135,377,X	;D  -  134.5 BAUD, CORRESPONDENCE
	AB	110  ,    ,ASC,340,357,X	;CR -  110 BAUD, ASCII
.ENDC

;GENERATE TABLES FOR AUTO-BAUD DETECT TYPE 3

.IF DF ABR$3
	ABC	3,4800,AINI13,ARST13	;DETECT AT 4800 FOR 300,600,1200,1800,
					;  2400,4800,9600
	AB	     ,   1,   ,000,377,F	;CR -  300 BAUD, ASCII
	AB	600  ,    ,ASC,200,377		;CR -  600 BAUD, ASCII
	AB	1200 ,    ,ASC,170,377,F	;CR - 1200 BAUD, ASCII
	AB	1800 ,    ,ASC,214,355		;CR - 1800 BAUD, ASCII
	AB	2400 ,    ,ASC,346,377		;CR - 2400 BAUD, ASCII
	AB	4800 ,    ,ASC,015,177		;CR - 4800 BAUD, ASCII
	AB	9600 ,    ,ASC,360,360		;CR - 9600 BAUD, ASCII
.ENDC

;GENERATE TABLES FOR AUTO-BAUD DETECT TYPE 4

.IF DF ABR$4
	ABC	4,300,AINI45,ARST45	;TYMNET STYLE DETECT AT 300 FOR 110,
					;  134,150,300
	AB	110  ,CRT ,ASC,000,177		;D - 110 BAUD, TERMINAL = CRT
	AB	150  ,TRMB,ASC,030,377,F	;B - 150 BAUD, TERMINAL = TRMB
	AB	300  ,CRT ,ASC,101,137		;A - 300 BAUD, TERMINAL = CRT
	AB	300  ,TRMC,ASC,103,137		;C - 300 BAUD, TERMINAL = TRMC
	AB	300  ,TRME,ASC,105,137		;E - 300 BUAD, TERMINAL = TRME
	AB	300  ,TRMG,ASC,107,137		;G - 300 BAUD, TERMINAL = TRMG
.ENDC

;GENERATE TABLES FOR AUTO-BAUD DETECT TYPE 5

.IF DF ABR$5
	ABC	5,1200,AINI45,ARST45	;TYMNET STYLE DETECT AT 1200 FOR 110,
					;  300,1200
	AB	     ,   2,   ,000,377,F	;D - 110 BAUD, TERMINAL = CRT
	AB	300  ,CRT ,ASC,170,377,F	;A - 300 BAUD, TERMINAL = CRT
	AB	300  ,TRMC,ASC,370,377		;C - 300 BAUD, TERMINAL = TRMC
	AB	1200 ,CRTA,ASC,101,137		;A - 1200 BAUD, TERMINAL = CRTA
	AB	1200 ,TRMG,ASC,107,137		;G - 1200 BAUD, TERMINAL = TRMG
	AB	1200 ,TRMJ,ASC,111,137		;I - 1200 BAUD, TERMINAL = TRMJ
.ENDC

;GENERATE TABLES FOR AUTO-BAUD DETECT TYPE 6

.IF DF ABR$6
	ABC	6,1200,AINI6,ARST6	;TYMNET STYLE DETECT AT 1200 FOR 110,
					;  134.5,300, AND 1200 USING SPECIAL
					;  HIGH SPEED CLOCK FOR SECONDARY
					;  DETECT CHARACTER TIMING
	AB	1200 ,CRTA,ASC,101,137		;A - 1200 BAUD, TERMINAL = CRTA
	AB	1200 ,TRMG,ASC,107,137		;G - 1200 BAUD, TERMINAL = TRMG
	AB	1200 ,TRMJ,ASC,111,137		;I - 1200 BAUD, TERMINAL = TRMJ
	AB	     ,   3,   ,170,377,F	;A,E - 300 BAUD, TERMINAL = CRTA
						;        OR TRME
	AB	     ,   4,   ,370,377		;C,G - 300 BAUD, TERMINAL = TRMC
						;	 OR TRMG
	AB	     ,   5,   ,000,377,F	;B,D - 150 BAUD, TERMINAL = TRMB
						;	 OR 110 BAUD, TERMINAL =
						;	 TTY
	AB	     ,   6,   ,000,177		;P - 134.5 BAUD, TERMINAL = SEL,
						;	CODE = CRS OR EBD
.ENDC

;Generate tables for auto-baud detect type 7

.IF DF ABR$7
	ABC	7,1200,AINI7,ARST7	;TYMNET STYLE DETECT AT 1200 FOR 110,
					;  134.5,300, AND 1200 USING SPECIAL
					;  HIGH SPEED CLOCK FOR SECONDARY
					;  DETECT CHARACTER TIMING
	AB	1200 ,CRTA,ASC,101,137		;A - 1200 BAUD, TERMINAL = CRTA
	AB	1200 ,TRGE,ASC,107,377		;G - 1200 BAUD, TERMINAL = TRMG
	AB	1200 ,TRGE,ASC,347,377		;g - 1200 BAUD, TERMINAL = TRMG
	AB	1200 ,TRIE,ASC,311,377		;I - 1200 BAUD, TERMINAL = TRMJ
	AB	1200 ,TRIE,ASC,151,377		;i - 1200 BAUD, TERMINAL = TRMJ
	AB	     ,   7,   ,170,377,F	;A,E,I,Y - 300 BAUD, TERMINAL =
						; CRTA OR TRME OR TRMI OR TRMY
	AB	     ,  10,   ,370,377		;C,G - 300 BAUD, TERMINAL = TRMC
						;	 OR TRMG
	AB	     ,  11,   ,000,377,F	;B,D - 150 BAUD, TERMINAL = TRMB
						;	 OR 110 BAUD, TERMINAL =
						;	 TTY
	AB	     ,  12,   ,000,177		;P - 134.5 BAUD, TERMINAL = SEL,
						;	CODE = CRS OR EBD
	AB	2400 ,CRTA,ASC,360,363		;A - 2400 BAUD, TERMINAL =CRT
	AB	2400 ,TRMG,ASC,361,363		;G - 2400 BAUD, TERMINAL = TRMG
	AB	4800 ,CRTA,ASC,376,376		;A - 4800 BAUD, TERMINAL = CRT
.ENDC

;Generate tables for auto-baud detect type 10

.IF DF ABR$10
	ABC	10,9600,AINI7,ARST7	;TYMNET STYLE DETECT AT 9600 FOR 110,
					;  134.5,300, AND 9600 USING SPECIAL
					;  HIGH SPEED CLOCK FOR SECONDARY
					;  DETECT CHARACTER TIMING
	AB	4800 ,CRTA,ASC,006,377,F	;A - 4800 BAUD, TERMINAL = CRTA
	AB	     ,  13,ASC,170,377,F	;A,I - 2400 BAUD
	AB	     ,  14,   ,200,377		;A,I,G 1200 BAUD
	AB	     ,  15,   ,000,377,F	;A,B,C,D,E,F,G,I,Y AT 300 BAUD AND LOWER
	AB	9600 ,TRGE,ASC,107,377		;G - 9600 BAUD, TERMINAL = TRMG
	AB	9600 ,TRGE,ASC,347,377		;g - 9600 BAUD, TERMINAL = TRMG
	AB	9600 ,TRIE,ASC,311,377		;I - 9600 BAUD, TERMINAL = TRMJ
	AB	9600 ,TRIE,ASC,151,377		;i - 9600 BAUD, TERMINAL = TRMJ
	AB	4800 ,TRMG,ASC,176,377,F	;G - 4800 BAUD, TERMINAL = TRMG
	AB	4800 ,TRMI,ASC,206,377		;I - 4800 BAUD, TERMINAL = TRMJ
	AB	2400 ,TRMG,ASC,370,377		;G - 2400 BAUD, TERMINAL = TRMG
	AB	9600 ,CRTA,ASC,101,137		;A - 9600 BAUD, TERMINAL = CRTA
.ENDC

;GENERATE THE SECONDARY TABLES

.IF DF SBT$

;  THE FORMAT OF EACH TABLE IS AS FOLLOWS:
;SEC$n::.BYTE	MIN TIME	;MINIMUM TIME SINCE PRIMARY CHARACTER (OPTIONAL)
;	.BYTE	MAX TIME	;MAXIMUM TIME SINCE PRIMARY CHARACTER (OPTIONAL)
;	.BYTE	MSK		;COMPLEMENT OF DETECT MASK FOR FIRST RATE
;	.BYTE	CHR		;DETECT CHARACTER FOR FIRST RATE
;	.BYTE	FLG		;FLAG BITS FOR FIRST RATE
;				;  200 = CHECK FRAMING ERROR
;				;  100 = MUST HAVE FRAMING ERROR
;	.BYTE	RAT		;FIRST RATE
;	.BYTE	TYP		;TERMINAL TYPE OR INDEX FOR NEXT LEVEL TABLE
;				;  IF RATE = 0
;	.BYTE	COD		;TERMINAL CODE
;	....

;DEFINE MACRO WHICH DEFINES A SECONDARY TABLE:
;	ABS	N,TIM
;  WHERE:
;	N   = NUMBER OF SECONDARY TABLE
;	TIM = NUMBER OF TICKS TO WAIT FOR SECOND DETECT CHARACTER

	.MACRO	ABS  N
	.BYTE	377			;TERMINATE PREVIOUS TABLE
SEC$'N:
	.ENDM

;DEFINE MACRO WHICH DEFINES EACH ENTRY IN THE SECONDARY DETECT TABLES
;  PARAMETERS ARE AS FOLLOWS:
;	AB	RAT,TYP,COD,CHR,MSK,F,MIN,MAX
;  WHERE:
;	RAT = ACTUAL BAUD RATE CORRESPONDING TO CHARACTER
;	TYP = TERMINAL TYPE OR SECONDARY TABLE NUMBER IF RAT IS BLANK
;	COD = TERMINAL CODE
;	CHR = CHARACTER FOR MATCH
;	MSK = MASK FOR MATCH
;	F   = F IF MUST HAVE FRAMING ERROR, BLANK IF CANNOT HAVE FRAMING
;		ERROR, X IF DON'T CARE
;	MIN = MINIMUM NUMBER OF FAST CLOCK TICKS SINCE PRIMARY CHARACTER
;		A ZERO IN THIS FIELD OF THE FIRST AB ENTRY OF A SECONDARY
;		TABLE INDICATES THIS IS THE DEFAULT IF A SECONDARY TIMEOUT OCCURS
;		(OPTIONAL, MUST BE BLANK IF DETECT ROUTINE DOES NOT USE IT!)
;	MAX = MAXIMUM NUMBER OF FAST CLOCK TICKS SINCE PRIMARY CHARACTER
;		(OPTIONAL, MUST BE BLANK IF DETECT ROUTINE DOES NOT USE IT!)

	.MACRO	AB  RAT,TYP,COD,CHR,MSK,FFF,MIN,MAX
.FLG=!200
.IF IDN <FFF><X>
  .FLG=!000
.ENDC
.IF IDN <FFF><F>
  .FLG=!300
.ENDC
.IF NB <MIN>
	.BYTE	MIN,MAX
.ENDC
.IF NB <RAT>
  .IF NB <TYP>
    .IF NDF T.'TYP
	.ERROR ;ILLEGAL TERMINAL TYPE IN AB MACRO FOR AUTO-BAUD TABLE
    .ENDC
    $$$T=!T.'TYP
  .IFF
    $$$T=!-1
  .ENDC
	.BYTE	^C<MSK>,CHR,.FLG,R.'RAT,$$$T
.IFF
  .IF NDF SEC.'TYP
	.ERROR ;UNDEFINED SECONDARY TABLE IN AB MACRO FOR AUTO-BAUD TABLE
  .ENDC
	.BYTE	^C<MSK>,CHR,.FLG,0,SEC.'TYP
  SBT$'TYP=!1
  SBT$=!1
.ENDC
.IF B <COD>
	.BYTE	0
.IFF
  .IF NDF .XX'COD
	.ERROR ;ILLEGAL TERMINAL CODE IN AB MACRO FOR AUTO-BAUD TABLE
  .ENDC
	.BYTE	.XX'COD
  X$$'COD=!1
.ENDC
	.ENDM
;GENERATE SECONDARY TABLE TYPE 1 (USED WITH DETECT TYPE 3)

.IF DF SBT$1
	ABS	1
	AB	300  ,    ,ASC,000,377,F	;CR - 300 BAUD, ASCII
.ENDC

;GENERATE SECONDARY TABLE TYPE 2 (USED WITH DETECT TYPE 5)

.IF DF SBT$2
	ABS	2
	AB	110  ,CRT ,ASC,000,177,F	;D - 110 BAUD, TERMINAL = CRT
.ENDC

;GENERATE SECONDARY TABLE TYPE 3 (USED WITH DETECT TYPE 6)

.IF DF SBT$3
	ABS	3
	AB	300  ,CRT ,ASC,000,377, , 0., 0.;A - 300 BAUD, TERMINAL = CRT
	AB	300  ,TRME,ASC,000,177,X, 8.,24.;E - 300 BAUD, TERMINAL = TRME
	AB	300  ,CRT ,ASC,370,377, ,25.,40.;A - 300 BAUD, TERMINAL = CRT
.ENDC

;GENERATE SECONDARY TABLE TYPE 4 (USED WITH DETECT TYPE 6)

.IF DF SBT$4
	ABS	4
	AB	300  ,TRMC,ASC,000,377,F, 8.,14.;C - 300 BAUD, TERMINAL = TRMC
	AB	300  ,TRMG,ASC,000,177,X,15.,25.;G - 300 BAUD, TERMINAL = TRMG
.ENDC

;GENERATE SECONDARY TABLE TYPE 5 (USED WITH DETECT TYPE 6)

.IF DF SBT$5
	ABS	5
	AB	150  ,TRMB,ASC,000,377,F,10.,37.;B - 150 BAUD, TERMINAL = TRMB
	AB	110  ,TTY ,ASC,000,377,F,38.,60.;D - 110 BAUD, TERMINAL = TTY
.ENDC

;GENERATE SECONDARY TABLE TYPE 6 (USED WITH DETECT TYPE 6)

.IF DF SBT$6
	ABS	6
	AB	134X ,SEL ,EBC,000,377,F,12.,21.;P - 134.5 BAUD, TERMINAL =
						;	SEL, CODE = EBC
	AB	134X ,SEL ,CRS,000,177, ,22.,45.;P - 134.5 BAUD, TERMINAL =
						;	SEL, CODE = CRS
.ENDC

;Generate secondary table type 7 (used with detect type 7)

.IF DF SBT$7
	ABS	7
	AB	300  ,CRTA,ASC,000,377, , 0., 0.;TIMEOUT .. A - 300 BAUD, TERMINAL = CRT
	AB	300  ,TRME,ASC,000,177,X,20.,33.;E - 300 BAUD, TERMINAL = TRME
	AB	300  ,TRMI,ASC,200,207, ,27.,26.;I - 300 BAUD, TERMINAL = TRMI
;	AB	300X ,SEL ,EBC,370,377, ,27.,34.;CR - 300 BAUD, TERMINAL =
						;	3767, CODE = EBC
	AB	300  ,TRMY,ASC,170,177,X,34.,40.;Y - 300 BAUD, TERMINAL = TRMY
	AB	300  ,CRTA,ASC,370,377, ,41.,64.;CATCH ANY PARITY BIT AND DEFAULT
						; TO A - 300 BAUD, TERMINAL = CRT
.ENDC

;GENERATE SECONDARY TABLE TYPE 10 (USED WITH DETECT TYPE 7)

.IF DF SBT$10
	ABS	10
	AB	300  ,TRMC,ASC,000,377,F,12.,21.;C - 300 BAUD, TERMINAL = TRMC
	AB	300  ,TRMG,ASC,000,177,X,22.,37.;G - 300 BAUD, TERMINAL = TRMG
.ENDC

;GENERATE SECONDARY TABLE TYPE 11 (USED WITH DETECT TYPE 7)

.IF DF SBT$11
	ABS	11
	AB	150  ,TRMB,ASC,000,377,F,15.,56.;B - 150 BAUD, TERMINAL = TRMB
	AB	110  ,TTY ,ASC,000,377,F,57.,90.;D - 110 BAUD, TERMINAL = TTY
.ENDC

;GENERATE SECONDARY TABLE TYPE 12 (USED WITH DETECT TYPE 7)

.IF DF SBT$12
	ABS	12
	AB	134X ,SEL ,EBC,000,377,F,18.,32.;P - 134.5 BAUD, TERMINAL =
						;	SEL, CODE = EBC
	AB	134X ,SEL ,CRS,000,177, ,33.,77.;P - 134.5 BAUD, TERMINAL =
						;	SEL, CODE = CRS
.ENDC

;GENERATE SECONDARY TABLE TYPE 13 (USED WITH DETECT TYPE 10)

.IF DF SBT$13
	ABS	13
	AB	2400 ,CRTA ,ASC,170,377, ,0.,0.	;A - 2400 BAUD CRTA
	AB	2400 ,TRMI ,ASC,200,377, ,1.,7.	;I - 2400 BAUD TRMI
	AB	2400 ,TRMI ,ASC,370,377, ,1.,4.	;i - 2400 BAUD TRMI
	AB	2400 ,CRTA ,ASC,370,377, ,5.,9.	;A - 2400 BAUD CRTA
.ENDC

;GENERATE SECONDARY TABLE TYPE 14 (USED WITH DETECT TYPE 10)

.IF DF SBT$14
	ABS	14
	AB	     ,  16,   ,000,377,F,1., 4.	; A,I 1200 BAUD
	AB	1200 ,TRMG,ASC,000,377,F,5.,10.	;G - 1200 BAUD
.ENDC

;GENERATE SECONDARY TABLE TYPE 15 (USED WITH DETECT TYPE 10)

.IF DF SBT$15
	ABS	15
	AB	     ,   17,ASC,000,377,F, 7.,14.;A,E,I,Y - 300 BAUD
	AB	300  ,TRMC ,ASC,000,377,F,15.,20.;C - 300 BAUD TRMC
	AB	300  ,TRMG ,ASC,000,377,F,21.,27.;G - 300 BAUD TRMG
	AB	134X ,SEL  ,EBC,000,377,F,25.,30.;P - 134 BAUD TRMP
	AB	150  ,TRMB ,ASC,000,377,F,35.,40.;B - 150 BAUD TRMB
;	AB	150  ,TRMJ ,ASC,000,377,F,35.,41.;B - 150 BAUD TRMB
	AB	134X ,SEL  ,CRS,000,377,F,41.,51.;P - 134 BAUD TRMP
	AB	110  ,TTY  ,ASC,000,377,F,60.,72.;D - 110 BAUD TRMD
.ENDC

;GENERATE SECONDARY TABLE TYPE 16 (USED WITH DETECT TYPE 10)

.IF DF SBT$16
	ABS	16
	AB	1200 ,CRTA ,ASC,170,377, ,0.,0.	;A - 1200 BAUD TRMA
	AB	1200 ,TRMI ,ASC,200,377, ,4.,9. ;i - 1200 BAUD TRMI
	AB	1200 ,TRMI ,ASC,000,377,F,4.,16. ;I - 1200 BAUD TRMI
	AB	1200 ,CRTA ,ASC,200,377, ,10.,20.;A - 1200 BAUD TRMA
.ENDC

;GENERATE SECONDARY TABLE TYPE 17 (USED WITH DETECT TYPE 10)

.IF DF SBT$17
	ABS	17
	AB	300  ,CRTA ,ASC,000,377,F, 0., 0.;TIMEOUT - 300 BAUD TRMA
	AB	300  ,TRME ,ASC,000,377,F,20.,28.;E - 300 BAUD TRME
	AB	300  ,TRMI ,ASC,000,377,F,29.,34.;I - 300 BAUD TRMI
	AB	300  ,TRMY ,ASC,000,377,F,35.,42.;Y - 300 BAUD TRMY
	AB	300  ,CRTA ,ASC,000,377,F,43.,59.;A - 300 BAUD CRTA
.ENDC

.ENDC		;.IF DF SBT$

	.BYTE	377			;FLAG END OF LAST TABLE
	.EVEN

;GENERATE INDEX TABLES

.N=!1
.X=!0
ATOTBL::.REPT	10		;BE SURE TO INCREASE THIS COUNT IF MORE
				;  AUTO-BAUD DETECT TYPES ARE ADDED!!
	.IRP	NN,<\.N>
.IF DF ABR$'NN
	.WORD	RAT$'NN
  ABX.'NN=!.X
.X=.X+1
.ENDC
	.ENDM
.N=!.N+1
	.ENDR

ATOTXX==!ATOTBL-2-<RATAT0*2>

.IF DF SBT$
.N=!1
.X=!0
SECTBL::.REPT	17		;BE SURE TO CHANGE THIS COUNT IF MORE
				;  SECONDARY TABLES ARE DEFINED!!
	.IRP	NN,<\.N>
.IF DF SBT$'NN
	.WORD	SEC$'NN
  SEC.'NN=!.X
  .X=!.X+2
.ENDC
	.ENDM
.N=!.N+1
	.ENDR
.ENDC

.IFF		;.IF NDF ABR$
  ATOTXX==!0			;THIS IS REFERENCED BY THE TERMINAL SERVICE
.ENDC		;.IF DF/NDF ABR$
	.PAGE
	.SBTTL	TERMINAL CODE TRANSLATION INDEX TABLES

;TABLES WHICH CONTAIN POINTERS TO THE CODE TRANSLATION TABLES AND TABLES
;  WHICH CONTAIN THE UPPER AND LOWER SHIFT CODES FOR THOSE CODES WHICH USE
;  THEM

;FIRST DEFINE THE INDEXES USED FOR THESE TABLES

.XXASC==!0			;ASCII IS ALWAYS 0

.N=!2
	.IRP	CODE,<CRS,EBC,BCD,CAL>
.IF DF X$$'CODE
  .XX'CODE==!.N
  .N=!.N+2
.IFF
  .XX'CODE==!-1
.ENDC
	.ENDM

;NOW GENERATE THE TABLES WHOSE ENTRIES POINT TO THE TRANSLATION TABLES

	.MACRO	TABLE  NAME,TBL
NAME==!.-2
	.IRP	CODE,<CRS,EBC,BCD,CAL>
.IF DF X$$'CODE
	.WORD	TBL''CODE#
.ENDC
	.ENDM
	.ENDM

	TABLE	CODTIU,XCU		;UPPER CASE INPUT TABLE
	TABLE	CODTIL,XCL		;LOWER CASE INPUT TABLE
	TABLE	CODTIP,XCP		;PREFIXED INPUT TABLE
	TABLE	CODTOU,XCO		;OUTPUT TABLE
	TABLE	CODTOX,XCX		;SPECIAL OUTPUT TABLE

;GENERATE THE TWO TABLES WHICH CONTAIN THE UPPER AND LOWER CASE SHIFT CODES
;  THESE TABLES HAVE 1 BYTE ENTRIES AND THE TWO TABLES ARE INTERLEAVED

CODTSU==!.-2
CODTSL==!CODTSU+1
	.IRP	CODE,<CRS,EBC,BCD,CAL>
.IF DF X$$'CODE
	.BYTE	XSU'CODE#,XSL'CODE#
.ENDC
	.ENDM
	.PAGE
	.SBTTL	IMPURE DATA

	.PSECT	IMPURE,RW,D,LCL,REL,CON

;"THE STACK"

STKEND::.BLKW	200
STKBGN::.WORD	STKUND#
	.WORD	STKUND
	.WORD	STKUND
	.WORD	STKUND

REQSTH::.WORD	0		;REQUEST HEAD POINTER
REQSTT::.WORD	0		;REQUEST TAIL POINTER

;TIMER DATA

TMRFRE::.WORD	0		;TIMER INDEX FREE LIST HEAD POINTER

TMRLST::.BLKW	NUMSOC+1	;INDEX OF NEXT ENTRY IN TIMER LIST (FIRST WORD
TMRTOP==!.-2			;  IN THIS TABLE IS THE HEAD POINTER)

TMRCNT::.BLKW	NUMSOC+1	;TIMER COUNT TABLE (FIRST WORD IN THIS TABLE IS
				;  THE CURRENT TIMER COUNT VALUE)

TMRSDB==.-2
	.BLKW	NUMSOC		;ADDRESS SDB FOR TIMER REQUEST (FIRST WORD OF
				;  OF THIS TABLE DOES NOT EXIST!)

TMRDSP==.-2
	.BLKW	NUMSOC		;DISPATCH ADDRESS FOR TIMER REQUEST (FIRST WORD
	.EVEN			;  OF THIS TABLE DOES NOT EXIST!)

;INTERRUPT BUFFER POINTERS FOR TERMINAL MODULE (TRM)

.IF NE TR.NUM
TRRNGT::.WORD	0		;BUFFER TAKER POINTER
TRRNGP::.WORD	0		;BUFFER PUTTER POINTER
TR0CON==!T0$+DDNCON
.ENDC

;Interrupt ring for type A line printers

.IF DF LPANUM
LPRING::.BLKW	2*LP.S0+2	; 1 word per socket plus safety margin
LPRNGE::			; End of ring (+2)
LPRNGP::.WORD	0		; Ring putter pointer
LPRNGT::.WORD	0		; Ring taker pointer
.ENDC
	.PAGE
	.SBTTL	DUMMY XDT USED IF XDT NOT LOADED

;THIS ROUTINE IS USED IN PLACE OF XDT IF XDT IS NOT LOADED - IF XDT IS LOADED
;  IT WILL OVERLAY THIS CODE

	.PSECT	.XDT.,RW,I,GBL,REL,OVR

.XDT.::	BR	XDT4			;INITIAL ENTRY - START NODE IF NO XDT
	BR	XDT2			;CRASH ENTRY - HALT
	.BLKW	1			;MUST KEEP THIS WORD OPEN SO XDT'S
					;  SYMBOL TABLE POINTER WILL WORK!

;HERE AFTER A NODE CRASH - CHECK ERROR TYPE - IF FATAL HALT, IF NON-FATAL
;  RESTART NODE

XDT2:
.IF EQ ..FTL
	TSTB	@SAVEPC#		;CHECK ERROR TYPE
	BEQ	XDT3			;IF FATAL ERROR
	BIT	#$NSFTL,NODSTS#		; Should it be fatal anyway?
	BNE	XDT3			; Yes, so die big
	CMP	#100.,CRSCNT#		;DON'T LET THIS GO ON TOO LONG!
	BLO	XDT3
	JMP	START#			;OK-LETS TRY IT ALL AGAIN!
.ENDC

;HERE FOR FATAL CRASH - HALT THE NODE!!

XDT3:	HALT

;HERE FOR INITIAL STARTUP ENTRY - JUST START THE NODE

XDT4:	JMP	GO#

;INSURE THAT SOME PSECTS END ON WORD BOUNDRIES AND DEFINE FINAL SYMBOLS
;  TO CHECK FOR PHASE ERRORS (MACRO-11 WILL NOT REPORT PHASE ERRORS UNLESS
;  THERE IS A LABEL INVOLVED!)

	.MACRO	PCHK  NAME,PAR
	.PSECT	NAME,PAR,REL
$.'NAME:
	.EVEN
	.ENDM

	PCHK	CODE  ,<RW,I,LCL,CON>
	PCHK	MAIN  ,<RW,I,LCL,CON>
	PCHK	SECOND,<RW,I,LCL,CON>
	PCHK	TENTHS,<RW,I,LCL,CON>
	PCHK	INIT  ,<RW,I,LCL,CON>
	PCHK	SX    ,<RW,D,LCL,CON>
	PCHK	PURE  ,<RW,D,LCL,CON>
	PCHK	.XDT. ,<RW,I,GBL,OVR>
	PCHK	.SYM. ,<RW,D,GBL,OVR>
	PCHK	DDB   ,<RW,D,LCL,CON>
	PCHK	LDB   ,<RW,D,LCL,CON>
	PCHK	ADB   ,<RW,D,LCL,CON>
	PCHK	SDB   ,<RW,D,LCL,CON>
	PCHK	IMPURE,<RW,D,LCL,CON>
	PCHK	ONCE  ,<RW,I,LCL,CON>
	PCHK	VECTBL,<RW,D,LCL,CON>

	.END

   @@