	.TITLE	CMDTYM - TYMSHARE STYLE COMMAND DECODER ROUTINES
	.SBTTL	CMDTYM - NEXILIS/JRG

	XLPAR

;DEFINE MACRO FOR INLINE MESSAGES

	.MACRO	INLMES  MES
	CALL	INLOUT#
	.ASCIZ	MES
	.EVEN
	.ENDM

.IF NDF ..SAT
  ..SAT=!0
.ENDC

;GENERATE COMMAND DECODER ENTRY TABLE

	PURE

TYMENT::.WORD	TYMCMD		;.CXCMD =  0 - ENTER COMMAND LEVEL
	.WORD	TYMCIN		;.CXCIN =  2 - COMMAND INTERRUPT
	.WORD	TYMECL		;.CXECL =  4 - END OF COMMAND LINE
	.WORD	TYMRST		;.CXRST =  6 - RESET COMMAND DECODER
	.WORD	TYMACK		;.CXACK = 10 - CONNECT ACK PACKET
	.WORD	TYMNAK		;.CXNAK = 12 - CONNECT NAK PACKET
	.WORD	TYMDIS		;.CXDIS = 14 - DISCONNECT PACKET
	.WORD	TYMDAK		;.CXDAK = 16 - DISCONNECT ACK PACKET

	CODE
	.PAGE
;HERE TO ENTER NETWORK COMMAND LEVEL
;	ENTRY INDEX = .CXCMD

TYMCMD:	CALL	WATIDL#			;MAKE SURE OUTPUT IS IDLE
.IF EQ ..SAT
	MOV	#P.TYMS,R0		;FORCE TYMSHARE TERMINAL PROFILE
	CALL	SETPRF#
	  NOP				;Should not fail!
.IFF
	MOVB	#$T2ELC,SDTRS2#(SD)	;SET TERMINAL PROFILE BITS
	MOV	#$T5LCO!$T5LCI!$T5XFC!$T5AOH,SDTRS5#(SD)
.ENDC
	BIC	#$T4HOE!$T4HIE,SDTRS4#(SD);DISABLE INPUT AND OUTPUT HOLD
	MOVB	#100,SDTRBS#(SD)	;MAKE THE COMMAND MODE BREAK SET THE
					;  CURRENT BREAK SET
	BIC	#$T1SOP!$T1CMD!$T1ECM!$T1IMI,SDTRS1#(SD) ;CLEAR FLAGS

;*****	change for optional command mode by DRE  10/30/80

	TBBN	$T0CMD,SDTRS0#(SD),2$	;ARE WE ALLOWED TO DO COMMANDS
	JMP	BYEBYE			;NO- GO IGNORE THIS INTERRUPT
;	end of 10/30/80 change


2$:	BIS	#$T1CMD!$T1ECM,SDTRS1#(SD);INDICATE COMMAND MODE
	MOV	#..MOD#,R1		;GET ADDRESS OF HEADER MESSAGE
	CALL	OUTSTR#
	INLMES	<<CR><LF>"-">		;TYPE FIRST PART OF NODE # LINE
	MOV	#THSNOD#,R1		;TYPE NAME OF THIS NODE
	CALL	OUTSTR#
	INLMES	<"-">
	MOVB	SDSOC#(SD),R0		;GET SOCKET NUMBER
	DEC	R0			;MINUS 1 = "PORT NUMBER"
	SWAB	R0			;PUT IT IN THE RIGHT POSITION
	ROR	R0
	MOV	R0,SDTRC3#(SD)		;SAVE IT
	CALL	OUTDIG			;OUTPUT 3 DIGITS
	CALL	OUTDIG
	CALL	OUTDIG
	INLMES	<"-">
	MOV	SDTPVC#(SD),R1		;DO WE HAVE A PVC STRING
	BEQ	PLSLG1			;NO
	INC	R1			;SKIP OVER BYTE OF PARAMS
	BIS	#$T1ACT,SDTRS1#(SD)	;TURN OFF ECHOING FUNNY WAY
10$:	MOVB	(R1)+,R0		;GET DATA BYTE
	BEQ	20$			;END OF STRING
	PUSH	R1
	CALL	TRDATA#			;PROCESS DATA AS IF TYPED BY USER
	POP	R1
	BR	10$
20$:	BIC	#$T1ACT,SDTRS1#(SD)	;ALLOW ECHOING
	BIS	#$T1DEX!$T1HIA,SDTRS1#(SD) ;ENABLE ECHOING
	BIS	#$T3LGI,SDTRS3#(SD)	;INDICATE LOGIN MODE
	BIS	#$T6CMW,SDTRS6#(SD)	;INDICATE WAITING FOR A COMMAND
	MOV	#INPGET#,SDTROD#(SD)	;RESET OUTPUT DISPATCH VECTOR
	BR	TYMECL			;HANDLE AT END OF LINE
PLSLG1:	MOVB	#5,SDTREC#(SD)		;SET RETRY COUNTER
	BR	TYMCI1			;CONTINUE
	.PAGE
;HERE ON HARD INTERRUPT CHARACTER WHEN IN COMMAND MODE
;	ENTRY INDEX = .CXCIN

TYMCIN:	CALL	WATIDL#			;MAKE SURE OUTPUT IS IDLE
TYMCI1:	CALL	CLRCMC#			;CLEAR COMMAND INPUT

;*****	change to prevent problems with previously image mode terminals
;*****	by DRE  2/4/81
	BIC	#$T1SOP!$T1IMI!$T1IMO,SDTRS1#(SD)

;*****	change for optional command mode by DRE  10/30/80

	TBBN	$T0CMD,SDTRS0#(SD),2$	;ARE WE ALLOWED TO DO COMMANDS
	BIC	#$T1CMD!$T1ECM,SDTRS1#(SD) ;CLEAR FLAGS
	JMP	BYEBYE			;NO- GO IGNORE THIS INTERRUPT
;	end of 10/30/80 change

2$:	INLMES	<<CR><LF>"please log in: ">;TYPE TYMNET STYLE PROMPT
	MOV	#TIMOUT,R1		;MAKE SURE NO TIMEOUT REQUEST
	CALL	TIMKIL#
	MOV	#JIF150#,R0		;GIVE HIM ABOUT 2-1/2 MIN. TO LOGIN!
	MOV	#TIMOUT,R1
	CALL	TIMREQ#
PLSLG4:	MOVB	#100,SDTRBS#(SD)	;MAKE SURE BREAK SET IS CORRECT
	BIS	#$T1ECH!$T1ECM!$T1DEX!$T1HIA,SDTRS1#(SD) ;ENABLE ECHOING
	BIS	#$T3LGI,SDTRS3#(SD)	;INDICATE LOGIN MODE
	BIS	#$T6CMW,SDTRS6#(SD)	;INDICATE WAITING FOR A COMMAND
	MOV	#INPGET#,SDTROD#(SD)	;RESET OUTPUT DISPATCH VECTOR
	TBBE	$T4SEL,SDTRS4#(SD),2$	;SELECTRIC TERMINAL?
	JMP	ENBKEY#			;YES-GO ENABLE ITS KEYBOARD

2$:	JMP	INPGET#			;NO-THATS ALL!
	.PAGE
;HERE ON END OF COMMAND LINE WHEN AT NETWORK COMMAND LEVEL
;	ENTRY INDEX = .CXECL

TYMECL:	BIC	#$T3ECL,SDTRS3#(SD)	;INDICATE NOT END OF LINE
	TBBE	$T6PND,SDTRS6#(SD),TYMEC2;GO ON IF NETWORK HANDSHAKE NOT PENDING
EATCMD:	CALL	GETCMC#			;IF PENDING, EAT THE COMMAND LINE!
RTN001:	  RETURN			;END OF LINE-THATS ALL!
	BR	EATCMD			;CONTINUE

TYMEC2:	TBBE	$T6CMW,SDTRS6#(SD),RTN001;FORGET IT IF NOT EXPECTING COMMAND
	BIC	#$T1SOP,SDTRS1#(SD)	;CLEAR SOME BITS
	BIC	#$T6CMW,SDTRS6#(SD)
	CALL	WATIDL#			;WAIT UNTIL OUTPUT IS IDLE
	CLRB	SDTRBS#(SD)		;NO BREAK CHARACTERS NOW!
2$:	CALL	GETCMC#			;GET A CHARACTER
	  BR	NULUSR			;IF END OF LINE
	CMP	#';,R0			;END OF LOGIN STRING?
	BEQ	NULUSR			;YES

;	DELETE BLOCKING OF CONTROL CHARACTERS IN NAME
;	DRE 11/04/80
;	CMP	R0,#40			;PRINTING CHARACTER?
;	BLT	2$			;NO-IGNORE IT

4$:	CMP	#';,R0			;END OF LOGIN STRING?
	BEQ	LGIEND			;YES
	CMP	#':,R0			;NO-START OF DST?
	BEQ	DSTSPC			;YES
	CALL	PUTCHR#			;NO-STORE CHARACTER IN SRC LIST
	  BR	LOGERR			;COMPLAIN IF CAN'T STORE IT!
	CALL	GETCMC#			;GET NEXT CHARACTER
	  BR	CMLEND			;IF END OF LINE
	BR	4$			;OTHERWISE CONTINUE

;HERE IF SEE END OF LOGIN STRING WITHOUT SEEING A DST SPECIFICATION

CMLEND:
.IF EQ ..SAT
	MOV	#LF,R0			;GET LF AS STOPPER
.IFF
	MOV	#CR,R0			;UNLESS SPECIAL TYMSAT VERSION, THEN
.ENDC					;  USE CARRIAGE RETURN!
LGIEND:	CALL	PUTCHR#			;STORE STOPPER CHARACTER
	  NOP
	CALL	EATCMD			;MAKE SURE NO JUNK LEFT
	MOVB	SDTRS0#+1(SD),R0	;GET HOST CONNECT LIST INDEX
	BIC	#^C<$T0HCL/400>,R0
	BEQ	LOGERR			;ERROR IF NO HOST CONNECT LIST
	MOV	HCLTBL#-2(R0),SDTRC4#(SD);STORE POINTER TO HOST CONNECT LIST
	MOV	#040,R0			;GET FLAG BITS
	CALL	CMDCON#			;PROCESS HOST CONNECT LIST
	CMP	#10,R1			;NORMAL RETURN?
	BEQ	RTN001			;YES
LOGERR:	CALL	DELSRC#			;CLEAR OUT THE SRC LIST
	  NOP
	CALL	CLRCMC#			;EAT REST OF COMMAND LINE
	DECB	SDTREC#(SD)		;HAVE WE DONE THIS ENOUGHT?
	BLT	TIMOUT			;YES-GET RID OF HIM!
	INLMES	<<CR><LF>"error, type user name: ">
	JMP	PLSLG4			;GO GET HIS INPUT

;HERE IF LOG IN STRING IS NULL

NULUSR:	INLMES	<<CR><LF>"user name: ">	;ASK HIM FOR HIS USER NAME
	JMP	PLSLG4			;CONTINUE

;HERE WITH START OF DST SPECIFICATION

DSTSPC:	CLR	SDTRC4#(SD)		;INDICATE NOT AUTO-CONNECT
	MOV	#040,R0			;GET FLAG BITS
	CALL	CMDCON#			;PROCESS DST SPECIFICATION
	CMP	#10,R1			;ALL OK?
	BNE	LOGERR			;NO
	TST	R0			;STOPPED BY END OF LINE?
	BNE	7$			;NO-JUST STORE STOPPER CHARACTER
.IF EQ ..SAT
	MOV	#LF,R0			;YES-USE LF
.IFF
	MOV	#CR,R0
.ENDC
7$:	CALL	PUTCHR#			;STORE IT
	  NOP
	CBR	EATCMD			;AND SURE NO JUNK AND RETURN

;HERE ON TIME-OUT - NO INPUT FOR ABOUT 2-1/2 MIN.

TIMOUT:	CALL	WATIDL#			;MAKE SURE OUTPUT IS IDLE
	INLMES	<<CR><LF>"please see your representative"<CR><LF>"if you are having trouble logging in">
BYEBYE:	INLMES	<"  ">			;GIVE SLOWER TERMINALS TIME TO QUIT
	CJMP	HUNGUP#			;HANG HIM UP AND RETURN
	.PAGE
;HERE WHEN TERMINAL HUNG UP
;	INTRY INDEX = .CXHNG

TYMRST:	MOV	#TIMOUT,R1		;CLEAR TIMER REQUEST
	CJMP	TIMKIL#			;AND RETURN
	.PAGE
;HERE FOR CONNECT ACK PACKET
;	ENTRY INDEX = .CXACK
;	C(R0) = FLAG BYTE FROM ACK PACKET

TYMACK:	BIC	#$T1CMD!$T1ECM!$T1SOP,SDTRS1#(SD);LEAVE COMMAND MODE
.IF EQ ..SAT
	TBBN	040,R0,2$		;WILL HE ACCEPT THE LOGIN STRING?
	CALL	DELSRC#			;NO-THROW IT AWAY!
	  NOP
	BR	4$

2$:	TBBN	$T2SLC,SDTRS2#(SD),3$	;OK AS-IS IF INSERTING LF AFTER CR
	MOV	SDPKSP#(SD),R1		;MUST FIX IT UP IF NOT
	BEQ	4$
	MOVB	PKCNT(R1),R2		;FIND LAST CHARACTER IN PACKET
	ADD	R1,R2
	CMPB	#LF,PKDATA-1(R2)	;IS IT A LF?
	BNE	3$			;NO-OK
	MOVB	#CR,PKDATA-1(R2)	;YES-CHANGE TO CR
.ENDC
3$:	CALL	SNDTRP#			;SEND IT TO HIM
4$:
.IF EQ ..SAT
	MOVB	SDTRBX#(SD),SDTRBS#(SD)	;MAKE CURRENT BREAK SET THE ACTIVE
	TBBN	$T3LGI,SDTRS3#(SD),6$	;HAS LOGGIN MODE BEEN CLEARED?
	MOV	#TIMOUT,R1		;YES-CLEAR THE LOGIN TIMER
	CALL	TIMKIL#
.IFF
	MOVB	#200,SDTRBS#(SD)
.ENDC
6$:	MOV	#OUTGET#,SDTROD#(SD)	;RESET OUTPUT DONE DISPATCH ADDRESS
	JMP	OUTGET#			;AND LEAVE COMMAND MODE!
	.PAGE
;HERE FOR CONNECT NAK PACKET
;	ENTRY INDEX = .CXNAK

TYMNAK:	BIS	#$T3LGI,SDTRS3#(SD)	;INDICATE LOGGING IN
					;FALL INTO DISCONNECT ROUTINE

;HERE FOR DISCONNECT OR KILL PACKET
;	ENTRY INDEX = .CXDIS

TYMDIS:	BIC	#$S1HLD,SDSTS1#(SD)	;MAKE SURE OUTPUT NOT HELD
	BIS	#$T1ECH!$T1ECM!$T1CMD,SDTRS1#(SD);AND THAT ECHOING IS ON, ETC.
	CALL	GETCTL#			;GET REASON
	BCC	1$			;SHOULD BE THERE
	CLR	R0
1$:	PUSH	R0			;Save it
	CALL	GETPKT#			;Get address of packet
	CMPB	#.PTNAK,PKTYPE(R1)	;Is this a NAK?
	BEQ	4$			;Yes
	MOV	#.PTDAK*400,PKCNT(R1)	;Change into a Disconnect ACK
	CALL	PKTRTX#			;And send it back
	BR	10$			;Continue

4$:	CALL	JNKCPK#			;Give up the NAK packet
10$:	POP	R0			;Restore reason code
	CMP	#.ERUNE,R0		;User name error?
	BNE	14$			;No
	JMP	LOGERR			;Yes

14$:	TBBN	$T3LGI,SDTRS3#(SD),16$	;DON'T GIVE A REASON UNLESS LOGGING IN
	TBBN	$T0CMX,SDTRS0#(SD),15$	;SHOULD WE GO BACK TO COMMAND MODE
	JMP	BYEBYE			;NO - JUST HANGUP
15$:	JMP	PLSLG1			;YES GIVE PROMPT

16$:	CMP	#.ERSVR,R0		;SUPERVISOR REQUEST?
	BEQ	BYEBYE			;YES-JUST HANG HIM UP QUITELY
	CMP	#.ERTIM,R0		;TIMEOUT?
	BEQ	NETHNG			;YES
	CMP	#.ERLKF,R0		;LINK FULL?
	BEQ	CIRBSY			;Yes
	CMP	#.ERNSA,R0		;Or no sockets available?
	BEQ	CIRBSY			;Yes
	CMP	#.ERLKD,R0		;Link down?
	BEQ	HSTNAV			;Yes-say host not available
	CMP	#.ERNSH,R0		;No such host?
	BEQ	HSTNAV			;Yes
	CMP	#.ERHSD,R0		;Or down?
	BEQ	HSTDWN			;Yes
	CMP	#.ERGWD,R0		;Or gateway down?
	BNE	TYMC2N			;No-just ask him to login again!
HSTNAV:	INLMES	<<CR><LF>"host not available through net"<CR><LF>>
TYMC2N:	TBBE	$T0CMX,SDTRS0#(SD),2$	;SHOULD WE GO BACK TO COMMAND MODE
	JMP	TYMCIN
2$:	JMP	BYEBYE

CIRBSY:	INLMES	<<CR><LF>"circuits busy"<CR><LF>>
	BR	TYMC2N

NETHNG:	INLMES	<<CR><LF>"network did not respond"<CR><LF>>
	BR	TYMC2N

HSTDWN:	INLMES	<<CR><LF>"host down"<CR><LF>>
	BR	TYMC2N

;HERE FOR DISCONNECT ACK PACKET
;	ENTRY INDEX = .CXDAK

TYMDAK:	CALL	JNKCPX#			;GET RID OF THE PACKET
	BR	TYMC2N			;THATS ALL!
	.PAGE
	.SBTTL	CMDTYM - LOCAL SUBROUTINES

;SUBROUTINE TO OUTPUT VALUE AS SINGLE OCTAL DIGIT
;	CALL	OUTDIG

OUTDIG:	POP	SDTROD#(SD)		;PUT RETURN ADDRESS IN RIGHT PLACE
	CLR	R0			;GET NEXT 3 BITS
	MOV	#3,R2
2$:	ROL	SDTRC3#(SD)
	ROL	R0
	SOB	R2,2$
	ADD	#'0,R0			;CHANGE TO ASCII
	CJMP	OUTCHR#			;OUTPUT IT AND RETURN

	.END

YE>@