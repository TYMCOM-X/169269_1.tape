BEGIN "MTDUMP"
	REQUIRE "(SYS)BAIPD8" LOAD!MODULE;
	EXTERNAL PROCEDURE BAIL;

COMMENT	THIS MAGNETIC TAPE DUMP PROGRAM IS A GENERAL PURPOSE
	TOOL FOR EXAMINING MAGNETIC TAPES OF UNKNOWN FORMAT;


	
	DEFINE EXTCHN = '15;
	DEFINE FILCHN = '16;
	DEFINE INCHAN = '17;
	DEFINE MAX!READ = '7777;
	DEFINE CRLF = "'15&'12";
	DEFINE FILES = 1;
	DEFINE RECORDS = 2;
	DEFINE BADCHR = 1;
	DEFINE BADID = 2;
	DEFINE BADPAR = 3;
	DEFINE DUPLICATE = 10;
	DEFINE TOOMANY = 11;
	DEFINE NEEDPOS = 12;
	DEFINE NOMATCH = 13;
	DEFINE NEEDPARS = 14;
	DEFINE BAD!RES = 15;
	DEFINE NODEV = 16;
	DEFINE NODSK = 17;
	DEFINE BAD!DEN = 18;
	DEFINE BADPARIT = 19;
	DEFINE DATA!MISSED = 20;
	DEFINE PARERR = 21;
	DEFINE BLK!TOO!LG = 22;
	DEFINE EOT = 23;
	DEFINE LOGEOT = 24;
	DEFINE BOT = 25;
	DEFINE NOLPT = 26;


	PRESET!WITH "ADVANCE","BACKSPACE","DUMP","FORMAT",
	  "HELP","INPUT","OPTIONS","OUTPUT","PROMPT","QUIT",
	  "REWIND","NUMBER","SYMBOLICS","?";
	STRING ARRAY COMNDS[1:14];
	PRESET!WITH 3,3,3,2,1,4,1,3,1,1,1,1,3,1;
	INTEGER ARRAY NUMPAR[1:14];
	PRESET!WITH "FILES","RECORDS";
	STRING ARRAY POSITN[1:2];
	PRESET!WITH "STATISTICS","TTY","LARGE";
	STRING ARRAY FORMS[1:3];
	PRESET!WITH "YES","NO";
	STRING ARRAY YORN[1:2];
	PRESET!WITH "OCTAL";
	STRING ARRAY MODES[1:1];
	PRESET!WITH "FSTAR";
	STRING ARRAY TAPE!ANAL[1:1];
	PRESET!WITH "ALL";
	STRING ARRAY RANGE[1:1];
	PRESET!WITH "TTY","LPT";
	STRING ARRAY HARDCOPY[1:2];
	PRESET!WITH "MTA0","MTA1","MTA2","MTA3","DSK";
	STRING ARRAY DRIVES[1:5];
	PRESET!WITH "ODD","EVEN";
	STRING ARRAY PARITIES[1:2];
	PRESET!WITH "ILLEGAL CHARACTER","ILLEGAL IDENTIFIER",
	  "BAD PARAMETER",[6]NULL,"DUPLICATE SPECIFICATION",
	  "TOO MANY PARAMETERS","NEED POSITIVE INTEGER",
	  "ILLEGAL COMMAND WORD","NOT ENOUGH PARAMETERS",
	  "BAD RESPONSE","CAN'T OPEN TAPE DEVICE",
	  "CAN'T INITIALIZE THE DISK",
	  "DENSITY NOT DEFINED FOR DEVICE",
	  "BAD PARITY PARAMETER VALUE",
	  "DATA MISSED, BAD TAPE, OR HUNG TRANSPORT",
	  "TAPE PARITY ERROR","TAPE RECORD TOO LARGE",
	  "PHYSICAL END OF TAPE ENCOUNTERED","*** EOT ***",
	  "*** BOT ***","CAN'T GET LINE PRINTER";
	STRING ARRAY ERRMES[1:26];
	STRING INDEV,PARITY,OUTFILE,REPORT!SIZE,ECHO,
	  SYM!MODE,FSTAR,PRTDEV;
	STRING TTYI;
	PRESET!WITH 6250,1600,800,556,200;
	INTEGER ARRAY TAPDENS[1:5];
	INTEGER ARRAY INBUF[0:MAX!READ-1];
	INTEGER BRKCHR,BRK!BLNK,CMDBRK,DENSITY,ERRNUM,FILEOF;
	INTEGER FILENUM,FILOUT,INEOF,PRTCHN,PRTEOF,RECDNUM;
	INTEGER TRACKS;
	BOOLEAN EOF!FOUND,EOT!FOUND,INTAPE;



COMMENT	THE PROCEDURE DEFINITIONS FOLLOW;


INTEGER PROCEDURE STRSRC(STRING ARRAY NAMES; STRING LOOK);
BEGIN "STRING SEARCH"
	INTEGER FIRST,LAST,PREV,I;

COMMENT	***** BILL WEIHER'S STRING SEARCH ROUTINE *****
        THIS ROUTINE IS CALLED WITH A STRING AND A STRING
    	ARRAY. IT SEARCHES FOR A MATCH AND RETURNS THE INDEX
    	INTO THE ARRAY OF THE MATCH. TO AVOID CONFUSION, THE
    	LOWER ARRAY BOUND SHOULD BE 1 OR GREATER. IF NO MATCH IS
    	FOUND, 0 IS RETURNED. THE PROCEDURE WILL TRY TO FIND
    	AN EXACT MATCH. FAILING THIS, IT WILL LOOK FOR STRINGS
    	WHICH MATCH ON ALL THE CHARACTERS IN THE STRING
    	ARGUMENT.  THE FLAG EXACT WILL BE SET TRUE IF AN EXACT 
    	MATCH IS FOUND.  IF NO EXACT MATCH IS FOUND AND SEVERAL 
    	PARTIAL MATCHES EXIST, THE PROCEDURE WILL RETURN 0.
	CALL IS STRSRC(ARRAY,STRING,FLAG);

	PREV_0; FIRST_ARRINFO(NAMES,1); LAST_ARRINFO(NAMES,2);
	FOR I_FIRST STEP 1 UNTIL LAST DO
	  IF EQU(LOOK,NAMES[I]) THEN RETURN(I)
	  ELSE IF EQU(LOOK,NAMES[I][1 FOR LENGTH(LOOK)])
	    THEN PREV_IF PREV NEQ 0 THEN -1 ELSE I;
	RETURN(PREV MAX 0);
END "STRING SEARCH";


PROCEDURE ERRMSG(REFERENCE INTEGER ERRNO);
BEGIN "PRINT ERROR MESSAGE"
	STRING MSG;
	INTEGER I,SPC,NUM;

	MSG_NULL;
	SPC_(ERRNO LSH -18) LAND '777777;
	NUM_ERRNO LAND '777777;
	IF NUM < 10 THEN BEGIN
	  PRINT(TTYI,CRLF);
	  IF SPC THEN
	    FOR I_1 STEP 1 UNTIL (SPC-1) DO
	      MSG_MSG&" ";
	  PRINT(MSG,"^"&CRLF);
	END;
	PRINT(ERRMES[NUM],CRLF);
	ERRNO_0;
	RETURN;
END "PRINT ERROR MESSAGE";


STRING PROCEDURE GETKEY(STRING MESSG; STRING ARRAY KEYS;
	REFERENCE STRING OPTVAL; INTEGER PRINTOLD);
BEGIN "GET KEY WORD"
	INTEGER I;
	STRING PARAM;

	PRINT(MESSG);
	IF PRINTOLD THEN PRINT(OPTVAL,"  _");
	I_0;
	WHILE I = 0 DO BEGIN
	  PARAM_INCHWL;
	  SCAN(PARAM,BRK!BLNK,I);
	  IF LENGTH(PARAM) = 0 THEN RETURN (NULL);
	  I_STRSRC(KEYS,PARAM);
	  IF I = 0 THEN BEGIN
	    ERRMSG(BAD!RES);  PRINT(MESSG);
	  END;
	END;
	RETURN (KEYS[I]);
END "GET KEY WORD";


INTEGER PROCEDURE GETNUM;
BEGIN "GET DECIMAL INTEGER"
	INTEGER I,J;
	STRING PARAM;

	J_FALSE;
	WHILE J = FALSE DO BEGIN
	  PARAM_INCHWL;
	  SCAN(PARAM,BRK!BLNK,I);
	  IF LENGTH(PARAM) = 0 THEN RETURN (0);
	  IF ("0" LEQ I LEQ "9") OR NOT ("-" NEQ I NEQ "+")
	    THEN BEGIN I_INTSCAN(PARAM,J);
	    IF LENGTH(PARAM) > 0 THEN BEGIN
	      ERRMSG(NEEDPOS);
	     J_FALSE;
	    END ELSE J_TRUE;
	  END;
	END;
	RETURN (I);
END "GET DECIMAL INTEGER";


PROCEDURE DELSCN(REFERENCE STRING CMDBUF; REFERENCE STRING
	CMDLIN; INTEGER DEL!BRK; INTEGER ARRAY DELPTRS;
	INTEGER STOPCH; BOOLEAN REMOVE);

BEGIN "DELIMITER SCAN"
	INTEGER I,J,K,FIRST,LAST,COUNT,BRCHR,SPFLG;
	STRING ENTITY;
	DEFINE SPACE = '40;
	LABEL ENDSCN;


COMMENT THE FOLLOWING SUBROUTINE BREAKS APART A TEXT LINE
	INTO ENTITIES SEPARATED BY DELIMITERS AS DESIGNATED
	BY THE CALLER.  THE PARAMETERS ARE AS FOLLOWS:

CMDBUF	THE TEXT LINE TO BE SCANNED.
CMDLIN	THIS IS AN ARRAY WHICH WILL CONTAIN THE TEXT WITH
	DELIMITERS STRIPPED OUT.
DEL!BRK	THIS IS THE NUMBER OF THE BREAK TABLE TO BE USED FOR
	DELIMITER SCANNING.
DELPTRS	FOLLOWING THE CALL, THIS ARRAY WILL CONTAIN POINTERS
	TO THE ENTITIES WITH THE DELIMITERS THAT TERMINATED
	EACH.  WORD 0 WILL CONTAIN THE COUNT OF ENTRIES.
	EACH TWO-WORD ENTRY IN THIS ARRAY WILL LOOK LIKE THE
	FOLLOWING:
	WORD 1:  INDEX INTO CMDLIN,,ENTITY CHARACTER COUNT
	WORD 2:  DELIMITER (RIGHT JUSTIFIED)
STOPCH	A CALLER SUPPLIED CHARACTER WHICH STOPS THE SCAN.  IF
	ZERO, THE SUBROUTINE SCANS THE WHOLE STRING.
REMOVE	A FLAG WHICH INDICATES WHETHER OR NOT TO REMOVE EXTRA
	BREAK CHARACTERS (SUCH AS LEADING AND TRAILING SPACES);



	FIRST_ARRINFO(DELPTRS,1);
	LAST_ARRINFO(DELPTRS,2);
	ARRCLR(DELPTRS);
	CMDLIN_NULL;
	SPFLG_1;  COUNT_0;  J_1;  BRCHR_-1;  K_FIRST+1;
	WHILE BRCHR NEQ STOPCH DO BEGIN "SCAN LOOP"
	  ENTITY_SCAN(CMDBUF,DEL!BRK,BRCHR);
	  COUNT_LENGTH(ENTITY);
	  IF COUNT THEN CMDLIN_CMDLIN&ENTITY;
	  IF REMOVE = TRUE THEN
	    IF BRCHR = SPACE THEN
	      IF NOT COUNT AND SPFLG THEN GO TO ENDSCN
	      ELSE SPFLG_1
	    ELSE SPFLG_0;
	  DELPTRS[K]_(J LSH 18)+COUNT;
	  DELPTRS[K+1]_BRCHR;
	  J_J+COUNT;  K_K+2;
ENDSCN:	END "SCAN LOOP";
	J_K-1;
	IF COUNT = 0 THEN
	  IF DELPTRS[J-2] = SPACE THEN BEGIN
	    DELPTRS[(J_J-2)]_0;
	  END;
	DELPTRS[0]_J/2;
END "DELIMITER SCAN";


INTEGER PROCEDURE GETPRM(INTEGER ARRAY DELS; INTEGER ARRIND);
BEGIN "GET PARAMETER"
	DEFINE SPACE = '40;

COMMENT	THIS SUBROUTINE FINDS A PARAMETER DELIMITER IN THE
	DELIMITER ARRAY AND RETURNS THE INDEX OF THE ARRAY
	ENTRY.  (LOOKS FOR SPACE OR END OF STRING.);;

	WHILE ARRIND < 2*DELS[0]+1 DO BEGIN
	  IF DELS[ARRIND+1] = SPACE THEN RETURN (ARRIND);
	  IF DELS[ARRIND+1] = 0 THEN RETURN (ARRIND);
	  ARRIND _ ARRIND+2;
	END;
	RETURN (0);
END "GET PARAMETER";


INTEGER PROCEDURE GET!RANGE(STRING ARRAY PARAMS;
	INTEGER ARRAY DELMTRS; REFERENCE INTEGER F,R);
BEGIN "GET RANGE"
	INTEGER I,J,K;
	FOR K_1 STEP 1 UNTIL 2 DO BEGIN "GET AMOUNTS"
	  IF EQU(PARAMS[K],NULL) THEN DONE "GET AMOUNTS";
	  I_INTSCAN(PARAMS[K],J);
	  IF J < 0 THEN I_1;
	  J_STRSRC(POSITN,PARAMS[K]);
	  IF J=FILES THEN BEGIN
	    IF F THEN RETURN (DUPLICATE);
	    F_I;
	  END
	  ELSE IF J = RECORDS THEN BEGIN
	    IF R THEN RETURN (DUPLICATE);
	    R_I;
	  END
	  ELSE RETURN (DELMTRS[2*(K+1)-1] LAND '777777000000
	    + BADID);
	END "GET AMOUNTS";
	IF F < 0 THEN RETURN (NEEDPOS);
	IF R < 0 THEN RETURN (NEEDPOS);
	RETURN (0);
END "GET RANGE";


INTEGER PROCEDURE CHKEOFERR;
BEGIN "CHECK ERRORS"
	IF NOT INEOF THEN EOF!FOUND_FALSE;
	INEOF _INEOF LSH 1;
	IF INEOF < 0 THEN RETURN (DATA!MISSED);
	INEOF_INEOF LSH 1;
	IF INEOF < 0 THEN RETURN (PARERR);
	INEOF_INEOF LSH 1;
	IF INEOF < 0 THEN RETURN (BLK!TOO!LG);
	INEOF_INEOF LSH 1;
	IF INEOF < 0 THEN BEGIN
	  IF EOF!FOUND THEN BEGIN
	    EOT!FOUND_TRUE;
	    RETURN (LOGEOT);
	  END;
	  EOF!FOUND_TRUE;
	  RETURN (0);
	END;
	INEOF_INEOF LSH 2;
	IF INEOF < 0 THEN RETURN (BOT);
	INEOF_INEOF LSH 1;
	IF INEOF < 0 THEN RETURN (EOT);
END "CHECK ERRORS";


INTEGER PROCEDURE ADVBAK(STRING FUNCTION; STRING ARRAY PARAMS;
	INTEGER ARRAY DELMTRS);
BEGIN "ADVANCE OR BACKSPACE TAPE"
	INTEGER I,J,R,F;

	R_F_0;
	IF EQU(PARAMS[1],NULL) THEN RETURN (NEEDPARS);
	IF (I_GET!RANGE(PARAMS,DELMTRS,F,R)) THEN RETURN (I);
	FOR I_1 STEP 1 UNTIL F DO BEGIN
	  MTAPE(INCHAN,FUNCTION);
	  IF (J_CHKEOFERR) THEN DONE;
	END;
	IF EQU(FUNCTION,"A") THEN
	  FILENUM_FILENUM+I ELSE FILENUM_FILENUM-I;
	FOR I_1 STEP 1 UNTIL R DO BEGIN
	  MTAPE(INCHAN,(IF EQU(FUNCTION,"A") THEN "F"
	    ELSE "R"));
	  IF (J_CHKEOFERRN DONE;
	END;
	IF EQU(FUNCTION,"A") THEN
	  RECDNUM_RECDNUM+I ELSE RECDNUM_1;
	RETURN (J);
END "ADVANCE OR BACKSPACE TAPE";


INTEGER PROCEDURE DUMP(STRING ARRAY PARAMS; INTEGER ARRAY
	DELMTRS);
BEGIN "DUMP"
	INTEGER ADDR,COLCNT,WDCNT,I,J,K,L,F,R,REC,FIL;
	BOOLEAN ALLSW,FILSW,RECSW;

	FILSW_RECSW_ALLSW_FALSE;  F_R_0;
	IF EQU(PARAMS[1],NULL) THEN RETURN (NEEDPARS);
	FOR K_1 STEP 1 UNTIL 2 DO BEGIN "GET AMOUNTS"
	  IF EQU(PARAMS[K],NULL) THEN CONTINUE "GET AMOUNTS";
	  IF J_STRSRC(RANGE,PARAMS[K]) THEN BEGIN
	    ALLSW_TRUE;  CONTINUE "GET AMOUNTS";
	  END;
	  I_INTSCAN(PARAMS[K],J);
	  IF J < 0 THEN I_1;
	  J_STRSRC(POSITN,PARAMS[K]);
	  IF J = FILES THEN BEGIN
	    IF F THEN RETURN (DUPLICATE);
	    F_I;  FILSW_TRUE;
	  END
	  ELSE IF J = RECORDS THEN BEGIN
	    IF R THEN RETURN (DUPLICATE);
	    R_I;  RECSW_TRUE;
	  END
	  ELSE RETURN (DELMTRS[2*(K+1)-1] LAND '777777000000
	    + BADID);
	END "GET AMOUNTS";
	IF F < 0 THEN RETURN (NEEDPOS);
	IF R < 0 THEN RETURN (NEEDPOS);
	IF ALLSW THEN BEGIN
	  IF FILSW THEN R_-1
	  ELSE IF RECSW THEN F_-1
	  ELSE R_F_-1;
	  FILSW_RECSW_TRUE;
	END;
	IF (FILSW LAND RECSW) = 0 THEN
	
	  IF FILSW THEN R_-1 ELSE F_1;
	FIL_F;  REC_R;
	IF NOT EQU(OUTFILE,"UNDEFINED") THEN SETPRINT(OUTFILE,
	  (IF EQU(ECHO,"YES") AND EQU(PRTDEV,"TTY") THEN
	  "B" ELSE "F")) ELSE IF EQU(ECHO,"NO")
	    THEN SETPRINT(NULL,"N");
	PRINT(CRLF,CRLF);
	IF PRTCHN THEN CPRINT(PRTCHN,CRLF,CRLF);
	WHILE FIL NEQ 0 DO BEGIN
	  WHILE REC NEQ 0 DO BEGIN "DISPLAY RECORDS"
	    ARRYIN(INCHAN,INBUF[0],MAX!READ);
	    IF (I_CHKEOFERR) THEN RETURN (I);
	    IF EOF!FOUND THEN DONE "DISPLAY RECORDS";
	    START!CODE
	      SETZ 2,;
	      UGETF INCHAN,2;
	      MOVEM 3,ADDR;
	    END;
	    IF PRTCHN THEN CPRINT(PRTCHN,"FILE # ",FILENUM,
	      ", RECORD # ",RECDNUM,"    BYTES IN RECORD = ",
	      ADDR,CRLF);
	    PRINT("FILE # ",FILENUM,", RECORD # ",
	      RECDNUM,"    BYTES IN RECORD = ",ADDR,CRLF);
	    RECDNUM_RECDNUM+1;  REC_REC-1;
	    IF EQU(REPORT!SIZE,"STATISTICS") THEN
	      CONTINUE "DISPLAY RECORDS";
	    COLCNT_(IF EQU(REPORT!SIZE,"TTY") THEN 4 ELSE 8);
	    IF TRACKS = 7 THEN BEGIN
	      WDCNT_(ADDR+(ADDR MOD 6))/6;
	      J_POINT(6,INBUF[0],-1);
	      K_POINT(8,INBUF[0],-1);
	      FOR I_1 STEP 1 UNTIL ADDR DO IDPB(ILDB(K),J);
	      K_WDCNT*6;
	      FOR I_(ADDR+1) STEP 1 UNTIL K DO IDPB(0,J);
	    END ELSE BEGIN
	      WDCNT_(ADDR/9)*2;
	      IF (I_ADDR MOD 9) THEN WDCNT_WDCNT+
		(IF I > 4 THEN 2 ELSE 1);
	      J_K_POINT(4,INBUF[0],-1);
	      ADDR_ADDR*2;
	      FOR I_1 STEP 1 UNTIL ADDR DO BEGIN
		IF (I MOD 8) = 1 THEN IBP(K);
		IDPB(ILDB(K),J);
	      END;
	      K_WDCNT*9;
	      FOR I_(ADDR+1) STEP 1 UNTIL K DO IDPB(0,J);
	    END;
	    I_0;  IF PRTCHN THEN CPRINT(PRTCHN,CRLF);
	    PRINT(CRLF);
	    WHILE I < WDCNT DO BEGIN
	      SETFORMAT(5,7);  PRINT(CVOS(I),"*");
	      IF PRTCHN THEN CPRINT(PRTCHN,CVOS(I),"*");
	      SETFORMAT(14,7);
	      K_WDCNT-I;
	      FOR J_1 STEP 1 UNTIL COLCNT MIN K DO BEGIN
		IF PRTCHN THEN CPRINT(PRTCHN,CVOS(INBUF[I]));
		PRINT(CVOS(INBUF[I]));  I_I+1;
	      END;
	      PRINT(CRLF);  IF PRTCHN THEN CPRINT(PRTCHN,CRLF);
	    END;
	    SETFORMAT(1,7);  PRINT(CRLF,CRLF);
	    IF PRTCHN THEN CPRINT(PRTCHN,CRLF,CRLF);
	  END "DISPLAY RECORDS";
	  REC_R;  FIL_FIL-1;  FILENUM_FILENUM+1;  RECDNUM_1;
	END;
	RETURN (0);
END "DUMP";


INTEGER PROCEDURE FORMAT(STRING ARRAY PARAMS; INTEGER
	ARRAY DELMTRS);
BEGIN "FORMAT"
	INTEGER I;

	IF EQU(PARAMS[1],NULL) THEN BEGIN
	  PRINT("FORMAT:  ",REPORT!SIZE,CRLF);
	  RETURN (0);
	END;
	I_STRSRC(FORMS,PARAMS[1]);
	IF NOT I THEN
	  RETURN (DELMTRS[3] LAND '777777000000 + BADPAR);
	REPORT!SIZE_FORMS[I];
	RETURN (0);
END "FORMAT";


INTEGER PROCEDURE HELP;
BEGIN "HELP"
	PRINT("HELP COMMAND NOT YET IMPLEMENTED"&CRLF);
	RETURN (0);
END "HELP";


INTEGER PROCEDURE INPUT(STRING ARRAY PARAMS; INTEGER
	ARRAY DELMTRS);
BEGIN "INPUT"
	INTEGER I,J,K,L,TEMP,ADDR;
	BOOLEAN FLAG;

	IF EQU(PARAMS[1],NULL) THEN BEGIN
	  IF INTAPE THEN PRINT("TAPE INPUT:  ",INDEV,"  ",
	    TRACKS," TRACK  ",PARITY," PARITY  ",DENSITY,
	    " BPI"&CRLF)
	  ELSE PRINT("TAPE INPUT:  ",INDEV,CRLF);
	  RETURN (0);
	END;
	IF (I_STRSRC(DRIVES,PARAMS[1])) THEN PARAMS[1]_DRIVES[I]
	ELSE RETURN (DELMTRS[3] LAND '777777000000 + BADPAR);
	J_(IF I THEN 2 ELSE 1);
	K_INTSCAN(PARAMS[J],BRKCHR);
	IF BRKCHR < 0 THEN IF I THEN RETURN (NEEDPARS)
	ELSE K_DENSITY;
	IF BRKCHR GEQ 0 THEN J_J+1;
	IF EQU(PARAMS[J],NULL) THEN RETURN (0);
	IF (I_STRSRC(PARITIES,PARAMS[J])) = 0 THEN
	  RETURN (BADPARIT);
	OPEN(INCHAN,PARAMS[1],'370017,0,0,MAX!READ,BRKCHR,
	  INEOF);
	ENTER(INCHAN,"MTDUMP.TMP",INEOF);
	IF INEOF THEN RETURN(NODEV);
	MTAPE(INCHAN,"W");
	TEMP_CALLI((ADDR_INCHAN),4);
	TEMP_TEMP LSH 13;
	IF TEMP > 0 THEN BEGIN
	  INTAPE_FALSE;
	  IF ARRINFO(PARAMS,2) > 1 THEN RETURN (TOOMANY)
	  ELSE RETURN (0);
	END;
	INTAPE_TRUE;
	START!CODE
	  MOVEI 2,2;
	  UGETF INCHAN,2;
	  MOVEM 3,ADDR;
	END;
	TEMP_ADDR LSH 12;  FLAG_FALSE;
	TRACKS_(IF TEMP < 0 THEN 7 ELSE 9);
	FOR L_1 STEP 1 UNTIL 5 DO BEGIN
	  TEMP_TEMP LSH 1;  IF TEMP < 0 THEN
	    IF TAPDENS[L]=K THEN FLAG_TRUE;
	END;
	IF FLAG=FALSE THEN RETURN (BAD!DEN);
	DENSITY_K;
	INDEV_PARAMS[1];
	IF TRACKS = 7 THEN START!CODE
	  MTAPE INCHAN,'201;
	END ELSE START!CODE
	  MTAPE INCHAN,'101;
	END;
	IF EQU(PARITY,"EVEN") THEN
	  IF TRACKS = 9 THEN RETURN (BADPARIT)
	  ELSE SETSTS(INCHAN,'371017);
	FILENUM_RECDNUM_1;
	RETURN (0);
END "INPUT";


INTEGER PROCEDURE NUMBER(STRING ARRAY PARAMS;
	INTEGER ARRAY DELMTRS);
BEGIN "NUMBER"
	INTEGER I,F,R;

	F_R_1;
	IF (I_GET!RANGE(PARAMS,DELMTRS,F,R)) THEN RETURN (I);
	FILENUM_F;  RECDNUM_R;
	RETURN (0);
END "NUMBER";


INTEGER PROCEDURE OPTION;
BEGIN "PRINT OPTIONS";

	IF INTAPE THEN PRINT("TAPE INPUT:  ",INDEV,"  ",
	  TRACKS," TRACK  ",PARITY," PARITY  ",DENSITY,
	  " BPI"&CRLF)
	ELSE PRINT("TAPE INPUT:  ",INDEV,CRLF);
	PRINT("OUTPUT FILE:  ",OUTFILE,CRLF);
	PRINT("REPORT SIZE:  ",REPORT!SIZE,CRLF);
	PRINT("ECHO TO TTY:  ",ECHO,CRLF);
	PRINT("ANALYSIS:  ",SYM!MODE," ",(IF EQU(FSTAR,"YES")
	  THEN "FSTAR" ELSE NULL),CRLF);
	RETURN (0);
END "PRINT OPTIONS";


INTEGER PROCEDURE OUTPUT(STRING ARRAY PARAMS; INTEGER ARRAY
	DELMTRS);
BEGIN "OUTPUT"
	PRINT("OUTPUT COMMAND NOT YET IMPLEMENTED"&CRLF);
	RETURN (0);
END "OUTPUT";


PROCEDURE GETVAL(INTEGER PRINTOLD);
BEGIN "GET OPTION VALUES"
	STRING PARAM;
	BOOLEAN FLAG;
	LABEL GETANS,GETDEV,GETDEN,GETFIL,GETFL1,GETHDC,REPSIZ;
	INTEGER ADDR,TEMP,I;

GETDEV:	PARAM_GETKEY("TAPE INPUT:  ",DRIVES,INDEV,PRINTOLD);
	IF NOT EQU(PARAM,NULL) THEN BEGIN
	  OPEN(INCHAN,PARAM,'370017,0,0,MAX!READ,BRKCHR,INEOF);
	  ENTER(INCHAN,"MTDUMP.TMP",INEOF);
	  IF INEOF THEN BEGIN
	    ERRMSG(NODEV);  GO TO GETDEV;
	  END;
	  MTAPE(INCHAN,"W");
	  INDEV_PARAM;
	END;
	IF EQU(INDEV,"UNDEFINED") THEN GO TO GETFIL;
	TEMP_CALLI((ADDR_INCHAN),4);
	TEMP_TEMP LSH 13;
	IF TEMP > 0 THEN BEGIN
	  INTAPE_FALSE;  GO TO GETFIL;
	END;
	INTAPE_TRUE;
	START!CODE
	  MOVEI 2,2;
	  UGETF INCHAN,2;
	  MOVEM 3,ADDR;
	END;
	TEMP_ADDR LSH 12;
	TRACKS_(IF TEMP < 0 THEN 7 ELSE 9);
	IF TRACKS = 7 THEN START!CODE
	  MTAPE INCHAN,'201;
	END ELSE START!CODE
	  MTAPE INCHAN,'101;
	END;
GETDEN:	PRINT("  DENSITY(");  FLAG_FALSE;
	FOR I_1 STEP 1 UNTIL 5 DO BEGIN
	  TEMP_TEMP LSH 1;
	  IF TEMP < 0 THEN BEGIN
	    IF FLAG THEN PRINT(",");
	    PRINT(TAPDENS[I]);
	    FLAG_TRUE;
	  END;
	END;
	PRINT("):  ");
	DENSITY_GETNUM;
	TEMP_ADDR LSH 12;  FLAG_FALSE;
	FOR I_1 STEP 1 UNTIL 5 DO BEGIN
	  TEMP_TEMP LSH 1;
	  IF TEMP < 0 THEN
	    IF TAPDENS[I] = DENSITY THEN FLAG_TRUE
	END;
	IF FLAG = FALSE THEN BEGIN
	  ERRMSG(BAD!DEN);  GO TO GETDEN;
	END;
	IF TRACKS = 9 THEN BEGIN
	  PARITY_"ODD";  PRINT("  PARITY:  ",PARITY,CRLF);
	END ELSE
	  PARITY_GETKEY("  PARITY:  ",PARITIES,PARITY,PRINTOLD);
	IF EQU(PARITY,"EVEN") THEN SETSTS(INCHAN,'371017);
GETFIL:	PARAM_GETKEY("OUTPUT TO FILE?  ",YORN,PARAM,0);
	IF PARAM = NULL THEN BEGIN
	  ERRMSG(BAD!RES);  GO TO GETFIL;
	END;
	IF EQU(PARAM,"YES") THEN BEGIN
COMMENT *****  THE FOLLOWING IS TEMPORARY  *****
	TO BE REPLACE WITH A SUBROUTINE GETFILE;
GETFL1:	  PARAM_"JUNK.TMP";
	  IF EQU(PARAM,NULL) THEN GO TO REPSIZ;
	  IF EQU(PARAM,OUTFILE) THEN GO TO REPSIZ;
	  OPEN(FILCHN,"DSK",'370000,0,2,FILEOF,FILEOF,FILEOF);
	  IF FILEOF THEN BEGIN
	    ERRMSG(NODSK);  RETURN;
	  END;
	  OUTFILE_PARAM;
	  LOOKUP(FILCHN,OUTFILE,I);
GETANS:	  PARAM_GETKEY((IF I=0 THEN "OLD FILE?  " ELSE
	    "NEW FILE?  "),YORN,PARAM,0);
	  IF PARAM = NULL THEN BEGIN
	    ERRMSG(BAD!RES);  GO TO GETANS;
	  END;
	  IF EQU(PARAM,"NO") THEN GO TO GETFL1;
	END ELSE OUTFILE_"UNDEFINED";
REPSIZ:	PARAM_GETKEY("REPORT SIZE:  ",FORMS,REPORT!SIZE,
	  PRINTOLD);
	IF NOT EQU(PARAM,NULL) THEN REPORT!SIZE_PARAM;
GETHDC:	PARAM_GETKEY("HARD COPY?  ",YORN,PARAM,PRINTOLD);
	IF PARAM NEQ NULL THEN ECHO_PARAM;
	IF EQU(ECHO,"YES") THEN BEGIN
	  PARAM_GETKEY("  DEVICE:  ",HARDCOPY,PRTDEV,PRINTOLD);
	  IF PARAM = NULL THEN BEGIN
	    ERRMSG(BAD!RES);  GO TO GETHDC;
	  END ELSE PRTCHN_0;
	  PRTDEV_PARAM;
	END;
	IF PRTDEV = "LPT" THEN BEGIN
	  OPEN(EXTCHN,PRTDEV,0,0,2,PRTEOF,PRTEOF,PRTEOF);
	  IF PRTEOF NEQ 0 THEN BEGIN
	    ERRMSG(NOLPT);  GO TO GETHDC;
	  END;
	  PRTCHN_EXTCHN;
	END;
	PARAM_GETKEY("SYMBOLIC MODE:  ",MODES,SYM!MODE,
	  PRINTOLD);
	IF NOT EQU(PARAM,NULL) THEN SYM!MODE_PARAM;
	PARAM_GETKEY("FSTAR TAPE:  ",YORN,FSTAR,PRINTOLD);
	IF NOT EQU(PARAM,NULL) THEN FSTAR_PARAM;
	RETURN;
END "GET OPTION VALUES";


INTEGER PROCEDURE PROMPT;
BEGIN "PROMPT"
	GETVAL(1);
	RETURN(0);
END "PROMPT";


INTEGER PROCEDURE QUIT;
BEGIN "QUIT"
	RETURN (-1);
END "QUIT";


INTEGER PROCEDURE REWIND;
BEGIN "REWIND TAPE"
	MTAPE(INCHAN,"W");
	FILENUM_RECDNUM_1;
	EOF!FOUND_EOT!FOUND_FALSE;
	RETURN (BOT);
END "REWIND TAPE";


INTEGER PROCEDURE SYMBOL(STRING ARRAY PARAMS; INTEGER ARRAY
	DELMTRS);
BEGIN "SYMBOL"
	INTEGER I;

	IF EQU(PARAMS[1],NULL) THEN BEGIN
	  PRINT("ANALYSIS:  ",SYM!MODE," ",(IF EQU(FSTAR,"YES")
	    THEN "FSTAR" ELSE NULL),CRLF);
	  RETURN (0);
	END;
	I_STRSRC(MODES,PARAMS[1]);
	IF NOT I THEN RETURN (DELMTRS[3] LAND '777777000000
	  + BADPAR);
	SYM!MODE_MODES[I];  FSTAR_"NO";
	IF EQU(PARAMS[2],NULL) THEN RETURN (0);
	IF NOT STRSRC(TAPE!ANAL,PARAMS[2]) THEN RETURN
	  (DELMTRS[5] LAND '777777000000 + BADPAR);
	FSTAR_"YES";
	RETURN (0);
END "SYMBOL";


INTEGER PROCEDURE XCTCMD(STRING CMDBUF);
BEGIN
	INTEGER ARRAY DELIMS[0:2*LENGTH(CMDBUF)];
	STRING TOKBUF;
	STRING ARRAY PARAMS[0:3];
	INTEGER I,J,K;

	DELSCN(CMDBUF,TOKBUF,CMDBRK,DELIMS,0,TRUE);
	ARRCLR(PARAMS);
	FOR K_1 STEP 1 UNTIL DELIMS[0] DO BEGIN
	  I_(DELIMS[2*K-1] LSH -18) LAND '777777;
	  J_DELIMS[2*K-1] LAND '777777;
	  PARAMS[K-1]_TOKBUF[I FOR J];
	END;
	I_STRSRC(COMNDS,PARAMS[0]);
	IF I AND (DELIMS[0] > NUMPAR[I]) THEN RETURN (TOOMANY);
	CASE I OF BEGIN
[0]	  RETURN (NOMATCH);
[1]	  RETURN (ADVBAK("A",PARAMS,DELIMS));
[2]	  RETURN (ADVBAK("B",PARAMS,DELIMS));
[3]	  RETURN (DUMP(PARAMS,DELIMS));
[4]	  RETURN (FORMAT(PARAMS,DELIMS));
[5]	  RETURN (HELP);
[6]	  RETURN (INPUT(PARAMS,DELIMS));
[7]	  RETURN (OPTION);
[8]	  RETURN (OUTPUT(PARAMS,DELIMS));
[9]	  RETURN (PROMPT);
[10]	  RETURN (QUIT);
[11]	  RETURN (REWIND);
[12]	  RETURN (NUMBER(PARAMS,DELIMS));
[13]	  RETURN (SYMBOL(PARAMS,DELIMS));
[14]	  RETURN (HELP)
	END;
END "XCTCMD";



COMMENT *****  THIS IS THE MAIN PROGRAM  *****

	PRINT("MTDUMP VERSION 1.0"&CRLF);

	BAIL;

	DENSITY_ERRNUM_PRTCHN_0;
	EOF!FOUND_EOT!FOUND_INTAPE_FALSE;
	INDEV_PARITY_OUTFILE_REPORT!SIZE_ECHO_SYM!MODE_
	  "UNDEFINED";
	RECDNUM_FILENUM_1;
	FSTAR_NULL;
	CMDBRK_GETBREAK;
	SETBREAK(CMDBRK," "&'11,NULL,"INS");
	BRK!BLNK_GETBREAK;
	SETBREAK(BRK!BLNK," "&'11,NULL,"XR");
	GETVAL(0);
	WHILE ERRNUM GEQ 0 DO BEGIN
	  PRINT("*");
	  TTYI_INCHWL;
	  ERRNUM _ XCTCMD(TTYI);
	  SETPRINT(NULL,"T");
	  IF ERRNUM > 0 THEN ERRMSG(ERRNUM);
	END;
	PRINT ("END MTDUMP");
END "MTDUMP";
   	 yÿ